<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Stand-alone interactive HTML movie (sihm)</title>
    </head>

    <body>
        <p>
            This was generated by
            <a href="https://github.com/leakec/sihm">sihm</a>
        </p>
        <script>
            /*! For license information please see main.js.LICENSE.txt */
            (() => {
                "use strict";
                const t = "148",
                    e = 100,
                    n = 301,
                    i = 302,
                    r = 306,
                    a = 1e3,
                    s = 1001,
                    o = 1002,
                    l = 1003,
                    c = 1005,
                    h = 1006,
                    u = 1008,
                    d = 1009,
                    p = 1014,
                    f = 1015,
                    m = 1016,
                    g = 1020,
                    v = 1023,
                    x = 1026,
                    b = 1027,
                    y = 33776,
                    S = 33777,
                    M = 33778,
                    A = 33779,
                    _ = 2300,
                    w = 2301,
                    T = 2302,
                    E = 2400,
                    R = 2401,
                    k = 2402,
                    C = 3e3,
                    L = 3001,
                    I = "srgb",
                    O = "srgb-linear",
                    D = 7680,
                    P = "300 es",
                    U = 1035;
                class V {
                    addEventListener(t, e) {
                        void 0 === this._listeners && (this._listeners = {});
                        const n = this._listeners;
                        void 0 === n[t] && (n[t] = []),
                            -1 === n[t].indexOf(e) && n[t].push(e);
                    }
                    hasEventListener(t, e) {
                        if (void 0 === this._listeners) return !1;
                        const n = this._listeners;
                        return void 0 !== n[t] && -1 !== n[t].indexOf(e);
                    }
                    removeEventListener(t, e) {
                        if (void 0 === this._listeners) return;
                        const n = this._listeners[t];
                        if (void 0 !== n) {
                            const t = n.indexOf(e);
                            -1 !== t && n.splice(t, 1);
                        }
                    }
                    dispatchEvent(t) {
                        if (void 0 === this._listeners) return;
                        const e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            const n = e.slice(0);
                            for (let e = 0, i = n.length; e < i; e++)
                                n[e].call(this, t);
                            t.target = null;
                        }
                    }
                }
                const N = [
                        "00",
                        "01",
                        "02",
                        "03",
                        "04",
                        "05",
                        "06",
                        "07",
                        "08",
                        "09",
                        "0a",
                        "0b",
                        "0c",
                        "0d",
                        "0e",
                        "0f",
                        "10",
                        "11",
                        "12",
                        "13",
                        "14",
                        "15",
                        "16",
                        "17",
                        "18",
                        "19",
                        "1a",
                        "1b",
                        "1c",
                        "1d",
                        "1e",
                        "1f",
                        "20",
                        "21",
                        "22",
                        "23",
                        "24",
                        "25",
                        "26",
                        "27",
                        "28",
                        "29",
                        "2a",
                        "2b",
                        "2c",
                        "2d",
                        "2e",
                        "2f",
                        "30",
                        "31",
                        "32",
                        "33",
                        "34",
                        "35",
                        "36",
                        "37",
                        "38",
                        "39",
                        "3a",
                        "3b",
                        "3c",
                        "3d",
                        "3e",
                        "3f",
                        "40",
                        "41",
                        "42",
                        "43",
                        "44",
                        "45",
                        "46",
                        "47",
                        "48",
                        "49",
                        "4a",
                        "4b",
                        "4c",
                        "4d",
                        "4e",
                        "4f",
                        "50",
                        "51",
                        "52",
                        "53",
                        "54",
                        "55",
                        "56",
                        "57",
                        "58",
                        "59",
                        "5a",
                        "5b",
                        "5c",
                        "5d",
                        "5e",
                        "5f",
                        "60",
                        "61",
                        "62",
                        "63",
                        "64",
                        "65",
                        "66",
                        "67",
                        "68",
                        "69",
                        "6a",
                        "6b",
                        "6c",
                        "6d",
                        "6e",
                        "6f",
                        "70",
                        "71",
                        "72",
                        "73",
                        "74",
                        "75",
                        "76",
                        "77",
                        "78",
                        "79",
                        "7a",
                        "7b",
                        "7c",
                        "7d",
                        "7e",
                        "7f",
                        "80",
                        "81",
                        "82",
                        "83",
                        "84",
                        "85",
                        "86",
                        "87",
                        "88",
                        "89",
                        "8a",
                        "8b",
                        "8c",
                        "8d",
                        "8e",
                        "8f",
                        "90",
                        "91",
                        "92",
                        "93",
                        "94",
                        "95",
                        "96",
                        "97",
                        "98",
                        "99",
                        "9a",
                        "9b",
                        "9c",
                        "9d",
                        "9e",
                        "9f",
                        "a0",
                        "a1",
                        "a2",
                        "a3",
                        "a4",
                        "a5",
                        "a6",
                        "a7",
                        "a8",
                        "a9",
                        "aa",
                        "ab",
                        "ac",
                        "ad",
                        "ae",
                        "af",
                        "b0",
                        "b1",
                        "b2",
                        "b3",
                        "b4",
                        "b5",
                        "b6",
                        "b7",
                        "b8",
                        "b9",
                        "ba",
                        "bb",
                        "bc",
                        "bd",
                        "be",
                        "bf",
                        "c0",
                        "c1",
                        "c2",
                        "c3",
                        "c4",
                        "c5",
                        "c6",
                        "c7",
                        "c8",
                        "c9",
                        "ca",
                        "cb",
                        "cc",
                        "cd",
                        "ce",
                        "cf",
                        "d0",
                        "d1",
                        "d2",
                        "d3",
                        "d4",
                        "d5",
                        "d6",
                        "d7",
                        "d8",
                        "d9",
                        "da",
                        "db",
                        "dc",
                        "dd",
                        "de",
                        "df",
                        "e0",
                        "e1",
                        "e2",
                        "e3",
                        "e4",
                        "e5",
                        "e6",
                        "e7",
                        "e8",
                        "e9",
                        "ea",
                        "eb",
                        "ec",
                        "ed",
                        "ee",
                        "ef",
                        "f0",
                        "f1",
                        "f2",
                        "f3",
                        "f4",
                        "f5",
                        "f6",
                        "f7",
                        "f8",
                        "f9",
                        "fa",
                        "fb",
                        "fc",
                        "fd",
                        "fe",
                        "ff",
                    ],
                    G = Math.PI / 180,
                    j = 180 / Math.PI;
                function H() {
                    const t = (4294967295 * Math.random()) | 0,
                        e = (4294967295 * Math.random()) | 0,
                        n = (4294967295 * Math.random()) | 0,
                        i = (4294967295 * Math.random()) | 0;
                    return (
                        N[255 & t] +
                        N[(t >> 8) & 255] +
                        N[(t >> 16) & 255] +
                        N[(t >> 24) & 255] +
                        "-" +
                        N[255 & e] +
                        N[(e >> 8) & 255] +
                        "-" +
                        N[((e >> 16) & 15) | 64] +
                        N[(e >> 24) & 255] +
                        "-" +
                        N[(63 & n) | 128] +
                        N[(n >> 8) & 255] +
                        "-" +
                        N[(n >> 16) & 255] +
                        N[(n >> 24) & 255] +
                        N[255 & i] +
                        N[(i >> 8) & 255] +
                        N[(i >> 16) & 255] +
                        N[(i >> 24) & 255]
                    ).toLowerCase();
                }
                function F(t, e, n) {
                    return Math.max(e, Math.min(n, t));
                }
                function B(t, e, n) {
                    return (1 - n) * t + n * e;
                }
                function z(t) {
                    return 0 == (t & (t - 1)) && 0 !== t;
                }
                function W(t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
                }
                function q(t, e) {
                    switch (e.constructor) {
                        case Float32Array:
                            return t;
                        case Uint16Array:
                            return t / 65535;
                        case Uint8Array:
                            return t / 255;
                        case Int16Array:
                            return Math.max(t / 32767, -1);
                        case Int8Array:
                            return Math.max(t / 127, -1);
                        default:
                            throw new Error("Invalid component type.");
                    }
                }
                function Y(t, e) {
                    switch (e.constructor) {
                        case Float32Array:
                            return t;
                        case Uint16Array:
                            return Math.round(65535 * t);
                        case Uint8Array:
                            return Math.round(255 * t);
                        case Int16Array:
                            return Math.round(32767 * t);
                        case Int8Array:
                            return Math.round(127 * t);
                        default:
                            throw new Error("Invalid component type.");
                    }
                }
                class K {
                    constructor(t = 0, e = 0) {
                        (K.prototype.isVector2 = !0),
                            (this.x = t),
                            (this.y = e);
                    }
                    get width() {
                        return this.x;
                    }
                    set width(t) {
                        this.x = t;
                    }
                    get height() {
                        return this.y;
                    }
                    set height(t) {
                        this.y = t;
                    }
                    set(t, e) {
                        return (this.x = t), (this.y = e), this;
                    }
                    setScalar(t) {
                        return (this.x = t), (this.y = t), this;
                    }
                    setX(t) {
                        return (this.x = t), this;
                    }
                    setY(t) {
                        return (this.y = t), this;
                    }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t);
                        }
                        return this;
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            default:
                                throw new Error("index is out of range: " + t);
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y);
                    }
                    copy(t) {
                        return (this.x = t.x), (this.y = t.y), this;
                    }
                    add(t) {
                        return (this.x += t.x), (this.y += t.y), this;
                    }
                    addScalar(t) {
                        return (this.x += t), (this.y += t), this;
                    }
                    addVectors(t, e) {
                        return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
                    }
                    addScaledVector(t, e) {
                        return (this.x += t.x * e), (this.y += t.y * e), this;
                    }
                    sub(t) {
                        return (this.x -= t.x), (this.y -= t.y), this;
                    }
                    subScalar(t) {
                        return (this.x -= t), (this.y -= t), this;
                    }
                    subVectors(t, e) {
                        return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
                    }
                    multiply(t) {
                        return (this.x *= t.x), (this.y *= t.y), this;
                    }
                    multiplyScalar(t) {
                        return (this.x *= t), (this.y *= t), this;
                    }
                    divide(t) {
                        return (this.x /= t.x), (this.y /= t.y), this;
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t);
                    }
                    applyMatrix3(t) {
                        const e = this.x,
                            n = this.y,
                            i = t.elements;
                        return (
                            (this.x = i[0] * e + i[3] * n + i[6]),
                            (this.y = i[1] * e + i[4] * n + i[7]),
                            this
                        );
                    }
                    min(t) {
                        return (
                            (this.x = Math.min(this.x, t.x)),
                            (this.y = Math.min(this.y, t.y)),
                            this
                        );
                    }
                    max(t) {
                        return (
                            (this.x = Math.max(this.x, t.x)),
                            (this.y = Math.max(this.y, t.y)),
                            this
                        );
                    }
                    clamp(t, e) {
                        return (
                            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                            this
                        );
                    }
                    clampScalar(t, e) {
                        return (
                            (this.x = Math.max(t, Math.min(e, this.x))),
                            (this.y = Math.max(t, Math.min(e, this.y))),
                            this
                        );
                    }
                    clampLength(t, e) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(
                            Math.max(t, Math.min(e, n)),
                        );
                    }
                    floor() {
                        return (
                            (this.x = Math.floor(this.x)),
                            (this.y = Math.floor(this.y)),
                            this
                        );
                    }
                    ceil() {
                        return (
                            (this.x = Math.ceil(this.x)),
                            (this.y = Math.ceil(this.y)),
                            this
                        );
                    }
                    round() {
                        return (
                            (this.x = Math.round(this.x)),
                            (this.y = Math.round(this.y)),
                            this
                        );
                    }
                    roundToZero() {
                        return (
                            (this.x =
                                this.x < 0
                                    ? Math.ceil(this.x)
                                    : Math.floor(this.x)),
                            (this.y =
                                this.y < 0
                                    ? Math.ceil(this.y)
                                    : Math.floor(this.y)),
                            this
                        );
                    }
                    negate() {
                        return (this.x = -this.x), (this.y = -this.y), this;
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y;
                    }
                    cross(t) {
                        return this.x * t.y - this.y * t.x;
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y;
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y);
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y);
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1);
                    }
                    angle() {
                        return Math.atan2(-this.y, -this.x) + Math.PI;
                    }
                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t));
                    }
                    distanceToSquared(t) {
                        const e = this.x - t.x,
                            n = this.y - t.y;
                        return e * e + n * n;
                    }
                    manhattanDistanceTo(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t);
                    }
                    lerp(t, e) {
                        return (
                            (this.x += (t.x - this.x) * e),
                            (this.y += (t.y - this.y) * e),
                            this
                        );
                    }
                    lerpVectors(t, e, n) {
                        return (
                            (this.x = t.x + (e.x - t.x) * n),
                            (this.y = t.y + (e.y - t.y) * n),
                            this
                        );
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y;
                    }
                    fromArray(t, e = 0) {
                        return (this.x = t[e]), (this.y = t[e + 1]), this;
                    }
                    toArray(t = [], e = 0) {
                        return (t[e] = this.x), (t[e + 1] = this.y), t;
                    }
                    fromBufferAttribute(t, e) {
                        return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
                    }
                    rotateAround(t, e) {
                        const n = Math.cos(e),
                            i = Math.sin(e),
                            r = this.x - t.x,
                            a = this.y - t.y;
                        return (
                            (this.x = r * n - a * i + t.x),
                            (this.y = r * i + a * n + t.y),
                            this
                        );
                    }
                    random() {
                        return (
                            (this.x = Math.random()),
                            (this.y = Math.random()),
                            this
                        );
                    }
                    *[Symbol.iterator]() {
                        yield this.x, yield this.y;
                    }
                }
                class J {
                    constructor() {
                        (J.prototype.isMatrix3 = !0),
                            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
                    }
                    set(t, e, n, i, r, a, s, o, l) {
                        const c = this.elements;
                        return (
                            (c[0] = t),
                            (c[1] = i),
                            (c[2] = s),
                            (c[3] = e),
                            (c[4] = r),
                            (c[5] = o),
                            (c[6] = n),
                            (c[7] = a),
                            (c[8] = l),
                            this
                        );
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
                    }
                    copy(t) {
                        const e = this.elements,
                            n = t.elements;
                        return (
                            (e[0] = n[0]),
                            (e[1] = n[1]),
                            (e[2] = n[2]),
                            (e[3] = n[3]),
                            (e[4] = n[4]),
                            (e[5] = n[5]),
                            (e[6] = n[6]),
                            (e[7] = n[7]),
                            (e[8] = n[8]),
                            this
                        );
                    }
                    extractBasis(t, e, n) {
                        return (
                            t.setFromMatrix3Column(this, 0),
                            e.setFromMatrix3Column(this, 1),
                            n.setFromMatrix3Column(this, 2),
                            this
                        );
                    }
                    setFromMatrix4(t) {
                        const e = t.elements;
                        return (
                            this.set(
                                e[0],
                                e[4],
                                e[8],
                                e[1],
                                e[5],
                                e[9],
                                e[2],
                                e[6],
                                e[10],
                            ),
                            this
                        );
                    }
                    multiply(t) {
                        return this.multiplyMatrices(this, t);
                    }
                    premultiply(t) {
                        return this.multiplyMatrices(t, this);
                    }
                    multiplyMatrices(t, e) {
                        const n = t.elements,
                            i = e.elements,
                            r = this.elements,
                            a = n[0],
                            s = n[3],
                            o = n[6],
                            l = n[1],
                            c = n[4],
                            h = n[7],
                            u = n[2],
                            d = n[5],
                            p = n[8],
                            f = i[0],
                            m = i[3],
                            g = i[6],
                            v = i[1],
                            x = i[4],
                            b = i[7],
                            y = i[2],
                            S = i[5],
                            M = i[8];
                        return (
                            (r[0] = a * f + s * v + o * y),
                            (r[3] = a * m + s * x + o * S),
                            (r[6] = a * g + s * b + o * M),
                            (r[1] = l * f + c * v + h * y),
                            (r[4] = l * m + c * x + h * S),
                            (r[7] = l * g + c * b + h * M),
                            (r[2] = u * f + d * v + p * y),
                            (r[5] = u * m + d * x + p * S),
                            (r[8] = u * g + d * b + p * M),
                            this
                        );
                    }
                    multiplyScalar(t) {
                        const e = this.elements;
                        return (
                            (e[0] *= t),
                            (e[3] *= t),
                            (e[6] *= t),
                            (e[1] *= t),
                            (e[4] *= t),
                            (e[7] *= t),
                            (e[2] *= t),
                            (e[5] *= t),
                            (e[8] *= t),
                            this
                        );
                    }
                    determinant() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            a = t[4],
                            s = t[5],
                            o = t[6],
                            l = t[7],
                            c = t[8];
                        return (
                            e * a * c -
                            e * s * l -
                            n * r * c +
                            n * s * o +
                            i * r * l -
                            i * a * o
                        );
                    }
                    invert() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            a = t[4],
                            s = t[5],
                            o = t[6],
                            l = t[7],
                            c = t[8],
                            h = c * a - s * l,
                            u = s * o - c * r,
                            d = l * r - a * o,
                            p = e * h + n * u + i * d;
                        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const f = 1 / p;
                        return (
                            (t[0] = h * f),
                            (t[1] = (i * l - c * n) * f),
                            (t[2] = (s * n - i * a) * f),
                            (t[3] = u * f),
                            (t[4] = (c * e - i * o) * f),
                            (t[5] = (i * r - s * e) * f),
                            (t[6] = d * f),
                            (t[7] = (n * o - l * e) * f),
                            (t[8] = (a * e - n * r) * f),
                            this
                        );
                    }
                    transpose() {
                        let t;
                        const e = this.elements;
                        return (
                            (t = e[1]),
                            (e[1] = e[3]),
                            (e[3] = t),
                            (t = e[2]),
                            (e[2] = e[6]),
                            (e[6] = t),
                            (t = e[5]),
                            (e[5] = e[7]),
                            (e[7] = t),
                            this
                        );
                    }
                    getNormalMatrix(t) {
                        return this.setFromMatrix4(t).invert().transpose();
                    }
                    transposeIntoArray(t) {
                        const e = this.elements;
                        return (
                            (t[0] = e[0]),
                            (t[1] = e[3]),
                            (t[2] = e[6]),
                            (t[3] = e[1]),
                            (t[4] = e[4]),
                            (t[5] = e[7]),
                            (t[6] = e[2]),
                            (t[7] = e[5]),
                            (t[8] = e[8]),
                            this
                        );
                    }
                    setUvTransform(t, e, n, i, r, a, s) {
                        const o = Math.cos(r),
                            l = Math.sin(r);
                        return (
                            this.set(
                                n * o,
                                n * l,
                                -n * (o * a + l * s) + a + t,
                                -i * l,
                                i * o,
                                -i * (-l * a + o * s) + s + e,
                                0,
                                0,
                                1,
                            ),
                            this
                        );
                    }
                    scale(t, e) {
                        return this.premultiply(Z.makeScale(t, e)), this;
                    }
                    rotate(t) {
                        return this.premultiply(Z.makeRotation(-t)), this;
                    }
                    translate(t, e) {
                        return this.premultiply(Z.makeTranslation(t, e)), this;
                    }
                    makeTranslation(t, e) {
                        return this.set(1, 0, t, 0, 1, e, 0, 0, 1), this;
                    }
                    makeRotation(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this;
                    }
                    makeScale(t, e) {
                        return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
                    }
                    equals(t) {
                        const e = this.elements,
                            n = t.elements;
                        for (let t = 0; t < 9; t++)
                            if (e[t] !== n[t]) return !1;
                        return !0;
                    }
                    fromArray(t, e = 0) {
                        for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                        return this;
                    }
                    toArray(t = [], e = 0) {
                        const n = this.elements;
                        return (
                            (t[e] = n[0]),
                            (t[e + 1] = n[1]),
                            (t[e + 2] = n[2]),
                            (t[e + 3] = n[3]),
                            (t[e + 4] = n[4]),
                            (t[e + 5] = n[5]),
                            (t[e + 6] = n[6]),
                            (t[e + 7] = n[7]),
                            (t[e + 8] = n[8]),
                            t
                        );
                    }
                    clone() {
                        return new this.constructor().fromArray(this.elements);
                    }
                }
                const Z = new J();
                function X(t) {
                    for (let e = t.length - 1; e >= 0; --e)
                        if (t[e] >= 65535) return !0;
                    return !1;
                }
                function Q(t) {
                    return document.createElementNS(
                        "http://www.w3.org/1999/xhtml",
                        t,
                    );
                }
                function $(t) {
                    return t < 0.04045
                        ? 0.0773993808 * t
                        : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
                }
                function tt(t) {
                    return t < 0.0031308
                        ? 12.92 * t
                        : 1.055 * Math.pow(t, 0.41666) - 0.055;
                }
                Int8Array,
                    Uint8Array,
                    Uint8ClampedArray,
                    Int16Array,
                    Uint16Array,
                    Int32Array,
                    Uint32Array,
                    Float32Array,
                    Float64Array;
                const et = { [I]: { [O]: $ }, [O]: { [I]: tt } },
                    nt = {
                        legacyMode: !0,
                        get workingColorSpace() {
                            return O;
                        },
                        set workingColorSpace(t) {
                            console.warn(
                                "THREE.ColorManagement: .workingColorSpace is readonly.",
                            );
                        },
                        convert: function (t, e, n) {
                            if (this.legacyMode || e === n || !e || !n)
                                return t;
                            if (et[e] && void 0 !== et[e][n]) {
                                const i = et[e][n];
                                return (
                                    (t.r = i(t.r)),
                                    (t.g = i(t.g)),
                                    (t.b = i(t.b)),
                                    t
                                );
                            }
                            throw new Error(
                                "Unsupported color space conversion.",
                            );
                        },
                        fromWorkingColorSpace: function (t, e) {
                            return this.convert(t, this.workingColorSpace, e);
                        },
                        toWorkingColorSpace: function (t, e) {
                            return this.convert(t, e, this.workingColorSpace);
                        },
                    },
                    it = {
                        aliceblue: 15792383,
                        antiquewhite: 16444375,
                        aqua: 65535,
                        aquamarine: 8388564,
                        azure: 15794175,
                        beige: 16119260,
                        bisque: 16770244,
                        black: 0,
                        blanchedalmond: 16772045,
                        blue: 255,
                        blueviolet: 9055202,
                        brown: 10824234,
                        burlywood: 14596231,
                        cadetblue: 6266528,
                        chartreuse: 8388352,
                        chocolate: 13789470,
                        coral: 16744272,
                        cornflowerblue: 6591981,
                        cornsilk: 16775388,
                        crimson: 14423100,
                        cyan: 65535,
                        darkblue: 139,
                        darkcyan: 35723,
                        darkgoldenrod: 12092939,
                        darkgray: 11119017,
                        darkgreen: 25600,
                        darkgrey: 11119017,
                        darkkhaki: 12433259,
                        darkmagenta: 9109643,
                        darkolivegreen: 5597999,
                        darkorange: 16747520,
                        darkorchid: 10040012,
                        darkred: 9109504,
                        darksalmon: 15308410,
                        darkseagreen: 9419919,
                        darkslateblue: 4734347,
                        darkslategray: 3100495,
                        darkslategrey: 3100495,
                        darkturquoise: 52945,
                        darkviolet: 9699539,
                        deeppink: 16716947,
                        deepskyblue: 49151,
                        dimgray: 6908265,
                        dimgrey: 6908265,
                        dodgerblue: 2003199,
                        firebrick: 11674146,
                        floralwhite: 16775920,
                        forestgreen: 2263842,
                        fuchsia: 16711935,
                        gainsboro: 14474460,
                        ghostwhite: 16316671,
                        gold: 16766720,
                        goldenrod: 14329120,
                        gray: 8421504,
                        green: 32768,
                        greenyellow: 11403055,
                        grey: 8421504,
                        honeydew: 15794160,
                        hotpink: 16738740,
                        indianred: 13458524,
                        indigo: 4915330,
                        ivory: 16777200,
                        khaki: 15787660,
                        lavender: 15132410,
                        lavenderblush: 16773365,
                        lawngreen: 8190976,
                        lemonchiffon: 16775885,
                        lightblue: 11393254,
                        lightcoral: 15761536,
                        lightcyan: 14745599,
                        lightgoldenrodyellow: 16448210,
                        lightgray: 13882323,
                        lightgreen: 9498256,
                        lightgrey: 13882323,
                        lightpink: 16758465,
                        lightsalmon: 16752762,
                        lightseagreen: 2142890,
                        lightskyblue: 8900346,
                        lightslategray: 7833753,
                        lightslategrey: 7833753,
                        lightsteelblue: 11584734,
                        lightyellow: 16777184,
                        lime: 65280,
                        limegreen: 3329330,
                        linen: 16445670,
                        magenta: 16711935,
                        maroon: 8388608,
                        mediumaquamarine: 6737322,
                        mediumblue: 205,
                        mediumorchid: 12211667,
                        mediumpurple: 9662683,
                        mediumseagreen: 3978097,
                        mediumslateblue: 8087790,
                        mediumspringgreen: 64154,
                        mediumturquoise: 4772300,
                        mediumvioletred: 13047173,
                        midnightblue: 1644912,
                        mintcream: 16121850,
                        mistyrose: 16770273,
                        moccasin: 16770229,
                        navajowhite: 16768685,
                        navy: 128,
                        oldlace: 16643558,
                        olive: 8421376,
                        olivedrab: 7048739,
                        orange: 16753920,
                        orangered: 16729344,
                        orchid: 14315734,
                        palegoldenrod: 15657130,
                        palegreen: 10025880,
                        paleturquoise: 11529966,
                        palevioletred: 14381203,
                        papayawhip: 16773077,
                        peachpuff: 16767673,
                        peru: 13468991,
                        pink: 16761035,
                        plum: 14524637,
                        powderblue: 11591910,
                        purple: 8388736,
                        rebeccapurple: 6697881,
                        red: 16711680,
                        rosybrown: 12357519,
                        royalblue: 4286945,
                        saddlebrown: 9127187,
                        salmon: 16416882,
                        sandybrown: 16032864,
                        seagreen: 3050327,
                        seashell: 16774638,
                        sienna: 10506797,
                        silver: 12632256,
                        skyblue: 8900331,
                        slateblue: 6970061,
                        slategray: 7372944,
                        slategrey: 7372944,
                        snow: 16775930,
                        springgreen: 65407,
                        steelblue: 4620980,
                        tan: 13808780,
                        teal: 32896,
                        thistle: 14204888,
                        tomato: 16737095,
                        turquoise: 4251856,
                        violet: 15631086,
                        wheat: 16113331,
                        white: 16777215,
                        whitesmoke: 16119285,
                        yellow: 16776960,
                        yellowgreen: 10145074,
                    },
                    rt = { r: 0, g: 0, b: 0 },
                    at = { h: 0, s: 0, l: 0 },
                    st = { h: 0, s: 0, l: 0 };
                function ot(t, e, n) {
                    return (
                        n < 0 && (n += 1),
                        n > 1 && (n -= 1),
                        n < 1 / 6
                            ? t + 6 * (e - t) * n
                            : n < 0.5
                            ? e
                            : n < 2 / 3
                            ? t + 6 * (e - t) * (2 / 3 - n)
                            : t
                    );
                }
                function lt(t, e) {
                    return (e.r = t.r), (e.g = t.g), (e.b = t.b), e;
                }
                class ct {
                    constructor(t, e, n) {
                        return (
                            (this.isColor = !0),
                            (this.r = 1),
                            (this.g = 1),
                            (this.b = 1),
                            void 0 === e && void 0 === n
                                ? this.set(t)
                                : this.setRGB(t, e, n)
                        );
                    }
                    set(t) {
                        return (
                            t && t.isColor
                                ? this.copy(t)
                                : "number" == typeof t
                                ? this.setHex(t)
                                : "string" == typeof t && this.setStyle(t),
                            this
                        );
                    }
                    setScalar(t) {
                        return (this.r = t), (this.g = t), (this.b = t), this;
                    }
                    setHex(t, e = I) {
                        return (
                            (t = Math.floor(t)),
                            (this.r = ((t >> 16) & 255) / 255),
                            (this.g = ((t >> 8) & 255) / 255),
                            (this.b = (255 & t) / 255),
                            nt.toWorkingColorSpace(this, e),
                            this
                        );
                    }
                    setRGB(t, e, n, i = nt.workingColorSpace) {
                        return (
                            (this.r = t),
                            (this.g = e),
                            (this.b = n),
                            nt.toWorkingColorSpace(this, i),
                            this
                        );
                    }
                    setHSL(t, e, n, i = nt.workingColorSpace) {
                        if (
                            ((t = ((t % (r = 1)) + r) % r),
                            (e = F(e, 0, 1)),
                            (n = F(n, 0, 1)),
                            0 === e)
                        )
                            this.r = this.g = this.b = n;
                        else {
                            const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
                                r = 2 * n - i;
                            (this.r = ot(r, i, t + 1 / 3)),
                                (this.g = ot(r, i, t)),
                                (this.b = ot(r, i, t - 1 / 3));
                        }
                        var r;
                        return nt.toWorkingColorSpace(this, i), this;
                    }
                    setStyle(t, e = I) {
                        function n(e) {
                            void 0 !== e &&
                                parseFloat(e) < 1 &&
                                console.warn(
                                    "THREE.Color: Alpha component of " +
                                        t +
                                        " will be ignored.",
                                );
                        }
                        let i;
                        if ((i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
                            let t;
                            const r = i[1],
                                a = i[2];
                            switch (r) {
                                case "rgb":
                                case "rgba":
                                    if (
                                        (t =
                                            /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                                a,
                                            ))
                                    )
                                        return (
                                            (this.r =
                                                Math.min(
                                                    255,
                                                    parseInt(t[1], 10),
                                                ) / 255),
                                            (this.g =
                                                Math.min(
                                                    255,
                                                    parseInt(t[2], 10),
                                                ) / 255),
                                            (this.b =
                                                Math.min(
                                                    255,
                                                    parseInt(t[3], 10),
                                                ) / 255),
                                            nt.toWorkingColorSpace(this, e),
                                            n(t[4]),
                                            this
                                        );
                                    if (
                                        (t =
                                            /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                                a,
                                            ))
                                    )
                                        return (
                                            (this.r =
                                                Math.min(
                                                    100,
                                                    parseInt(t[1], 10),
                                                ) / 100),
                                            (this.g =
                                                Math.min(
                                                    100,
                                                    parseInt(t[2], 10),
                                                ) / 100),
                                            (this.b =
                                                Math.min(
                                                    100,
                                                    parseInt(t[3], 10),
                                                ) / 100),
                                            nt.toWorkingColorSpace(this, e),
                                            n(t[4]),
                                            this
                                        );
                                    break;
                                case "hsl":
                                case "hsla":
                                    if (
                                        (t =
                                            /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                                a,
                                            ))
                                    ) {
                                        const i = parseFloat(t[1]) / 360,
                                            r = parseFloat(t[2]) / 100,
                                            a = parseFloat(t[3]) / 100;
                                        return n(t[4]), this.setHSL(i, r, a, e);
                                    }
                            }
                        } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
                            const t = i[1],
                                n = t.length;
                            if (3 === n)
                                return (
                                    (this.r =
                                        parseInt(
                                            t.charAt(0) + t.charAt(0),
                                            16,
                                        ) / 255),
                                    (this.g =
                                        parseInt(
                                            t.charAt(1) + t.charAt(1),
                                            16,
                                        ) / 255),
                                    (this.b =
                                        parseInt(
                                            t.charAt(2) + t.charAt(2),
                                            16,
                                        ) / 255),
                                    nt.toWorkingColorSpace(this, e),
                                    this
                                );
                            if (6 === n)
                                return (
                                    (this.r =
                                        parseInt(
                                            t.charAt(0) + t.charAt(1),
                                            16,
                                        ) / 255),
                                    (this.g =
                                        parseInt(
                                            t.charAt(2) + t.charAt(3),
                                            16,
                                        ) / 255),
                                    (this.b =
                                        parseInt(
                                            t.charAt(4) + t.charAt(5),
                                            16,
                                        ) / 255),
                                    nt.toWorkingColorSpace(this, e),
                                    this
                                );
                        }
                        return t && t.length > 0
                            ? this.setColorName(t, e)
                            : this;
                    }
                    setColorName(t, e = I) {
                        const n = it[t.toLowerCase()];
                        return (
                            void 0 !== n
                                ? this.setHex(n, e)
                                : console.warn(
                                      "THREE.Color: Unknown color " + t,
                                  ),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor(this.r, this.g, this.b);
                    }
                    copy(t) {
                        return (
                            (this.r = t.r), (this.g = t.g), (this.b = t.b), this
                        );
                    }
                    copySRGBToLinear(t) {
                        return (
                            (this.r = $(t.r)),
                            (this.g = $(t.g)),
                            (this.b = $(t.b)),
                            this
                        );
                    }
                    copyLinearToSRGB(t) {
                        return (
                            (this.r = tt(t.r)),
                            (this.g = tt(t.g)),
                            (this.b = tt(t.b)),
                            this
                        );
                    }
                    convertSRGBToLinear() {
                        return this.copySRGBToLinear(this), this;
                    }
                    convertLinearToSRGB() {
                        return this.copyLinearToSRGB(this), this;
                    }
                    getHex(t = I) {
                        return (
                            nt.fromWorkingColorSpace(lt(this, rt), t),
                            (F(255 * rt.r, 0, 255) << 16) ^
                                (F(255 * rt.g, 0, 255) << 8) ^
                                (F(255 * rt.b, 0, 255) << 0)
                        );
                    }
                    getHexString(t = I) {
                        return ("000000" + this.getHex(t).toString(16)).slice(
                            -6,
                        );
                    }
                    getHSL(t, e = nt.workingColorSpace) {
                        nt.fromWorkingColorSpace(lt(this, rt), e);
                        const n = rt.r,
                            i = rt.g,
                            r = rt.b,
                            a = Math.max(n, i, r),
                            s = Math.min(n, i, r);
                        let o, l;
                        const c = (s + a) / 2;
                        if (s === a) (o = 0), (l = 0);
                        else {
                            const t = a - s;
                            switch (
                                ((l = c <= 0.5 ? t / (a + s) : t / (2 - a - s)),
                                a)
                            ) {
                                case n:
                                    o = (i - r) / t + (i < r ? 6 : 0);
                                    break;
                                case i:
                                    o = (r - n) / t + 2;
                                    break;
                                case r:
                                    o = (n - i) / t + 4;
                            }
                            o /= 6;
                        }
                        return (t.h = o), (t.s = l), (t.l = c), t;
                    }
                    getRGB(t, e = nt.workingColorSpace) {
                        return (
                            nt.fromWorkingColorSpace(lt(this, rt), e),
                            (t.r = rt.r),
                            (t.g = rt.g),
                            (t.b = rt.b),
                            t
                        );
                    }
                    getStyle(t = I) {
                        return (
                            nt.fromWorkingColorSpace(lt(this, rt), t),
                            t !== I
                                ? `color(${t} ${rt.r} ${rt.g} ${rt.b})`
                                : `rgb(${(255 * rt.r) | 0},${
                                      (255 * rt.g) | 0
                                  },${(255 * rt.b) | 0})`
                        );
                    }
                    offsetHSL(t, e, n) {
                        return (
                            this.getHSL(at),
                            (at.h += t),
                            (at.s += e),
                            (at.l += n),
                            this.setHSL(at.h, at.s, at.l),
                            this
                        );
                    }
                    add(t) {
                        return (
                            (this.r += t.r),
                            (this.g += t.g),
                            (this.b += t.b),
                            this
                        );
                    }
                    addColors(t, e) {
                        return (
                            (this.r = t.r + e.r),
                            (this.g = t.g + e.g),
                            (this.b = t.b + e.b),
                            this
                        );
                    }
                    addScalar(t) {
                        return (
                            (this.r += t), (this.g += t), (this.b += t), this
                        );
                    }
                    sub(t) {
                        return (
                            (this.r = Math.max(0, this.r - t.r)),
                            (this.g = Math.max(0, this.g - t.g)),
                            (this.b = Math.max(0, this.b - t.b)),
                            this
                        );
                    }
                    multiply(t) {
                        return (
                            (this.r *= t.r),
                            (this.g *= t.g),
                            (this.b *= t.b),
                            this
                        );
                    }
                    multiplyScalar(t) {
                        return (
                            (this.r *= t), (this.g *= t), (this.b *= t), this
                        );
                    }
                    lerp(t, e) {
                        return (
                            (this.r += (t.r - this.r) * e),
                            (this.g += (t.g - this.g) * e),
                            (this.b += (t.b - this.b) * e),
                            this
                        );
                    }
                    lerpColors(t, e, n) {
                        return (
                            (this.r = t.r + (e.r - t.r) * n),
                            (this.g = t.g + (e.g - t.g) * n),
                            (this.b = t.b + (e.b - t.b) * n),
                            this
                        );
                    }
                    lerpHSL(t, e) {
                        this.getHSL(at), t.getHSL(st);
                        const n = B(at.h, st.h, e),
                            i = B(at.s, st.s, e),
                            r = B(at.l, st.l, e);
                        return this.setHSL(n, i, r), this;
                    }
                    equals(t) {
                        return (
                            t.r === this.r && t.g === this.g && t.b === this.b
                        );
                    }
                    fromArray(t, e = 0) {
                        return (
                            (this.r = t[e]),
                            (this.g = t[e + 1]),
                            (this.b = t[e + 2]),
                            this
                        );
                    }
                    toArray(t = [], e = 0) {
                        return (
                            (t[e] = this.r),
                            (t[e + 1] = this.g),
                            (t[e + 2] = this.b),
                            t
                        );
                    }
                    fromBufferAttribute(t, e) {
                        return (
                            (this.r = t.getX(e)),
                            (this.g = t.getY(e)),
                            (this.b = t.getZ(e)),
                            this
                        );
                    }
                    toJSON() {
                        return this.getHex();
                    }
                    *[Symbol.iterator]() {
                        yield this.r, yield this.g, yield this.b;
                    }
                }
                let ht;
                ct.NAMES = it;
                class ut {
                    static getDataURL(t) {
                        if (/^data:/i.test(t.src)) return t.src;
                        if ("undefined" == typeof HTMLCanvasElement)
                            return t.src;
                        let e;
                        if (t instanceof HTMLCanvasElement) e = t;
                        else {
                            void 0 === ht && (ht = Q("canvas")),
                                (ht.width = t.width),
                                (ht.height = t.height);
                            const n = ht.getContext("2d");
                            t instanceof ImageData
                                ? n.putImageData(t, 0, 0)
                                : n.drawImage(t, 0, 0, t.width, t.height),
                                (e = ht);
                        }
                        return e.width > 2048 || e.height > 2048
                            ? (console.warn(
                                  "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                                  t,
                              ),
                              e.toDataURL("image/jpeg", 0.6))
                            : e.toDataURL("image/png");
                    }
                    static sRGBToLinear(t) {
                        if (
                            ("undefined" != typeof HTMLImageElement &&
                                t instanceof HTMLImageElement) ||
                            ("undefined" != typeof HTMLCanvasElement &&
                                t instanceof HTMLCanvasElement) ||
                            ("undefined" != typeof ImageBitmap &&
                                t instanceof ImageBitmap)
                        ) {
                            const e = Q("canvas");
                            (e.width = t.width), (e.height = t.height);
                            const n = e.getContext("2d");
                            n.drawImage(t, 0, 0, t.width, t.height);
                            const i = n.getImageData(0, 0, t.width, t.height),
                                r = i.data;
                            for (let t = 0; t < r.length; t++)
                                r[t] = 255 * $(r[t] / 255);
                            return n.putImageData(i, 0, 0), e;
                        }
                        if (t.data) {
                            const e = t.data.slice(0);
                            for (let t = 0; t < e.length; t++)
                                e instanceof Uint8Array ||
                                e instanceof Uint8ClampedArray
                                    ? (e[t] = Math.floor(255 * $(e[t] / 255)))
                                    : (e[t] = $(e[t]));
                            return {
                                data: e,
                                width: t.width,
                                height: t.height,
                            };
                        }
                        return (
                            console.warn(
                                "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.",
                            ),
                            t
                        );
                    }
                }
                class dt {
                    constructor(t = null) {
                        (this.isSource = !0),
                            (this.uuid = H()),
                            (this.data = t),
                            (this.version = 0);
                    }
                    set needsUpdate(t) {
                        !0 === t && this.version++;
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t;
                        if (!e && void 0 !== t.images[this.uuid])
                            return t.images[this.uuid];
                        const n = { uuid: this.uuid, url: "" },
                            i = this.data;
                        if (null !== i) {
                            let t;
                            if (Array.isArray(i)) {
                                t = [];
                                for (let e = 0, n = i.length; e < n; e++)
                                    i[e].isDataTexture
                                        ? t.push(pt(i[e].image))
                                        : t.push(pt(i[e]));
                            } else t = pt(i);
                            n.url = t;
                        }
                        return e || (t.images[this.uuid] = n), n;
                    }
                }
                function pt(t) {
                    return ("undefined" != typeof HTMLImageElement &&
                        t instanceof HTMLImageElement) ||
                        ("undefined" != typeof HTMLCanvasElement &&
                            t instanceof HTMLCanvasElement) ||
                        ("undefined" != typeof ImageBitmap &&
                            t instanceof ImageBitmap)
                        ? ut.getDataURL(t)
                        : t.data
                        ? {
                              data: Array.from(t.data),
                              width: t.width,
                              height: t.height,
                              type: t.data.constructor.name,
                          }
                        : (console.warn(
                              "THREE.Texture: Unable to serialize Texture.",
                          ),
                          {});
                }
                let ft = 0;
                class mt extends V {
                    constructor(
                        t = mt.DEFAULT_IMAGE,
                        e = mt.DEFAULT_MAPPING,
                        n = 1001,
                        i = 1001,
                        r = 1006,
                        a = 1008,
                        s = 1023,
                        o = 1009,
                        l = mt.DEFAULT_ANISOTROPY,
                        c = 3e3,
                    ) {
                        super(),
                            (this.isTexture = !0),
                            Object.defineProperty(this, "id", { value: ft++ }),
                            (this.uuid = H()),
                            (this.name = ""),
                            (this.source = new dt(t)),
                            (this.mipmaps = []),
                            (this.mapping = e),
                            (this.wrapS = n),
                            (this.wrapT = i),
                            (this.magFilter = r),
                            (this.minFilter = a),
                            (this.anisotropy = l),
                            (this.format = s),
                            (this.internalFormat = null),
                            (this.type = o),
                            (this.offset = new K(0, 0)),
                            (this.repeat = new K(1, 1)),
                            (this.center = new K(0, 0)),
                            (this.rotation = 0),
                            (this.matrixAutoUpdate = !0),
                            (this.matrix = new J()),
                            (this.generateMipmaps = !0),
                            (this.premultiplyAlpha = !1),
                            (this.flipY = !0),
                            (this.unpackAlignment = 4),
                            (this.encoding = c),
                            (this.userData = {}),
                            (this.version = 0),
                            (this.onUpdate = null),
                            (this.isRenderTargetTexture = !1),
                            (this.needsPMREMUpdate = !1);
                    }
                    get image() {
                        return this.source.data;
                    }
                    set image(t) {
                        this.source.data = t;
                    }
                    updateMatrix() {
                        this.matrix.setUvTransform(
                            this.offset.x,
                            this.offset.y,
                            this.repeat.x,
                            this.repeat.y,
                            this.rotation,
                            this.center.x,
                            this.center.y,
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(t) {
                        return (
                            (this.name = t.name),
                            (this.source = t.source),
                            (this.mipmaps = t.mipmaps.slice(0)),
                            (this.mapping = t.mapping),
                            (this.wrapS = t.wrapS),
                            (this.wrapT = t.wrapT),
                            (this.magFilter = t.magFilter),
                            (this.minFilter = t.minFilter),
                            (this.anisotropy = t.anisotropy),
                            (this.format = t.format),
                            (this.internalFormat = t.internalFormat),
                            (this.type = t.type),
                            this.offset.copy(t.offset),
                            this.repeat.copy(t.repeat),
                            this.center.copy(t.center),
                            (this.rotation = t.rotation),
                            (this.matrixAutoUpdate = t.matrixAutoUpdate),
                            this.matrix.copy(t.matrix),
                            (this.generateMipmaps = t.generateMipmaps),
                            (this.premultiplyAlpha = t.premultiplyAlpha),
                            (this.flipY = t.flipY),
                            (this.unpackAlignment = t.unpackAlignment),
                            (this.encoding = t.encoding),
                            (this.userData = JSON.parse(
                                JSON.stringify(t.userData),
                            )),
                            (this.needsUpdate = !0),
                            this
                        );
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t;
                        if (!e && void 0 !== t.textures[this.uuid])
                            return t.textures[this.uuid];
                        const n = {
                            metadata: {
                                version: 4.5,
                                type: "Texture",
                                generator: "Texture.toJSON",
                            },
                            uuid: this.uuid,
                            name: this.name,
                            image: this.source.toJSON(t).uuid,
                            mapping: this.mapping,
                            repeat: [this.repeat.x, this.repeat.y],
                            offset: [this.offset.x, this.offset.y],
                            center: [this.center.x, this.center.y],
                            rotation: this.rotation,
                            wrap: [this.wrapS, this.wrapT],
                            format: this.format,
                            type: this.type,
                            encoding: this.encoding,
                            minFilter: this.minFilter,
                            magFilter: this.magFilter,
                            anisotropy: this.anisotropy,
                            flipY: this.flipY,
                            generateMipmaps: this.generateMipmaps,
                            premultiplyAlpha: this.premultiplyAlpha,
                            unpackAlignment: this.unpackAlignment,
                        };
                        return (
                            Object.keys(this.userData).length > 0 &&
                                (n.userData = this.userData),
                            e || (t.textures[this.uuid] = n),
                            n
                        );
                    }
                    dispose() {
                        this.dispatchEvent({ type: "dispose" });
                    }
                    transformUv(t) {
                        if (300 !== this.mapping) return t;
                        if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
                            switch (this.wrapS) {
                                case a:
                                    t.x = t.x - Math.floor(t.x);
                                    break;
                                case s:
                                    t.x = t.x < 0 ? 0 : 1;
                                    break;
                                case o:
                                    1 === Math.abs(Math.floor(t.x) % 2)
                                        ? (t.x = Math.ceil(t.x) - t.x)
                                        : (t.x = t.x - Math.floor(t.x));
                            }
                        if (t.y < 0 || t.y > 1)
                            switch (this.wrapT) {
                                case a:
                                    t.y = t.y - Math.floor(t.y);
                                    break;
                                case s:
                                    t.y = t.y < 0 ? 0 : 1;
                                    break;
                                case o:
                                    1 === Math.abs(Math.floor(t.y) % 2)
                                        ? (t.y = Math.ceil(t.y) - t.y)
                                        : (t.y = t.y - Math.floor(t.y));
                            }
                        return this.flipY && (t.y = 1 - t.y), t;
                    }
                    set needsUpdate(t) {
                        !0 === t &&
                            (this.version++, (this.source.needsUpdate = !0));
                    }
                }
                (mt.DEFAULT_IMAGE = null),
                    (mt.DEFAULT_MAPPING = 300),
                    (mt.DEFAULT_ANISOTROPY = 1);
                class gt {
                    constructor(t = 0, e = 0, n = 0, i = 1) {
                        (gt.prototype.isVector4 = !0),
                            (this.x = t),
                            (this.y = e),
                            (this.z = n),
                            (this.w = i);
                    }
                    get width() {
                        return this.z;
                    }
                    set width(t) {
                        this.z = t;
                    }
                    get height() {
                        return this.w;
                    }
                    set height(t) {
                        this.w = t;
                    }
                    set(t, e, n, i) {
                        return (
                            (this.x = t),
                            (this.y = e),
                            (this.z = n),
                            (this.w = i),
                            this
                        );
                    }
                    setScalar(t) {
                        return (
                            (this.x = t),
                            (this.y = t),
                            (this.z = t),
                            (this.w = t),
                            this
                        );
                    }
                    setX(t) {
                        return (this.x = t), this;
                    }
                    setY(t) {
                        return (this.y = t), this;
                    }
                    setZ(t) {
                        return (this.z = t), this;
                    }
                    setW(t) {
                        return (this.w = t), this;
                    }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            case 3:
                                this.w = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t);
                        }
                        return this;
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            case 3:
                                return this.w;
                            default:
                                throw new Error("index is out of range: " + t);
                        }
                    }
                    clone() {
                        return new this.constructor(
                            this.x,
                            this.y,
                            this.z,
                            this.w,
                        );
                    }
                    copy(t) {
                        return (
                            (this.x = t.x),
                            (this.y = t.y),
                            (this.z = t.z),
                            (this.w = void 0 !== t.w ? t.w : 1),
                            this
                        );
                    }
                    add(t) {
                        return (
                            (this.x += t.x),
                            (this.y += t.y),
                            (this.z += t.z),
                            (this.w += t.w),
                            this
                        );
                    }
                    addScalar(t) {
                        return (
                            (this.x += t),
                            (this.y += t),
                            (this.z += t),
                            (this.w += t),
                            this
                        );
                    }
                    addVectors(t, e) {
                        return (
                            (this.x = t.x + e.x),
                            (this.y = t.y + e.y),
                            (this.z = t.z + e.z),
                            (this.w = t.w + e.w),
                            this
                        );
                    }
                    addScaledVector(t, e) {
                        return (
                            (this.x += t.x * e),
                            (this.y += t.y * e),
                            (this.z += t.z * e),
                            (this.w += t.w * e),
                            this
                        );
                    }
                    sub(t) {
                        return (
                            (this.x -= t.x),
                            (this.y -= t.y),
                            (this.z -= t.z),
                            (this.w -= t.w),
                            this
                        );
                    }
                    subScalar(t) {
                        return (
                            (this.x -= t),
                            (this.y -= t),
                            (this.z -= t),
                            (this.w -= t),
                            this
                        );
                    }
                    subVectors(t, e) {
                        return (
                            (this.x = t.x - e.x),
                            (this.y = t.y - e.y),
                            (this.z = t.z - e.z),
                            (this.w = t.w - e.w),
                            this
                        );
                    }
                    multiply(t) {
                        return (
                            (this.x *= t.x),
                            (this.y *= t.y),
                            (this.z *= t.z),
                            (this.w *= t.w),
                            this
                        );
                    }
                    multiplyScalar(t) {
                        return (
                            (this.x *= t),
                            (this.y *= t),
                            (this.z *= t),
                            (this.w *= t),
                            this
                        );
                    }
                    applyMatrix4(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = this.w,
                            a = t.elements;
                        return (
                            (this.x =
                                a[0] * e + a[4] * n + a[8] * i + a[12] * r),
                            (this.y =
                                a[1] * e + a[5] * n + a[9] * i + a[13] * r),
                            (this.z =
                                a[2] * e + a[6] * n + a[10] * i + a[14] * r),
                            (this.w =
                                a[3] * e + a[7] * n + a[11] * i + a[15] * r),
                            this
                        );
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t);
                    }
                    setAxisAngleFromQuaternion(t) {
                        this.w = 2 * Math.acos(t.w);
                        const e = Math.sqrt(1 - t.w * t.w);
                        return (
                            e < 1e-4
                                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                                : ((this.x = t.x / e),
                                  (this.y = t.y / e),
                                  (this.z = t.z / e)),
                            this
                        );
                    }
                    setAxisAngleFromRotationMatrix(t) {
                        let e, n, i, r;
                        const a = 0.01,
                            s = 0.1,
                            o = t.elements,
                            l = o[0],
                            c = o[4],
                            h = o[8],
                            u = o[1],
                            d = o[5],
                            p = o[9],
                            f = o[2],
                            m = o[6],
                            g = o[10];
                        if (
                            Math.abs(c - u) < a &&
                            Math.abs(h - f) < a &&
                            Math.abs(p - m) < a
                        ) {
                            if (
                                Math.abs(c + u) < s &&
                                Math.abs(h + f) < s &&
                                Math.abs(p + m) < s &&
                                Math.abs(l + d + g - 3) < s
                            )
                                return this.set(1, 0, 0, 0), this;
                            e = Math.PI;
                            const t = (l + 1) / 2,
                                o = (d + 1) / 2,
                                v = (g + 1) / 2,
                                x = (c + u) / 4,
                                b = (h + f) / 4,
                                y = (p + m) / 4;
                            return (
                                t > o && t > v
                                    ? t < a
                                        ? ((n = 0),
                                          (i = 0.707106781),
                                          (r = 0.707106781))
                                        : ((n = Math.sqrt(t)),
                                          (i = x / n),
                                          (r = b / n))
                                    : o > v
                                    ? o < a
                                        ? ((n = 0.707106781),
                                          (i = 0),
                                          (r = 0.707106781))
                                        : ((i = Math.sqrt(o)),
                                          (n = x / i),
                                          (r = y / i))
                                    : v < a
                                    ? ((n = 0.707106781),
                                      (i = 0.707106781),
                                      (r = 0))
                                    : ((r = Math.sqrt(v)),
                                      (n = b / r),
                                      (i = y / r)),
                                this.set(n, i, r, e),
                                this
                            );
                        }
                        let v = Math.sqrt(
                            (m - p) * (m - p) +
                                (h - f) * (h - f) +
                                (u - c) * (u - c),
                        );
                        return (
                            Math.abs(v) < 0.001 && (v = 1),
                            (this.x = (m - p) / v),
                            (this.y = (h - f) / v),
                            (this.z = (u - c) / v),
                            (this.w = Math.acos((l + d + g - 1) / 2)),
                            this
                        );
                    }
                    min(t) {
                        return (
                            (this.x = Math.min(this.x, t.x)),
                            (this.y = Math.min(this.y, t.y)),
                            (this.z = Math.min(this.z, t.z)),
                            (this.w = Math.min(this.w, t.w)),
                            this
                        );
                    }
                    max(t) {
                        return (
                            (this.x = Math.max(this.x, t.x)),
                            (this.y = Math.max(this.y, t.y)),
                            (this.z = Math.max(this.z, t.z)),
                            (this.w = Math.max(this.w, t.w)),
                            this
                        );
                    }
                    clamp(t, e) {
                        return (
                            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
                            (this.w = Math.max(t.w, Math.min(e.w, this.w))),
                            this
                        );
                    }
                    clampScalar(t, e) {
                        return (
                            (this.x = Math.max(t, Math.min(e, this.x))),
                            (this.y = Math.max(t, Math.min(e, this.y))),
                            (this.z = Math.max(t, Math.min(e, this.z))),
                            (this.w = Math.max(t, Math.min(e, this.w))),
                            this
                        );
                    }
                    clampLength(t, e) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(
                            Math.max(t, Math.min(e, n)),
                        );
                    }
                    floor() {
                        return (
                            (this.x = Math.floor(this.x)),
                            (this.y = Math.floor(this.y)),
                            (this.z = Math.floor(this.z)),
                            (this.w = Math.floor(this.w)),
                            this
                        );
                    }
                    ceil() {
                        return (
                            (this.x = Math.ceil(this.x)),
                            (this.y = Math.ceil(this.y)),
                            (this.z = Math.ceil(this.z)),
                            (this.w = Math.ceil(this.w)),
                            this
                        );
                    }
                    round() {
                        return (
                            (this.x = Math.round(this.x)),
                            (this.y = Math.round(this.y)),
                            (this.z = Math.round(this.z)),
                            (this.w = Math.round(this.w)),
                            this
                        );
                    }
                    roundToZero() {
                        return (
                            (this.x =
                                this.x < 0
                                    ? Math.ceil(this.x)
                                    : Math.floor(this.x)),
                            (this.y =
                                this.y < 0
                                    ? Math.ceil(this.y)
                                    : Math.floor(this.y)),
                            (this.z =
                                this.z < 0
                                    ? Math.ceil(this.z)
                                    : Math.floor(this.z)),
                            (this.w =
                                this.w < 0
                                    ? Math.ceil(this.w)
                                    : Math.floor(this.w)),
                            this
                        );
                    }
                    negate() {
                        return (
                            (this.x = -this.x),
                            (this.y = -this.y),
                            (this.z = -this.z),
                            (this.w = -this.w),
                            this
                        );
                    }
                    dot(t) {
                        return (
                            this.x * t.x +
                            this.y * t.y +
                            this.z * t.z +
                            this.w * t.w
                        );
                    }
                    lengthSq() {
                        return (
                            this.x * this.x +
                            this.y * this.y +
                            this.z * this.z +
                            this.w * this.w
                        );
                    }
                    length() {
                        return Math.sqrt(
                            this.x * this.x +
                                this.y * this.y +
                                this.z * this.z +
                                this.w * this.w,
                        );
                    }
                    manhattanLength() {
                        return (
                            Math.abs(this.x) +
                            Math.abs(this.y) +
                            Math.abs(this.z) +
                            Math.abs(this.w)
                        );
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1);
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t);
                    }
                    lerp(t, e) {
                        return (
                            (this.x += (t.x - this.x) * e),
                            (this.y += (t.y - this.y) * e),
                            (this.z += (t.z - this.z) * e),
                            (this.w += (t.w - this.w) * e),
                            this
                        );
                    }
                    lerpVectors(t, e, n) {
                        return (
                            (this.x = t.x + (e.x - t.x) * n),
                            (this.y = t.y + (e.y - t.y) * n),
                            (this.z = t.z + (e.z - t.z) * n),
                            (this.w = t.w + (e.w - t.w) * n),
                            this
                        );
                    }
                    equals(t) {
                        return (
                            t.x === this.x &&
                            t.y === this.y &&
                            t.z === this.z &&
                            t.w === this.w
                        );
                    }
                    fromArray(t, e = 0) {
                        return (
                            (this.x = t[e]),
                            (this.y = t[e + 1]),
                            (this.z = t[e + 2]),
                            (this.w = t[e + 3]),
                            this
                        );
                    }
                    toArray(t = [], e = 0) {
                        return (
                            (t[e] = this.x),
                            (t[e + 1] = this.y),
                            (t[e + 2] = this.z),
                            (t[e + 3] = this.w),
                            t
                        );
                    }
                    fromBufferAttribute(t, e) {
                        return (
                            (this.x = t.getX(e)),
                            (this.y = t.getY(e)),
                            (this.z = t.getZ(e)),
                            (this.w = t.getW(e)),
                            this
                        );
                    }
                    random() {
                        return (
                            (this.x = Math.random()),
                            (this.y = Math.random()),
                            (this.z = Math.random()),
                            (this.w = Math.random()),
                            this
                        );
                    }
                    *[Symbol.iterator]() {
                        yield this.x, yield this.y, yield this.z, yield this.w;
                    }
                }
                class vt extends V {
                    constructor(t = 1, e = 1, n = {}) {
                        super(),
                            (this.isWebGLRenderTarget = !0),
                            (this.width = t),
                            (this.height = e),
                            (this.depth = 1),
                            (this.scissor = new gt(0, 0, t, e)),
                            (this.scissorTest = !1),
                            (this.viewport = new gt(0, 0, t, e));
                        const i = { width: t, height: e, depth: 1 };
                        (this.texture = new mt(
                            i,
                            n.mapping,
                            n.wrapS,
                            n.wrapT,
                            n.magFilter,
                            n.minFilter,
                            n.format,
                            n.type,
                            n.anisotropy,
                            n.encoding,
                        )),
                            (this.texture.isRenderTargetTexture = !0),
                            (this.texture.flipY = !1),
                            (this.texture.generateMipmaps =
                                void 0 !== n.generateMipmaps &&
                                n.generateMipmaps),
                            (this.texture.internalFormat =
                                void 0 !== n.internalFormat
                                    ? n.internalFormat
                                    : null),
                            (this.texture.minFilter =
                                void 0 !== n.minFilter ? n.minFilter : h),
                            (this.depthBuffer =
                                void 0 === n.depthBuffer || n.depthBuffer),
                            (this.stencilBuffer =
                                void 0 !== n.stencilBuffer && n.stencilBuffer),
                            (this.depthTexture =
                                void 0 !== n.depthTexture
                                    ? n.depthTexture
                                    : null),
                            (this.samples =
                                void 0 !== n.samples ? n.samples : 0);
                    }
                    setSize(t, e, n = 1) {
                        (this.width === t &&
                            this.height === e &&
                            this.depth === n) ||
                            ((this.width = t),
                            (this.height = e),
                            (this.depth = n),
                            (this.texture.image.width = t),
                            (this.texture.image.height = e),
                            (this.texture.image.depth = n),
                            this.dispose()),
                            this.viewport.set(0, 0, t, e),
                            this.scissor.set(0, 0, t, e);
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(t) {
                        (this.width = t.width),
                            (this.height = t.height),
                            (this.depth = t.depth),
                            this.viewport.copy(t.viewport),
                            (this.texture = t.texture.clone()),
                            (this.texture.isRenderTargetTexture = !0);
                        const e = Object.assign({}, t.texture.image);
                        return (
                            (this.texture.source = new dt(e)),
                            (this.depthBuffer = t.depthBuffer),
                            (this.stencilBuffer = t.stencilBuffer),
                            null !== t.depthTexture &&
                                (this.depthTexture = t.depthTexture.clone()),
                            (this.samples = t.samples),
                            this
                        );
                    }
                    dispose() {
                        this.dispatchEvent({ type: "dispose" });
                    }
                }
                class xt extends mt {
                    constructor(t = null, e = 1, n = 1, i = 1) {
                        super(null),
                            (this.isDataArrayTexture = !0),
                            (this.image = {
                                data: t,
                                width: e,
                                height: n,
                                depth: i,
                            }),
                            (this.magFilter = l),
                            (this.minFilter = l),
                            (this.wrapR = s),
                            (this.generateMipmaps = !1),
                            (this.flipY = !1),
                            (this.unpackAlignment = 1);
                    }
                }
                class bt extends mt {
                    constructor(t = null, e = 1, n = 1, i = 1) {
                        super(null),
                            (this.isData3DTexture = !0),
                            (this.image = {
                                data: t,
                                width: e,
                                height: n,
                                depth: i,
                            }),
                            (this.magFilter = l),
                            (this.minFilter = l),
                            (this.wrapR = s),
                            (this.generateMipmaps = !1),
                            (this.flipY = !1),
                            (this.unpackAlignment = 1);
                    }
                }
                class yt {
                    constructor(t = 0, e = 0, n = 0, i = 1) {
                        (this.isQuaternion = !0),
                            (this._x = t),
                            (this._y = e),
                            (this._z = n),
                            (this._w = i);
                    }
                    static slerpFlat(t, e, n, i, r, a, s) {
                        let o = n[i + 0],
                            l = n[i + 1],
                            c = n[i + 2],
                            h = n[i + 3];
                        const u = r[a + 0],
                            d = r[a + 1],
                            p = r[a + 2],
                            f = r[a + 3];
                        if (0 === s)
                            return (
                                (t[e + 0] = o),
                                (t[e + 1] = l),
                                (t[e + 2] = c),
                                void (t[e + 3] = h)
                            );
                        if (1 === s)
                            return (
                                (t[e + 0] = u),
                                (t[e + 1] = d),
                                (t[e + 2] = p),
                                void (t[e + 3] = f)
                            );
                        if (h !== f || o !== u || l !== d || c !== p) {
                            let t = 1 - s;
                            const e = o * u + l * d + c * p + h * f,
                                n = e >= 0 ? 1 : -1,
                                i = 1 - e * e;
                            if (i > Number.EPSILON) {
                                const r = Math.sqrt(i),
                                    a = Math.atan2(r, e * n);
                                (t = Math.sin(t * a) / r),
                                    (s = Math.sin(s * a) / r);
                            }
                            const r = s * n;
                            if (
                                ((o = o * t + u * r),
                                (l = l * t + d * r),
                                (c = c * t + p * r),
                                (h = h * t + f * r),
                                t === 1 - s)
                            ) {
                                const t =
                                    1 /
                                    Math.sqrt(o * o + l * l + c * c + h * h);
                                (o *= t), (l *= t), (c *= t), (h *= t);
                            }
                        }
                        (t[e] = o),
                            (t[e + 1] = l),
                            (t[e + 2] = c),
                            (t[e + 3] = h);
                    }
                    static multiplyQuaternionsFlat(t, e, n, i, r, a) {
                        const s = n[i],
                            o = n[i + 1],
                            l = n[i + 2],
                            c = n[i + 3],
                            h = r[a],
                            u = r[a + 1],
                            d = r[a + 2],
                            p = r[a + 3];
                        return (
                            (t[e] = s * p + c * h + o * d - l * u),
                            (t[e + 1] = o * p + c * u + l * h - s * d),
                            (t[e + 2] = l * p + c * d + s * u - o * h),
                            (t[e + 3] = c * p - s * h - o * u - l * d),
                            t
                        );
                    }
                    get x() {
                        return this._x;
                    }
                    set x(t) {
                        (this._x = t), this._onChangeCallback();
                    }
                    get y() {
                        return this._y;
                    }
                    set y(t) {
                        (this._y = t), this._onChangeCallback();
                    }
                    get z() {
                        return this._z;
                    }
                    set z(t) {
                        (this._z = t), this._onChangeCallback();
                    }
                    get w() {
                        return this._w;
                    }
                    set w(t) {
                        (this._w = t), this._onChangeCallback();
                    }
                    set(t, e, n, i) {
                        return (
                            (this._x = t),
                            (this._y = e),
                            (this._z = n),
                            (this._w = i),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor(
                            this._x,
                            this._y,
                            this._z,
                            this._w,
                        );
                    }
                    copy(t) {
                        return (
                            (this._x = t.x),
                            (this._y = t.y),
                            (this._z = t.z),
                            (this._w = t.w),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    setFromEuler(t, e) {
                        const n = t._x,
                            i = t._y,
                            r = t._z,
                            a = t._order,
                            s = Math.cos,
                            o = Math.sin,
                            l = s(n / 2),
                            c = s(i / 2),
                            h = s(r / 2),
                            u = o(n / 2),
                            d = o(i / 2),
                            p = o(r / 2);
                        switch (a) {
                            case "XYZ":
                                (this._x = u * c * h + l * d * p),
                                    (this._y = l * d * h - u * c * p),
                                    (this._z = l * c * p + u * d * h),
                                    (this._w = l * c * h - u * d * p);
                                break;
                            case "YXZ":
                                (this._x = u * c * h + l * d * p),
                                    (this._y = l * d * h - u * c * p),
                                    (this._z = l * c * p - u * d * h),
                                    (this._w = l * c * h + u * d * p);
                                break;
                            case "ZXY":
                                (this._x = u * c * h - l * d * p),
                                    (this._y = l * d * h + u * c * p),
                                    (this._z = l * c * p + u * d * h),
                                    (this._w = l * c * h - u * d * p);
                                break;
                            case "ZYX":
                                (this._x = u * c * h - l * d * p),
                                    (this._y = l * d * h + u * c * p),
                                    (this._z = l * c * p - u * d * h),
                                    (this._w = l * c * h + u * d * p);
                                break;
                            case "YZX":
                                (this._x = u * c * h + l * d * p),
                                    (this._y = l * d * h + u * c * p),
                                    (this._z = l * c * p - u * d * h),
                                    (this._w = l * c * h - u * d * p);
                                break;
                            case "XZY":
                                (this._x = u * c * h - l * d * p),
                                    (this._y = l * d * h - u * c * p),
                                    (this._z = l * c * p + u * d * h),
                                    (this._w = l * c * h + u * d * p);
                                break;
                            default:
                                console.warn(
                                    "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                                        a,
                                );
                        }
                        return !1 !== e && this._onChangeCallback(), this;
                    }
                    setFromAxisAngle(t, e) {
                        const n = e / 2,
                            i = Math.sin(n);
                        return (
                            (this._x = t.x * i),
                            (this._y = t.y * i),
                            (this._z = t.z * i),
                            (this._w = Math.cos(n)),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    setFromRotationMatrix(t) {
                        const e = t.elements,
                            n = e[0],
                            i = e[4],
                            r = e[8],
                            a = e[1],
                            s = e[5],
                            o = e[9],
                            l = e[2],
                            c = e[6],
                            h = e[10],
                            u = n + s + h;
                        if (u > 0) {
                            const t = 0.5 / Math.sqrt(u + 1);
                            (this._w = 0.25 / t),
                                (this._x = (c - o) * t),
                                (this._y = (r - l) * t),
                                (this._z = (a - i) * t);
                        } else if (n > s && n > h) {
                            const t = 2 * Math.sqrt(1 + n - s - h);
                            (this._w = (c - o) / t),
                                (this._x = 0.25 * t),
                                (this._y = (i + a) / t),
                                (this._z = (r + l) / t);
                        } else if (s > h) {
                            const t = 2 * Math.sqrt(1 + s - n - h);
                            (this._w = (r - l) / t),
                                (this._x = (i + a) / t),
                                (this._y = 0.25 * t),
                                (this._z = (o + c) / t);
                        } else {
                            const t = 2 * Math.sqrt(1 + h - n - s);
                            (this._w = (a - i) / t),
                                (this._x = (r + l) / t),
                                (this._y = (o + c) / t),
                                (this._z = 0.25 * t);
                        }
                        return this._onChangeCallback(), this;
                    }
                    setFromUnitVectors(t, e) {
                        let n = t.dot(e) + 1;
                        return (
                            n < Number.EPSILON
                                ? ((n = 0),
                                  Math.abs(t.x) > Math.abs(t.z)
                                      ? ((this._x = -t.y),
                                        (this._y = t.x),
                                        (this._z = 0),
                                        (this._w = n))
                                      : ((this._x = 0),
                                        (this._y = -t.z),
                                        (this._z = t.y),
                                        (this._w = n)))
                                : ((this._x = t.y * e.z - t.z * e.y),
                                  (this._y = t.z * e.x - t.x * e.z),
                                  (this._z = t.x * e.y - t.y * e.x),
                                  (this._w = n)),
                            this.normalize()
                        );
                    }
                    angleTo(t) {
                        return 2 * Math.acos(Math.abs(F(this.dot(t), -1, 1)));
                    }
                    rotateTowards(t, e) {
                        const n = this.angleTo(t);
                        if (0 === n) return this;
                        const i = Math.min(1, e / n);
                        return this.slerp(t, i), this;
                    }
                    identity() {
                        return this.set(0, 0, 0, 1);
                    }
                    invert() {
                        return this.conjugate();
                    }
                    conjugate() {
                        return (
                            (this._x *= -1),
                            (this._y *= -1),
                            (this._z *= -1),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    dot(t) {
                        return (
                            this._x * t._x +
                            this._y * t._y +
                            this._z * t._z +
                            this._w * t._w
                        );
                    }
                    lengthSq() {
                        return (
                            this._x * this._x +
                            this._y * this._y +
                            this._z * this._z +
                            this._w * this._w
                        );
                    }
                    length() {
                        return Math.sqrt(
                            this._x * this._x +
                                this._y * this._y +
                                this._z * this._z +
                                this._w * this._w,
                        );
                    }
                    normalize() {
                        let t = this.length();
                        return (
                            0 === t
                                ? ((this._x = 0),
                                  (this._y = 0),
                                  (this._z = 0),
                                  (this._w = 1))
                                : ((t = 1 / t),
                                  (this._x = this._x * t),
                                  (this._y = this._y * t),
                                  (this._z = this._z * t),
                                  (this._w = this._w * t)),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    multiply(t) {
                        return this.multiplyQuaternions(this, t);
                    }
                    premultiply(t) {
                        return this.multiplyQuaternions(t, this);
                    }
                    multiplyQuaternions(t, e) {
                        const n = t._x,
                            i = t._y,
                            r = t._z,
                            a = t._w,
                            s = e._x,
                            o = e._y,
                            l = e._z,
                            c = e._w;
                        return (
                            (this._x = n * c + a * s + i * l - r * o),
                            (this._y = i * c + a * o + r * s - n * l),
                            (this._z = r * c + a * l + n * o - i * s),
                            (this._w = a * c - n * s - i * o - r * l),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    slerp(t, e) {
                        if (0 === e) return this;
                        if (1 === e) return this.copy(t);
                        const n = this._x,
                            i = this._y,
                            r = this._z,
                            a = this._w;
                        let s = a * t._w + n * t._x + i * t._y + r * t._z;
                        if (
                            (s < 0
                                ? ((this._w = -t._w),
                                  (this._x = -t._x),
                                  (this._y = -t._y),
                                  (this._z = -t._z),
                                  (s = -s))
                                : this.copy(t),
                            s >= 1)
                        )
                            return (
                                (this._w = a),
                                (this._x = n),
                                (this._y = i),
                                (this._z = r),
                                this
                            );
                        const o = 1 - s * s;
                        if (o <= Number.EPSILON) {
                            const t = 1 - e;
                            return (
                                (this._w = t * a + e * this._w),
                                (this._x = t * n + e * this._x),
                                (this._y = t * i + e * this._y),
                                (this._z = t * r + e * this._z),
                                this.normalize(),
                                this._onChangeCallback(),
                                this
                            );
                        }
                        const l = Math.sqrt(o),
                            c = Math.atan2(l, s),
                            h = Math.sin((1 - e) * c) / l,
                            u = Math.sin(e * c) / l;
                        return (
                            (this._w = a * h + this._w * u),
                            (this._x = n * h + this._x * u),
                            (this._y = i * h + this._y * u),
                            (this._z = r * h + this._z * u),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    slerpQuaternions(t, e, n) {
                        return this.copy(t).slerp(e, n);
                    }
                    random() {
                        const t = Math.random(),
                            e = Math.sqrt(1 - t),
                            n = Math.sqrt(t),
                            i = 2 * Math.PI * Math.random(),
                            r = 2 * Math.PI * Math.random();
                        return this.set(
                            e * Math.cos(i),
                            n * Math.sin(r),
                            n * Math.cos(r),
                            e * Math.sin(i),
                        );
                    }
                    equals(t) {
                        return (
                            t._x === this._x &&
                            t._y === this._y &&
                            t._z === this._z &&
                            t._w === this._w
                        );
                    }
                    fromArray(t, e = 0) {
                        return (
                            (this._x = t[e]),
                            (this._y = t[e + 1]),
                            (this._z = t[e + 2]),
                            (this._w = t[e + 3]),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    toArray(t = [], e = 0) {
                        return (
                            (t[e] = this._x),
                            (t[e + 1] = this._y),
                            (t[e + 2] = this._z),
                            (t[e + 3] = this._w),
                            t
                        );
                    }
                    fromBufferAttribute(t, e) {
                        return (
                            (this._x = t.getX(e)),
                            (this._y = t.getY(e)),
                            (this._z = t.getZ(e)),
                            (this._w = t.getW(e)),
                            this
                        );
                    }
                    _onChange(t) {
                        return (this._onChangeCallback = t), this;
                    }
                    _onChangeCallback() {}
                    *[Symbol.iterator]() {
                        yield this._x,
                            yield this._y,
                            yield this._z,
                            yield this._w;
                    }
                }
                class St {
                    constructor(t = 0, e = 0, n = 0) {
                        (St.prototype.isVector3 = !0),
                            (this.x = t),
                            (this.y = e),
                            (this.z = n);
                    }
                    set(t, e, n) {
                        return (
                            void 0 === n && (n = this.z),
                            (this.x = t),
                            (this.y = e),
                            (this.z = n),
                            this
                        );
                    }
                    setScalar(t) {
                        return (this.x = t), (this.y = t), (this.z = t), this;
                    }
                    setX(t) {
                        return (this.x = t), this;
                    }
                    setY(t) {
                        return (this.y = t), this;
                    }
                    setZ(t) {
                        return (this.z = t), this;
                    }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t);
                        }
                        return this;
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            default:
                                throw new Error("index is out of range: " + t);
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y, this.z);
                    }
                    copy(t) {
                        return (
                            (this.x = t.x), (this.y = t.y), (this.z = t.z), this
                        );
                    }
                    add(t) {
                        return (
                            (this.x += t.x),
                            (this.y += t.y),
                            (this.z += t.z),
                            this
                        );
                    }
                    addScalar(t) {
                        return (
                            (this.x += t), (this.y += t), (this.z += t), this
                        );
                    }
                    addVectors(t, e) {
                        return (
                            (this.x = t.x + e.x),
                            (this.y = t.y + e.y),
                            (this.z = t.z + e.z),
                            this
                        );
                    }
                    addScaledVector(t, e) {
                        return (
                            (this.x += t.x * e),
                            (this.y += t.y * e),
                            (this.z += t.z * e),
                            this
                        );
                    }
                    sub(t) {
                        return (
                            (this.x -= t.x),
                            (this.y -= t.y),
                            (this.z -= t.z),
                            this
                        );
                    }
                    subScalar(t) {
                        return (
                            (this.x -= t), (this.y -= t), (this.z -= t), this
                        );
                    }
                    subVectors(t, e) {
                        return (
                            (this.x = t.x - e.x),
                            (this.y = t.y - e.y),
                            (this.z = t.z - e.z),
                            this
                        );
                    }
                    multiply(t) {
                        return (
                            (this.x *= t.x),
                            (this.y *= t.y),
                            (this.z *= t.z),
                            this
                        );
                    }
                    multiplyScalar(t) {
                        return (
                            (this.x *= t), (this.y *= t), (this.z *= t), this
                        );
                    }
                    multiplyVectors(t, e) {
                        return (
                            (this.x = t.x * e.x),
                            (this.y = t.y * e.y),
                            (this.z = t.z * e.z),
                            this
                        );
                    }
                    applyEuler(t) {
                        return this.applyQuaternion(At.setFromEuler(t));
                    }
                    applyAxisAngle(t, e) {
                        return this.applyQuaternion(At.setFromAxisAngle(t, e));
                    }
                    applyMatrix3(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements;
                        return (
                            (this.x = r[0] * e + r[3] * n + r[6] * i),
                            (this.y = r[1] * e + r[4] * n + r[7] * i),
                            (this.z = r[2] * e + r[5] * n + r[8] * i),
                            this
                        );
                    }
                    applyNormalMatrix(t) {
                        return this.applyMatrix3(t).normalize();
                    }
                    applyMatrix4(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements,
                            a = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                        return (
                            (this.x =
                                (r[0] * e + r[4] * n + r[8] * i + r[12]) * a),
                            (this.y =
                                (r[1] * e + r[5] * n + r[9] * i + r[13]) * a),
                            (this.z =
                                (r[2] * e + r[6] * n + r[10] * i + r[14]) * a),
                            this
                        );
                    }
                    applyQuaternion(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.x,
                            a = t.y,
                            s = t.z,
                            o = t.w,
                            l = o * e + a * i - s * n,
                            c = o * n + s * e - r * i,
                            h = o * i + r * n - a * e,
                            u = -r * e - a * n - s * i;
                        return (
                            (this.x = l * o + u * -r + c * -s - h * -a),
                            (this.y = c * o + u * -a + h * -r - l * -s),
                            (this.z = h * o + u * -s + l * -a - c * -r),
                            this
                        );
                    }
                    project(t) {
                        return this.applyMatrix4(
                            t.matrixWorldInverse,
                        ).applyMatrix4(t.projectionMatrix);
                    }
                    unproject(t) {
                        return this.applyMatrix4(
                            t.projectionMatrixInverse,
                        ).applyMatrix4(t.matrixWorld);
                    }
                    transformDirection(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements;
                        return (
                            (this.x = r[0] * e + r[4] * n + r[8] * i),
                            (this.y = r[1] * e + r[5] * n + r[9] * i),
                            (this.z = r[2] * e + r[6] * n + r[10] * i),
                            this.normalize()
                        );
                    }
                    divide(t) {
                        return (
                            (this.x /= t.x),
                            (this.y /= t.y),
                            (this.z /= t.z),
                            this
                        );
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t);
                    }
                    min(t) {
                        return (
                            (this.x = Math.min(this.x, t.x)),
                            (this.y = Math.min(this.y, t.y)),
                            (this.z = Math.min(this.z, t.z)),
                            this
                        );
                    }
                    max(t) {
                        return (
                            (this.x = Math.max(this.x, t.x)),
                            (this.y = Math.max(this.y, t.y)),
                            (this.z = Math.max(this.z, t.z)),
                            this
                        );
                    }
                    clamp(t, e) {
                        return (
                            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
                            this
                        );
                    }
                    clampScalar(t, e) {
                        return (
                            (this.x = Math.max(t, Math.min(e, this.x))),
                            (this.y = Math.max(t, Math.min(e, this.y))),
                            (this.z = Math.max(t, Math.min(e, this.z))),
                            this
                        );
                    }
                    clampLength(t, e) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(
                            Math.max(t, Math.min(e, n)),
                        );
                    }
                    floor() {
                        return (
                            (this.x = Math.floor(this.x)),
                            (this.y = Math.floor(this.y)),
                            (this.z = Math.floor(this.z)),
                            this
                        );
                    }
                    ceil() {
                        return (
                            (this.x = Math.ceil(this.x)),
                            (this.y = Math.ceil(this.y)),
                            (this.z = Math.ceil(this.z)),
                            this
                        );
                    }
                    round() {
                        return (
                            (this.x = Math.round(this.x)),
                            (this.y = Math.round(this.y)),
                            (this.z = Math.round(this.z)),
                            this
                        );
                    }
                    roundToZero() {
                        return (
                            (this.x =
                                this.x < 0
                                    ? Math.ceil(this.x)
                                    : Math.floor(this.x)),
                            (this.y =
                                this.y < 0
                                    ? Math.ceil(this.y)
                                    : Math.floor(this.y)),
                            (this.z =
                                this.z < 0
                                    ? Math.ceil(this.z)
                                    : Math.floor(this.z)),
                            this
                        );
                    }
                    negate() {
                        return (
                            (this.x = -this.x),
                            (this.y = -this.y),
                            (this.z = -this.z),
                            this
                        );
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z;
                    }
                    lengthSq() {
                        return (
                            this.x * this.x + this.y * this.y + this.z * this.z
                        );
                    }
                    length() {
                        return Math.sqrt(
                            this.x * this.x + this.y * this.y + this.z * this.z,
                        );
                    }
                    manhattanLength() {
                        return (
                            Math.abs(this.x) +
                            Math.abs(this.y) +
                            Math.abs(this.z)
                        );
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1);
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t);
                    }
                    lerp(t, e) {
                        return (
                            (this.x += (t.x - this.x) * e),
                            (this.y += (t.y - this.y) * e),
                            (this.z += (t.z - this.z) * e),
                            this
                        );
                    }
                    lerpVectors(t, e, n) {
                        return (
                            (this.x = t.x + (e.x - t.x) * n),
                            (this.y = t.y + (e.y - t.y) * n),
                            (this.z = t.z + (e.z - t.z) * n),
                            this
                        );
                    }
                    cross(t) {
                        return this.crossVectors(this, t);
                    }
                    crossVectors(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z,
                            a = e.x,
                            s = e.y,
                            o = e.z;
                        return (
                            (this.x = i * o - r * s),
                            (this.y = r * a - n * o),
                            (this.z = n * s - i * a),
                            this
                        );
                    }
                    projectOnVector(t) {
                        const e = t.lengthSq();
                        if (0 === e) return this.set(0, 0, 0);
                        const n = t.dot(this) / e;
                        return this.copy(t).multiplyScalar(n);
                    }
                    projectOnPlane(t) {
                        return Mt.copy(this).projectOnVector(t), this.sub(Mt);
                    }
                    reflect(t) {
                        return this.sub(
                            Mt.copy(t).multiplyScalar(2 * this.dot(t)),
                        );
                    }
                    angleTo(t) {
                        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                        if (0 === e) return Math.PI / 2;
                        const n = this.dot(t) / e;
                        return Math.acos(F(n, -1, 1));
                    }
                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t));
                    }
                    distanceToSquared(t) {
                        const e = this.x - t.x,
                            n = this.y - t.y,
                            i = this.z - t.z;
                        return e * e + n * n + i * i;
                    }
                    manhattanDistanceTo(t) {
                        return (
                            Math.abs(this.x - t.x) +
                            Math.abs(this.y - t.y) +
                            Math.abs(this.z - t.z)
                        );
                    }
                    setFromSpherical(t) {
                        return this.setFromSphericalCoords(
                            t.radius,
                            t.phi,
                            t.theta,
                        );
                    }
                    setFromSphericalCoords(t, e, n) {
                        const i = Math.sin(e) * t;
                        return (
                            (this.x = i * Math.sin(n)),
                            (this.y = Math.cos(e) * t),
                            (this.z = i * Math.cos(n)),
                            this
                        );
                    }
                    setFromCylindrical(t) {
                        return this.setFromCylindricalCoords(
                            t.radius,
                            t.theta,
                            t.y,
                        );
                    }
                    setFromCylindricalCoords(t, e, n) {
                        return (
                            (this.x = t * Math.sin(e)),
                            (this.y = n),
                            (this.z = t * Math.cos(e)),
                            this
                        );
                    }
                    setFromMatrixPosition(t) {
                        const e = t.elements;
                        return (
                            (this.x = e[12]),
                            (this.y = e[13]),
                            (this.z = e[14]),
                            this
                        );
                    }
                    setFromMatrixScale(t) {
                        const e = this.setFromMatrixColumn(t, 0).length(),
                            n = this.setFromMatrixColumn(t, 1).length(),
                            i = this.setFromMatrixColumn(t, 2).length();
                        return (this.x = e), (this.y = n), (this.z = i), this;
                    }
                    setFromMatrixColumn(t, e) {
                        return this.fromArray(t.elements, 4 * e);
                    }
                    setFromMatrix3Column(t, e) {
                        return this.fromArray(t.elements, 3 * e);
                    }
                    setFromEuler(t) {
                        return (
                            (this.x = t._x),
                            (this.y = t._y),
                            (this.z = t._z),
                            this
                        );
                    }
                    equals(t) {
                        return (
                            t.x === this.x && t.y === this.y && t.z === this.z
                        );
                    }
                    fromArray(t, e = 0) {
                        return (
                            (this.x = t[e]),
                            (this.y = t[e + 1]),
                            (this.z = t[e + 2]),
                            this
                        );
                    }
                    toArray(t = [], e = 0) {
                        return (
                            (t[e] = this.x),
                            (t[e + 1] = this.y),
                            (t[e + 2] = this.z),
                            t
                        );
                    }
                    fromBufferAttribute(t, e) {
                        return (
                            (this.x = t.getX(e)),
                            (this.y = t.getY(e)),
                            (this.z = t.getZ(e)),
                            this
                        );
                    }
                    random() {
                        return (
                            (this.x = Math.random()),
                            (this.y = Math.random()),
                            (this.z = Math.random()),
                            this
                        );
                    }
                    randomDirection() {
                        const t = 2 * (Math.random() - 0.5),
                            e = Math.random() * Math.PI * 2,
                            n = Math.sqrt(1 - t ** 2);
                        return (
                            (this.x = n * Math.cos(e)),
                            (this.y = n * Math.sin(e)),
                            (this.z = t),
                            this
                        );
                    }
                    *[Symbol.iterator]() {
                        yield this.x, yield this.y, yield this.z;
                    }
                }
                const Mt = new St(),
                    At = new yt();
                class _t {
                    constructor(
                        t = new St(1 / 0, 1 / 0, 1 / 0),
                        e = new St(-1 / 0, -1 / 0, -1 / 0),
                    ) {
                        (this.isBox3 = !0), (this.min = t), (this.max = e);
                    }
                    set(t, e) {
                        return this.min.copy(t), this.max.copy(e), this;
                    }
                    setFromArray(t) {
                        let e = 1 / 0,
                            n = 1 / 0,
                            i = 1 / 0,
                            r = -1 / 0,
                            a = -1 / 0,
                            s = -1 / 0;
                        for (let o = 0, l = t.length; o < l; o += 3) {
                            const l = t[o],
                                c = t[o + 1],
                                h = t[o + 2];
                            l < e && (e = l),
                                c < n && (n = c),
                                h < i && (i = h),
                                l > r && (r = l),
                                c > a && (a = c),
                                h > s && (s = h);
                        }
                        return (
                            this.min.set(e, n, i), this.max.set(r, a, s), this
                        );
                    }
                    setFromBufferAttribute(t) {
                        let e = 1 / 0,
                            n = 1 / 0,
                            i = 1 / 0,
                            r = -1 / 0,
                            a = -1 / 0,
                            s = -1 / 0;
                        for (let o = 0, l = t.count; o < l; o++) {
                            const l = t.getX(o),
                                c = t.getY(o),
                                h = t.getZ(o);
                            l < e && (e = l),
                                c < n && (n = c),
                                h < i && (i = h),
                                l > r && (r = l),
                                c > a && (a = c),
                                h > s && (s = h);
                        }
                        return (
                            this.min.set(e, n, i), this.max.set(r, a, s), this
                        );
                    }
                    setFromPoints(t) {
                        this.makeEmpty();
                        for (let e = 0, n = t.length; e < n; e++)
                            this.expandByPoint(t[e]);
                        return this;
                    }
                    setFromCenterAndSize(t, e) {
                        const n = Tt.copy(e).multiplyScalar(0.5);
                        return (
                            this.min.copy(t).sub(n),
                            this.max.copy(t).add(n),
                            this
                        );
                    }
                    setFromObject(t, e = !1) {
                        return this.makeEmpty(), this.expandByObject(t, e);
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(t) {
                        return this.min.copy(t.min), this.max.copy(t.max), this;
                    }
                    makeEmpty() {
                        return (
                            (this.min.x = this.min.y = this.min.z = 1 / 0),
                            (this.max.x = this.max.y = this.max.z = -1 / 0),
                            this
                        );
                    }
                    isEmpty() {
                        return (
                            this.max.x < this.min.x ||
                            this.max.y < this.min.y ||
                            this.max.z < this.min.z
                        );
                    }
                    getCenter(t) {
                        return this.isEmpty()
                            ? t.set(0, 0, 0)
                            : t
                                  .addVectors(this.min, this.max)
                                  .multiplyScalar(0.5);
                    }
                    getSize(t) {
                        return this.isEmpty()
                            ? t.set(0, 0, 0)
                            : t.subVectors(this.max, this.min);
                    }
                    expandByPoint(t) {
                        return this.min.min(t), this.max.max(t), this;
                    }
                    expandByVector(t) {
                        return this.min.sub(t), this.max.add(t), this;
                    }
                    expandByScalar(t) {
                        return (
                            this.min.addScalar(-t), this.max.addScalar(t), this
                        );
                    }
                    expandByObject(t, e = !1) {
                        t.updateWorldMatrix(!1, !1);
                        const n = t.geometry;
                        if (void 0 !== n)
                            if (
                                e &&
                                null != n.attributes &&
                                void 0 !== n.attributes.position
                            ) {
                                const e = n.attributes.position;
                                for (let n = 0, i = e.count; n < i; n++)
                                    Tt.fromBufferAttribute(e, n).applyMatrix4(
                                        t.matrixWorld,
                                    ),
                                        this.expandByPoint(Tt);
                            } else
                                null === n.boundingBox &&
                                    n.computeBoundingBox(),
                                    Et.copy(n.boundingBox),
                                    Et.applyMatrix4(t.matrixWorld),
                                    this.union(Et);
                        const i = t.children;
                        for (let t = 0, n = i.length; t < n; t++)
                            this.expandByObject(i[t], e);
                        return this;
                    }
                    containsPoint(t) {
                        return !(
                            t.x < this.min.x ||
                            t.x > this.max.x ||
                            t.y < this.min.y ||
                            t.y > this.max.y ||
                            t.z < this.min.z ||
                            t.z > this.max.z
                        );
                    }
                    containsBox(t) {
                        return (
                            this.min.x <= t.min.x &&
                            t.max.x <= this.max.x &&
                            this.min.y <= t.min.y &&
                            t.max.y <= this.max.y &&
                            this.min.z <= t.min.z &&
                            t.max.z <= this.max.z
                        );
                    }
                    getParameter(t, e) {
                        return e.set(
                            (t.x - this.min.x) / (this.max.x - this.min.x),
                            (t.y - this.min.y) / (this.max.y - this.min.y),
                            (t.z - this.min.z) / (this.max.z - this.min.z),
                        );
                    }
                    intersectsBox(t) {
                        return !(
                            t.max.x < this.min.x ||
                            t.min.x > this.max.x ||
                            t.max.y < this.min.y ||
                            t.min.y > this.max.y ||
                            t.max.z < this.min.z ||
                            t.min.z > this.max.z
                        );
                    }
                    intersectsSphere(t) {
                        return (
                            this.clampPoint(t.center, Tt),
                            Tt.distanceToSquared(t.center) <=
                                t.radius * t.radius
                        );
                    }
                    intersectsPlane(t) {
                        let e, n;
                        return (
                            t.normal.x > 0
                                ? ((e = t.normal.x * this.min.x),
                                  (n = t.normal.x * this.max.x))
                                : ((e = t.normal.x * this.max.x),
                                  (n = t.normal.x * this.min.x)),
                            t.normal.y > 0
                                ? ((e += t.normal.y * this.min.y),
                                  (n += t.normal.y * this.max.y))
                                : ((e += t.normal.y * this.max.y),
                                  (n += t.normal.y * this.min.y)),
                            t.normal.z > 0
                                ? ((e += t.normal.z * this.min.z),
                                  (n += t.normal.z * this.max.z))
                                : ((e += t.normal.z * this.max.z),
                                  (n += t.normal.z * this.min.z)),
                            e <= -t.constant && n >= -t.constant
                        );
                    }
                    intersectsTriangle(t) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(Dt),
                            Pt.subVectors(this.max, Dt),
                            Rt.subVectors(t.a, Dt),
                            kt.subVectors(t.b, Dt),
                            Ct.subVectors(t.c, Dt),
                            Lt.subVectors(kt, Rt),
                            It.subVectors(Ct, kt),
                            Ot.subVectors(Rt, Ct);
                        let e = [
                            0,
                            -Lt.z,
                            Lt.y,
                            0,
                            -It.z,
                            It.y,
                            0,
                            -Ot.z,
                            Ot.y,
                            Lt.z,
                            0,
                            -Lt.x,
                            It.z,
                            0,
                            -It.x,
                            Ot.z,
                            0,
                            -Ot.x,
                            -Lt.y,
                            Lt.x,
                            0,
                            -It.y,
                            It.x,
                            0,
                            -Ot.y,
                            Ot.x,
                            0,
                        ];
                        return (
                            !!Nt(e, Rt, kt, Ct, Pt) &&
                            ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
                            !!Nt(e, Rt, kt, Ct, Pt) &&
                                (Ut.crossVectors(Lt, It),
                                (e = [Ut.x, Ut.y, Ut.z]),
                                Nt(e, Rt, kt, Ct, Pt)))
                        );
                    }
                    clampPoint(t, e) {
                        return e.copy(t).clamp(this.min, this.max);
                    }
                    distanceToPoint(t) {
                        return Tt.copy(t)
                            .clamp(this.min, this.max)
                            .sub(t)
                            .length();
                    }
                    getBoundingSphere(t) {
                        return (
                            this.getCenter(t.center),
                            (t.radius = 0.5 * this.getSize(Tt).length()),
                            t
                        );
                    }
                    intersect(t) {
                        return (
                            this.min.max(t.min),
                            this.max.min(t.max),
                            this.isEmpty() && this.makeEmpty(),
                            this
                        );
                    }
                    union(t) {
                        return this.min.min(t.min), this.max.max(t.max), this;
                    }
                    applyMatrix4(t) {
                        return (
                            this.isEmpty() ||
                                (wt[0]
                                    .set(this.min.x, this.min.y, this.min.z)
                                    .applyMatrix4(t),
                                wt[1]
                                    .set(this.min.x, this.min.y, this.max.z)
                                    .applyMatrix4(t),
                                wt[2]
                                    .set(this.min.x, this.max.y, this.min.z)
                                    .applyMatrix4(t),
                                wt[3]
                                    .set(this.min.x, this.max.y, this.max.z)
                                    .applyMatrix4(t),
                                wt[4]
                                    .set(this.max.x, this.min.y, this.min.z)
                                    .applyMatrix4(t),
                                wt[5]
                                    .set(this.max.x, this.min.y, this.max.z)
                                    .applyMatrix4(t),
                                wt[6]
                                    .set(this.max.x, this.max.y, this.min.z)
                                    .applyMatrix4(t),
                                wt[7]
                                    .set(this.max.x, this.max.y, this.max.z)
                                    .applyMatrix4(t),
                                this.setFromPoints(wt)),
                            this
                        );
                    }
                    translate(t) {
                        return this.min.add(t), this.max.add(t), this;
                    }
                    equals(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max);
                    }
                }
                const wt = [
                        new St(),
                        new St(),
                        new St(),
                        new St(),
                        new St(),
                        new St(),
                        new St(),
                        new St(),
                    ],
                    Tt = new St(),
                    Et = new _t(),
                    Rt = new St(),
                    kt = new St(),
                    Ct = new St(),
                    Lt = new St(),
                    It = new St(),
                    Ot = new St(),
                    Dt = new St(),
                    Pt = new St(),
                    Ut = new St(),
                    Vt = new St();
                function Nt(t, e, n, i, r) {
                    for (let a = 0, s = t.length - 3; a <= s; a += 3) {
                        Vt.fromArray(t, a);
                        const s =
                                r.x * Math.abs(Vt.x) +
                                r.y * Math.abs(Vt.y) +
                                r.z * Math.abs(Vt.z),
                            o = e.dot(Vt),
                            l = n.dot(Vt),
                            c = i.dot(Vt);
                        if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > s)
                            return !1;
                    }
                    return !0;
                }
                const Gt = new _t(),
                    jt = new St(),
                    Ht = new St();
                class Ft {
                    constructor(t = new St(), e = -1) {
                        (this.center = t), (this.radius = e);
                    }
                    set(t, e) {
                        return this.center.copy(t), (this.radius = e), this;
                    }
                    setFromPoints(t, e) {
                        const n = this.center;
                        void 0 !== e
                            ? n.copy(e)
                            : Gt.setFromPoints(t).getCenter(n);
                        let i = 0;
                        for (let e = 0, r = t.length; e < r; e++)
                            i = Math.max(i, n.distanceToSquared(t[e]));
                        return (this.radius = Math.sqrt(i)), this;
                    }
                    copy(t) {
                        return (
                            this.center.copy(t.center),
                            (this.radius = t.radius),
                            this
                        );
                    }
                    isEmpty() {
                        return this.radius < 0;
                    }
                    makeEmpty() {
                        return (
                            this.center.set(0, 0, 0), (this.radius = -1), this
                        );
                    }
                    containsPoint(t) {
                        return (
                            t.distanceToSquared(this.center) <=
                            this.radius * this.radius
                        );
                    }
                    distanceToPoint(t) {
                        return t.distanceTo(this.center) - this.radius;
                    }
                    intersectsSphere(t) {
                        const e = this.radius + t.radius;
                        return t.center.distanceToSquared(this.center) <= e * e;
                    }
                    intersectsBox(t) {
                        return t.intersectsSphere(this);
                    }
                    intersectsPlane(t) {
                        return (
                            Math.abs(t.distanceToPoint(this.center)) <=
                            this.radius
                        );
                    }
                    clampPoint(t, e) {
                        const n = this.center.distanceToSquared(t);
                        return (
                            e.copy(t),
                            n > this.radius * this.radius &&
                                (e.sub(this.center).normalize(),
                                e.multiplyScalar(this.radius).add(this.center)),
                            e
                        );
                    }
                    getBoundingBox(t) {
                        return this.isEmpty()
                            ? (t.makeEmpty(), t)
                            : (t.set(this.center, this.center),
                              t.expandByScalar(this.radius),
                              t);
                    }
                    applyMatrix4(t) {
                        return (
                            this.center.applyMatrix4(t),
                            (this.radius = this.radius * t.getMaxScaleOnAxis()),
                            this
                        );
                    }
                    translate(t) {
                        return this.center.add(t), this;
                    }
                    expandByPoint(t) {
                        if (this.isEmpty())
                            return this.center.copy(t), (this.radius = 0), this;
                        jt.subVectors(t, this.center);
                        const e = jt.lengthSq();
                        if (e > this.radius * this.radius) {
                            const t = Math.sqrt(e),
                                n = 0.5 * (t - this.radius);
                            this.center.addScaledVector(jt, n / t),
                                (this.radius += n);
                        }
                        return this;
                    }
                    union(t) {
                        return t.isEmpty()
                            ? this
                            : this.isEmpty()
                            ? (this.copy(t), this)
                            : (!0 === this.center.equals(t.center)
                                  ? (this.radius = Math.max(
                                        this.radius,
                                        t.radius,
                                    ))
                                  : (Ht.subVectors(
                                        t.center,
                                        this.center,
                                    ).setLength(t.radius),
                                    this.expandByPoint(
                                        jt.copy(t.center).add(Ht),
                                    ),
                                    this.expandByPoint(
                                        jt.copy(t.center).sub(Ht),
                                    )),
                              this);
                    }
                    equals(t) {
                        return (
                            t.center.equals(this.center) &&
                            t.radius === this.radius
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                const Bt = new St(),
                    zt = new St(),
                    Wt = new St(),
                    qt = new St(),
                    Yt = new St(),
                    Kt = new St(),
                    Jt = new St();
                class Zt {
                    constructor(t = new St(), e = new St(0, 0, -1)) {
                        (this.origin = t), (this.direction = e);
                    }
                    set(t, e) {
                        return (
                            this.origin.copy(t), this.direction.copy(e), this
                        );
                    }
                    copy(t) {
                        return (
                            this.origin.copy(t.origin),
                            this.direction.copy(t.direction),
                            this
                        );
                    }
                    at(t, e) {
                        return e
                            .copy(this.direction)
                            .multiplyScalar(t)
                            .add(this.origin);
                    }
                    lookAt(t) {
                        return (
                            this.direction.copy(t).sub(this.origin).normalize(),
                            this
                        );
                    }
                    recast(t) {
                        return this.origin.copy(this.at(t, Bt)), this;
                    }
                    closestPointToPoint(t, e) {
                        e.subVectors(t, this.origin);
                        const n = e.dot(this.direction);
                        return n < 0
                            ? e.copy(this.origin)
                            : e
                                  .copy(this.direction)
                                  .multiplyScalar(n)
                                  .add(this.origin);
                    }
                    distanceToPoint(t) {
                        return Math.sqrt(this.distanceSqToPoint(t));
                    }
                    distanceSqToPoint(t) {
                        const e = Bt.subVectors(t, this.origin).dot(
                            this.direction,
                        );
                        return e < 0
                            ? this.origin.distanceToSquared(t)
                            : (Bt.copy(this.direction)
                                  .multiplyScalar(e)
                                  .add(this.origin),
                              Bt.distanceToSquared(t));
                    }
                    distanceSqToSegment(t, e, n, i) {
                        zt.copy(t).add(e).multiplyScalar(0.5),
                            Wt.copy(e).sub(t).normalize(),
                            qt.copy(this.origin).sub(zt);
                        const r = 0.5 * t.distanceTo(e),
                            a = -this.direction.dot(Wt),
                            s = qt.dot(this.direction),
                            o = -qt.dot(Wt),
                            l = qt.lengthSq(),
                            c = Math.abs(1 - a * a);
                        let h, u, d, p;
                        if (c > 0)
                            if (
                                ((h = a * o - s),
                                (u = a * s - o),
                                (p = r * c),
                                h >= 0)
                            )
                                if (u >= -p)
                                    if (u <= p) {
                                        const t = 1 / c;
                                        (h *= t),
                                            (u *= t),
                                            (d =
                                                h * (h + a * u + 2 * s) +
                                                u * (a * h + u + 2 * o) +
                                                l);
                                    } else
                                        (u = r),
                                            (h = Math.max(0, -(a * u + s))),
                                            (d = -h * h + u * (u + 2 * o) + l);
                                else
                                    (u = -r),
                                        (h = Math.max(0, -(a * u + s))),
                                        (d = -h * h + u * (u + 2 * o) + l);
                            else
                                u <= -p
                                    ? ((h = Math.max(0, -(-a * r + s))),
                                      (u =
                                          h > 0
                                              ? -r
                                              : Math.min(Math.max(-r, -o), r)),
                                      (d = -h * h + u * (u + 2 * o) + l))
                                    : u <= p
                                    ? ((h = 0),
                                      (u = Math.min(Math.max(-r, -o), r)),
                                      (d = u * (u + 2 * o) + l))
                                    : ((h = Math.max(0, -(a * r + s))),
                                      (u =
                                          h > 0
                                              ? r
                                              : Math.min(Math.max(-r, -o), r)),
                                      (d = -h * h + u * (u + 2 * o) + l));
                        else
                            (u = a > 0 ? -r : r),
                                (h = Math.max(0, -(a * u + s))),
                                (d = -h * h + u * (u + 2 * o) + l);
                        return (
                            n &&
                                n
                                    .copy(this.direction)
                                    .multiplyScalar(h)
                                    .add(this.origin),
                            i && i.copy(Wt).multiplyScalar(u).add(zt),
                            d
                        );
                    }
                    intersectSphere(t, e) {
                        Bt.subVectors(t.center, this.origin);
                        const n = Bt.dot(this.direction),
                            i = Bt.dot(Bt) - n * n,
                            r = t.radius * t.radius;
                        if (i > r) return null;
                        const a = Math.sqrt(r - i),
                            s = n - a,
                            o = n + a;
                        return s < 0 && o < 0
                            ? null
                            : s < 0
                            ? this.at(o, e)
                            : this.at(s, e);
                    }
                    intersectsSphere(t) {
                        return (
                            this.distanceSqToPoint(t.center) <=
                            t.radius * t.radius
                        );
                    }
                    distanceToPlane(t) {
                        const e = t.normal.dot(this.direction);
                        if (0 === e)
                            return 0 === t.distanceToPoint(this.origin)
                                ? 0
                                : null;
                        const n = -(this.origin.dot(t.normal) + t.constant) / e;
                        return n >= 0 ? n : null;
                    }
                    intersectPlane(t, e) {
                        const n = this.distanceToPlane(t);
                        return null === n ? null : this.at(n, e);
                    }
                    intersectsPlane(t) {
                        const e = t.distanceToPoint(this.origin);
                        return 0 === e || t.normal.dot(this.direction) * e < 0;
                    }
                    intersectBox(t, e) {
                        let n, i, r, a, s, o;
                        const l = 1 / this.direction.x,
                            c = 1 / this.direction.y,
                            h = 1 / this.direction.z,
                            u = this.origin;
                        return (
                            l >= 0
                                ? ((n = (t.min.x - u.x) * l),
                                  (i = (t.max.x - u.x) * l))
                                : ((n = (t.max.x - u.x) * l),
                                  (i = (t.min.x - u.x) * l)),
                            c >= 0
                                ? ((r = (t.min.y - u.y) * c),
                                  (a = (t.max.y - u.y) * c))
                                : ((r = (t.max.y - u.y) * c),
                                  (a = (t.min.y - u.y) * c)),
                            n > a || r > i
                                ? null
                                : ((r > n || isNaN(n)) && (n = r),
                                  (a < i || isNaN(i)) && (i = a),
                                  h >= 0
                                      ? ((s = (t.min.z - u.z) * h),
                                        (o = (t.max.z - u.z) * h))
                                      : ((s = (t.max.z - u.z) * h),
                                        (o = (t.min.z - u.z) * h)),
                                  n > o || s > i
                                      ? null
                                      : ((s > n || n != n) && (n = s),
                                        (o < i || i != i) && (i = o),
                                        i < 0
                                            ? null
                                            : this.at(n >= 0 ? n : i, e)))
                        );
                    }
                    intersectsBox(t) {
                        return null !== this.intersectBox(t, Bt);
                    }
                    intersectTriangle(t, e, n, i, r) {
                        Yt.subVectors(e, t),
                            Kt.subVectors(n, t),
                            Jt.crossVectors(Yt, Kt);
                        let a,
                            s = this.direction.dot(Jt);
                        if (s > 0) {
                            if (i) return null;
                            a = 1;
                        } else {
                            if (!(s < 0)) return null;
                            (a = -1), (s = -s);
                        }
                        qt.subVectors(this.origin, t);
                        const o =
                            a * this.direction.dot(Kt.crossVectors(qt, Kt));
                        if (o < 0) return null;
                        const l = a * this.direction.dot(Yt.cross(qt));
                        if (l < 0) return null;
                        if (o + l > s) return null;
                        const c = -a * qt.dot(Jt);
                        return c < 0 ? null : this.at(c / s, r);
                    }
                    applyMatrix4(t) {
                        return (
                            this.origin.applyMatrix4(t),
                            this.direction.transformDirection(t),
                            this
                        );
                    }
                    equals(t) {
                        return (
                            t.origin.equals(this.origin) &&
                            t.direction.equals(this.direction)
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                class Xt {
                    constructor() {
                        (Xt.prototype.isMatrix4 = !0),
                            (this.elements = [
                                1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
                            ]);
                    }
                    set(t, e, n, i, r, a, s, o, l, c, h, u, d, p, f, m) {
                        const g = this.elements;
                        return (
                            (g[0] = t),
                            (g[4] = e),
                            (g[8] = n),
                            (g[12] = i),
                            (g[1] = r),
                            (g[5] = a),
                            (g[9] = s),
                            (g[13] = o),
                            (g[2] = l),
                            (g[6] = c),
                            (g[10] = h),
                            (g[14] = u),
                            (g[3] = d),
                            (g[7] = p),
                            (g[11] = f),
                            (g[15] = m),
                            this
                        );
                    }
                    identity() {
                        return (
                            this.set(
                                1,
                                0,
                                0,
                                0,
                                0,
                                1,
                                0,
                                0,
                                0,
                                0,
                                1,
                                0,
                                0,
                                0,
                                0,
                                1,
                            ),
                            this
                        );
                    }
                    clone() {
                        return new Xt().fromArray(this.elements);
                    }
                    copy(t) {
                        const e = this.elements,
                            n = t.elements;
                        return (
                            (e[0] = n[0]),
                            (e[1] = n[1]),
                            (e[2] = n[2]),
                            (e[3] = n[3]),
                            (e[4] = n[4]),
                            (e[5] = n[5]),
                            (e[6] = n[6]),
                            (e[7] = n[7]),
                            (e[8] = n[8]),
                            (e[9] = n[9]),
                            (e[10] = n[10]),
                            (e[11] = n[11]),
                            (e[12] = n[12]),
                            (e[13] = n[13]),
                            (e[14] = n[14]),
                            (e[15] = n[15]),
                            this
                        );
                    }
                    copyPosition(t) {
                        const e = this.elements,
                            n = t.elements;
                        return (
                            (e[12] = n[12]),
                            (e[13] = n[13]),
                            (e[14] = n[14]),
                            this
                        );
                    }
                    setFromMatrix3(t) {
                        const e = t.elements;
                        return (
                            this.set(
                                e[0],
                                e[3],
                                e[6],
                                0,
                                e[1],
                                e[4],
                                e[7],
                                0,
                                e[2],
                                e[5],
                                e[8],
                                0,
                                0,
                                0,
                                0,
                                1,
                            ),
                            this
                        );
                    }
                    extractBasis(t, e, n) {
                        return (
                            t.setFromMatrixColumn(this, 0),
                            e.setFromMatrixColumn(this, 1),
                            n.setFromMatrixColumn(this, 2),
                            this
                        );
                    }
                    makeBasis(t, e, n) {
                        return (
                            this.set(
                                t.x,
                                e.x,
                                n.x,
                                0,
                                t.y,
                                e.y,
                                n.y,
                                0,
                                t.z,
                                e.z,
                                n.z,
                                0,
                                0,
                                0,
                                0,
                                1,
                            ),
                            this
                        );
                    }
                    extractRotation(t) {
                        const e = this.elements,
                            n = t.elements,
                            i = 1 / Qt.setFromMatrixColumn(t, 0).length(),
                            r = 1 / Qt.setFromMatrixColumn(t, 1).length(),
                            a = 1 / Qt.setFromMatrixColumn(t, 2).length();
                        return (
                            (e[0] = n[0] * i),
                            (e[1] = n[1] * i),
                            (e[2] = n[2] * i),
                            (e[3] = 0),
                            (e[4] = n[4] * r),
                            (e[5] = n[5] * r),
                            (e[6] = n[6] * r),
                            (e[7] = 0),
                            (e[8] = n[8] * a),
                            (e[9] = n[9] * a),
                            (e[10] = n[10] * a),
                            (e[11] = 0),
                            (e[12] = 0),
                            (e[13] = 0),
                            (e[14] = 0),
                            (e[15] = 1),
                            this
                        );
                    }
                    makeRotationFromEuler(t) {
                        const e = this.elements,
                            n = t.x,
                            i = t.y,
                            r = t.z,
                            a = Math.cos(n),
                            s = Math.sin(n),
                            o = Math.cos(i),
                            l = Math.sin(i),
                            c = Math.cos(r),
                            h = Math.sin(r);
                        if ("XYZ" === t.order) {
                            const t = a * c,
                                n = a * h,
                                i = s * c,
                                r = s * h;
                            (e[0] = o * c),
                                (e[4] = -o * h),
                                (e[8] = l),
                                (e[1] = n + i * l),
                                (e[5] = t - r * l),
                                (e[9] = -s * o),
                                (e[2] = r - t * l),
                                (e[6] = i + n * l),
                                (e[10] = a * o);
                        } else if ("YXZ" === t.order) {
                            const t = o * c,
                                n = o * h,
                                i = l * c,
                                r = l * h;
                            (e[0] = t + r * s),
                                (e[4] = i * s - n),
                                (e[8] = a * l),
                                (e[1] = a * h),
                                (e[5] = a * c),
                                (e[9] = -s),
                                (e[2] = n * s - i),
                                (e[6] = r + t * s),
                                (e[10] = a * o);
                        } else if ("ZXY" === t.order) {
                            const t = o * c,
                                n = o * h,
                                i = l * c,
                                r = l * h;
                            (e[0] = t - r * s),
                                (e[4] = -a * h),
                                (e[8] = i + n * s),
                                (e[1] = n + i * s),
                                (e[5] = a * c),
                                (e[9] = r - t * s),
                                (e[2] = -a * l),
                                (e[6] = s),
                                (e[10] = a * o);
                        } else if ("ZYX" === t.order) {
                            const t = a * c,
                                n = a * h,
                                i = s * c,
                                r = s * h;
                            (e[0] = o * c),
                                (e[4] = i * l - n),
                                (e[8] = t * l + r),
                                (e[1] = o * h),
                                (e[5] = r * l + t),
                                (e[9] = n * l - i),
                                (e[2] = -l),
                                (e[6] = s * o),
                                (e[10] = a * o);
                        } else if ("YZX" === t.order) {
                            const t = a * o,
                                n = a * l,
                                i = s * o,
                                r = s * l;
                            (e[0] = o * c),
                                (e[4] = r - t * h),
                                (e[8] = i * h + n),
                                (e[1] = h),
                                (e[5] = a * c),
                                (e[9] = -s * c),
                                (e[2] = -l * c),
                                (e[6] = n * h + i),
                                (e[10] = t - r * h);
                        } else if ("XZY" === t.order) {
                            const t = a * o,
                                n = a * l,
                                i = s * o,
                                r = s * l;
                            (e[0] = o * c),
                                (e[4] = -h),
                                (e[8] = l * c),
                                (e[1] = t * h + r),
                                (e[5] = a * c),
                                (e[9] = n * h - i),
                                (e[2] = i * h - n),
                                (e[6] = s * c),
                                (e[10] = r * h + t);
                        }
                        return (
                            (e[3] = 0),
                            (e[7] = 0),
                            (e[11] = 0),
                            (e[12] = 0),
                            (e[13] = 0),
                            (e[14] = 0),
                            (e[15] = 1),
                            this
                        );
                    }
                    makeRotationFromQuaternion(t) {
                        return this.compose(te, t, ee);
                    }
                    lookAt(t, e, n) {
                        const i = this.elements;
                        return (
                            re.subVectors(t, e),
                            0 === re.lengthSq() && (re.z = 1),
                            re.normalize(),
                            ne.crossVectors(n, re),
                            0 === ne.lengthSq() &&
                                (1 === Math.abs(n.z)
                                    ? (re.x += 1e-4)
                                    : (re.z += 1e-4),
                                re.normalize(),
                                ne.crossVectors(n, re)),
                            ne.normalize(),
                            ie.crossVectors(re, ne),
                            (i[0] = ne.x),
                            (i[4] = ie.x),
                            (i[8] = re.x),
                            (i[1] = ne.y),
                            (i[5] = ie.y),
                            (i[9] = re.y),
                            (i[2] = ne.z),
                            (i[6] = ie.z),
                            (i[10] = re.z),
                            this
                        );
                    }
                    multiply(t) {
                        return this.multiplyMatrices(this, t);
                    }
                    premultiply(t) {
                        return this.multiplyMatrices(t, this);
                    }
                    multiplyMatrices(t, e) {
                        const n = t.elements,
                            i = e.elements,
                            r = this.elements,
                            a = n[0],
                            s = n[4],
                            o = n[8],
                            l = n[12],
                            c = n[1],
                            h = n[5],
                            u = n[9],
                            d = n[13],
                            p = n[2],
                            f = n[6],
                            m = n[10],
                            g = n[14],
                            v = n[3],
                            x = n[7],
                            b = n[11],
                            y = n[15],
                            S = i[0],
                            M = i[4],
                            A = i[8],
                            _ = i[12],
                            w = i[1],
                            T = i[5],
                            E = i[9],
                            R = i[13],
                            k = i[2],
                            C = i[6],
                            L = i[10],
                            I = i[14],
                            O = i[3],
                            D = i[7],
                            P = i[11],
                            U = i[15];
                        return (
                            (r[0] = a * S + s * w + o * k + l * O),
                            (r[4] = a * M + s * T + o * C + l * D),
                            (r[8] = a * A + s * E + o * L + l * P),
                            (r[12] = a * _ + s * R + o * I + l * U),
                            (r[1] = c * S + h * w + u * k + d * O),
                            (r[5] = c * M + h * T + u * C + d * D),
                            (r[9] = c * A + h * E + u * L + d * P),
                            (r[13] = c * _ + h * R + u * I + d * U),
                            (r[2] = p * S + f * w + m * k + g * O),
                            (r[6] = p * M + f * T + m * C + g * D),
                            (r[10] = p * A + f * E + m * L + g * P),
                            (r[14] = p * _ + f * R + m * I + g * U),
                            (r[3] = v * S + x * w + b * k + y * O),
                            (r[7] = v * M + x * T + b * C + y * D),
                            (r[11] = v * A + x * E + b * L + y * P),
                            (r[15] = v * _ + x * R + b * I + y * U),
                            this
                        );
                    }
                    multiplyScalar(t) {
                        const e = this.elements;
                        return (
                            (e[0] *= t),
                            (e[4] *= t),
                            (e[8] *= t),
                            (e[12] *= t),
                            (e[1] *= t),
                            (e[5] *= t),
                            (e[9] *= t),
                            (e[13] *= t),
                            (e[2] *= t),
                            (e[6] *= t),
                            (e[10] *= t),
                            (e[14] *= t),
                            (e[3] *= t),
                            (e[7] *= t),
                            (e[11] *= t),
                            (e[15] *= t),
                            this
                        );
                    }
                    determinant() {
                        const t = this.elements,
                            e = t[0],
                            n = t[4],
                            i = t[8],
                            r = t[12],
                            a = t[1],
                            s = t[5],
                            o = t[9],
                            l = t[13],
                            c = t[2],
                            h = t[6],
                            u = t[10],
                            d = t[14];
                        return (
                            t[3] *
                                (+r * o * h -
                                    i * l * h -
                                    r * s * u +
                                    n * l * u +
                                    i * s * d -
                                    n * o * d) +
                            t[7] *
                                (+e * o * d -
                                    e * l * u +
                                    r * a * u -
                                    i * a * d +
                                    i * l * c -
                                    r * o * c) +
                            t[11] *
                                (+e * l * h -
                                    e * s * d -
                                    r * a * h +
                                    n * a * d +
                                    r * s * c -
                                    n * l * c) +
                            t[15] *
                                (-i * s * c -
                                    e * o * h +
                                    e * s * u +
                                    i * a * h -
                                    n * a * u +
                                    n * o * c)
                        );
                    }
                    transpose() {
                        const t = this.elements;
                        let e;
                        return (
                            (e = t[1]),
                            (t[1] = t[4]),
                            (t[4] = e),
                            (e = t[2]),
                            (t[2] = t[8]),
                            (t[8] = e),
                            (e = t[6]),
                            (t[6] = t[9]),
                            (t[9] = e),
                            (e = t[3]),
                            (t[3] = t[12]),
                            (t[12] = e),
                            (e = t[7]),
                            (t[7] = t[13]),
                            (t[13] = e),
                            (e = t[11]),
                            (t[11] = t[14]),
                            (t[14] = e),
                            this
                        );
                    }
                    setPosition(t, e, n) {
                        const i = this.elements;
                        return (
                            t.isVector3
                                ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
                                : ((i[12] = t), (i[13] = e), (i[14] = n)),
                            this
                        );
                    }
                    invert() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            a = t[4],
                            s = t[5],
                            o = t[6],
                            l = t[7],
                            c = t[8],
                            h = t[9],
                            u = t[10],
                            d = t[11],
                            p = t[12],
                            f = t[13],
                            m = t[14],
                            g = t[15],
                            v =
                                h * m * l -
                                f * u * l +
                                f * o * d -
                                s * m * d -
                                h * o * g +
                                s * u * g,
                            x =
                                p * u * l -
                                c * m * l -
                                p * o * d +
                                a * m * d +
                                c * o * g -
                                a * u * g,
                            b =
                                c * f * l -
                                p * h * l +
                                p * s * d -
                                a * f * d -
                                c * s * g +
                                a * h * g,
                            y =
                                p * h * o -
                                c * f * o -
                                p * s * u +
                                a * f * u +
                                c * s * m -
                                a * h * m,
                            S = e * v + n * x + i * b + r * y;
                        if (0 === S)
                            return this.set(
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                            );
                        const M = 1 / S;
                        return (
                            (t[0] = v * M),
                            (t[1] =
                                (f * u * r -
                                    h * m * r -
                                    f * i * d +
                                    n * m * d +
                                    h * i * g -
                                    n * u * g) *
                                M),
                            (t[2] =
                                (s * m * r -
                                    f * o * r +
                                    f * i * l -
                                    n * m * l -
                                    s * i * g +
                                    n * o * g) *
                                M),
                            (t[3] =
                                (h * o * r -
                                    s * u * r -
                                    h * i * l +
                                    n * u * l +
                                    s * i * d -
                                    n * o * d) *
                                M),
                            (t[4] = x * M),
                            (t[5] =
                                (c * m * r -
                                    p * u * r +
                                    p * i * d -
                                    e * m * d -
                                    c * i * g +
                                    e * u * g) *
                                M),
                            (t[6] =
                                (p * o * r -
                                    a * m * r -
                                    p * i * l +
                                    e * m * l +
                                    a * i * g -
                                    e * o * g) *
                                M),
                            (t[7] =
                                (a * u * r -
                                    c * o * r +
                                    c * i * l -
                                    e * u * l -
                                    a * i * d +
                                    e * o * d) *
                                M),
                            (t[8] = b * M),
                            (t[9] =
                                (p * h * r -
                                    c * f * r -
                                    p * n * d +
                                    e * f * d +
                                    c * n * g -
                                    e * h * g) *
                                M),
                            (t[10] =
                                (a * f * r -
                                    p * s * r +
                                    p * n * l -
                                    e * f * l -
                                    a * n * g +
                                    e * s * g) *
                                M),
                            (t[11] =
                                (c * s * r -
                                    a * h * r -
                                    c * n * l +
                                    e * h * l +
                                    a * n * d -
                                    e * s * d) *
                                M),
                            (t[12] = y * M),
                            (t[13] =
                                (c * f * i -
                                    p * h * i +
                                    p * n * u -
                                    e * f * u -
                                    c * n * m +
                                    e * h * m) *
                                M),
                            (t[14] =
                                (p * s * i -
                                    a * f * i -
                                    p * n * o +
                                    e * f * o +
                                    a * n * m -
                                    e * s * m) *
                                M),
                            (t[15] =
                                (a * h * i -
                                    c * s * i +
                                    c * n * o -
                                    e * h * o -
                                    a * n * u +
                                    e * s * u) *
                                M),
                            this
                        );
                    }
                    scale(t) {
                        const e = this.elements,
                            n = t.x,
                            i = t.y,
                            r = t.z;
                        return (
                            (e[0] *= n),
                            (e[4] *= i),
                            (e[8] *= r),
                            (e[1] *= n),
                            (e[5] *= i),
                            (e[9] *= r),
                            (e[2] *= n),
                            (e[6] *= i),
                            (e[10] *= r),
                            (e[3] *= n),
                            (e[7] *= i),
                            (e[11] *= r),
                            this
                        );
                    }
                    getMaxScaleOnAxis() {
                        const t = this.elements,
                            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                            i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                        return Math.sqrt(Math.max(e, n, i));
                    }
                    makeTranslation(t, e, n) {
                        return (
                            this.set(
                                1,
                                0,
                                0,
                                t,
                                0,
                                1,
                                0,
                                e,
                                0,
                                0,
                                1,
                                n,
                                0,
                                0,
                                0,
                                1,
                            ),
                            this
                        );
                    }
                    makeRotationX(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return (
                            this.set(
                                1,
                                0,
                                0,
                                0,
                                0,
                                e,
                                -n,
                                0,
                                0,
                                n,
                                e,
                                0,
                                0,
                                0,
                                0,
                                1,
                            ),
                            this
                        );
                    }
                    makeRotationY(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return (
                            this.set(
                                e,
                                0,
                                n,
                                0,
                                0,
                                1,
                                0,
                                0,
                                -n,
                                0,
                                e,
                                0,
                                0,
                                0,
                                0,
                                1,
                            ),
                            this
                        );
                    }
                    makeRotationZ(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return (
                            this.set(
                                e,
                                -n,
                                0,
                                0,
                                n,
                                e,
                                0,
                                0,
                                0,
                                0,
                                1,
                                0,
                                0,
                                0,
                                0,
                                1,
                            ),
                            this
                        );
                    }
                    makeRotationAxis(t, e) {
                        const n = Math.cos(e),
                            i = Math.sin(e),
                            r = 1 - n,
                            a = t.x,
                            s = t.y,
                            o = t.z,
                            l = r * a,
                            c = r * s;
                        return (
                            this.set(
                                l * a + n,
                                l * s - i * o,
                                l * o + i * s,
                                0,
                                l * s + i * o,
                                c * s + n,
                                c * o - i * a,
                                0,
                                l * o - i * s,
                                c * o + i * a,
                                r * o * o + n,
                                0,
                                0,
                                0,
                                0,
                                1,
                            ),
                            this
                        );
                    }
                    makeScale(t, e, n) {
                        return (
                            this.set(
                                t,
                                0,
                                0,
                                0,
                                0,
                                e,
                                0,
                                0,
                                0,
                                0,
                                n,
                                0,
                                0,
                                0,
                                0,
                                1,
                            ),
                            this
                        );
                    }
                    makeShear(t, e, n, i, r, a) {
                        return (
                            this.set(
                                1,
                                n,
                                r,
                                0,
                                t,
                                1,
                                a,
                                0,
                                e,
                                i,
                                1,
                                0,
                                0,
                                0,
                                0,
                                1,
                            ),
                            this
                        );
                    }
                    compose(t, e, n) {
                        const i = this.elements,
                            r = e._x,
                            a = e._y,
                            s = e._z,
                            o = e._w,
                            l = r + r,
                            c = a + a,
                            h = s + s,
                            u = r * l,
                            d = r * c,
                            p = r * h,
                            f = a * c,
                            m = a * h,
                            g = s * h,
                            v = o * l,
                            x = o * c,
                            b = o * h,
                            y = n.x,
                            S = n.y,
                            M = n.z;
                        return (
                            (i[0] = (1 - (f + g)) * y),
                            (i[1] = (d + b) * y),
                            (i[2] = (p - x) * y),
                            (i[3] = 0),
                            (i[4] = (d - b) * S),
                            (i[5] = (1 - (u + g)) * S),
                            (i[6] = (m + v) * S),
                            (i[7] = 0),
                            (i[8] = (p + x) * M),
                            (i[9] = (m - v) * M),
                            (i[10] = (1 - (u + f)) * M),
                            (i[11] = 0),
                            (i[12] = t.x),
                            (i[13] = t.y),
                            (i[14] = t.z),
                            (i[15] = 1),
                            this
                        );
                    }
                    decompose(t, e, n) {
                        const i = this.elements;
                        let r = Qt.set(i[0], i[1], i[2]).length();
                        const a = Qt.set(i[4], i[5], i[6]).length(),
                            s = Qt.set(i[8], i[9], i[10]).length();
                        this.determinant() < 0 && (r = -r),
                            (t.x = i[12]),
                            (t.y = i[13]),
                            (t.z = i[14]),
                            $t.copy(this);
                        const o = 1 / r,
                            l = 1 / a,
                            c = 1 / s;
                        return (
                            ($t.elements[0] *= o),
                            ($t.elements[1] *= o),
                            ($t.elements[2] *= o),
                            ($t.elements[4] *= l),
                            ($t.elements[5] *= l),
                            ($t.elements[6] *= l),
                            ($t.elements[8] *= c),
                            ($t.elements[9] *= c),
                            ($t.elements[10] *= c),
                            e.setFromRotationMatrix($t),
                            (n.x = r),
                            (n.y = a),
                            (n.z = s),
                            this
                        );
                    }
                    makePerspective(t, e, n, i, r, a) {
                        const s = this.elements,
                            o = (2 * r) / (e - t),
                            l = (2 * r) / (n - i),
                            c = (e + t) / (e - t),
                            h = (n + i) / (n - i),
                            u = -(a + r) / (a - r),
                            d = (-2 * a * r) / (a - r);
                        return (
                            (s[0] = o),
                            (s[4] = 0),
                            (s[8] = c),
                            (s[12] = 0),
                            (s[1] = 0),
                            (s[5] = l),
                            (s[9] = h),
                            (s[13] = 0),
                            (s[2] = 0),
                            (s[6] = 0),
                            (s[10] = u),
                            (s[14] = d),
                            (s[3] = 0),
                            (s[7] = 0),
                            (s[11] = -1),
                            (s[15] = 0),
                            this
                        );
                    }
                    makeOrthographic(t, e, n, i, r, a) {
                        const s = this.elements,
                            o = 1 / (e - t),
                            l = 1 / (n - i),
                            c = 1 / (a - r),
                            h = (e + t) * o,
                            u = (n + i) * l,
                            d = (a + r) * c;
                        return (
                            (s[0] = 2 * o),
                            (s[4] = 0),
                            (s[8] = 0),
                            (s[12] = -h),
                            (s[1] = 0),
                            (s[5] = 2 * l),
                            (s[9] = 0),
                            (s[13] = -u),
                            (s[2] = 0),
                            (s[6] = 0),
                            (s[10] = -2 * c),
                            (s[14] = -d),
                            (s[3] = 0),
                            (s[7] = 0),
                            (s[11] = 0),
                            (s[15] = 1),
                            this
                        );
                    }
                    equals(t) {
                        const e = this.elements,
                            n = t.elements;
                        for (let t = 0; t < 16; t++)
                            if (e[t] !== n[t]) return !1;
                        return !0;
                    }
                    fromArray(t, e = 0) {
                        for (let n = 0; n < 16; n++)
                            this.elements[n] = t[n + e];
                        return this;
                    }
                    toArray(t = [], e = 0) {
                        const n = this.elements;
                        return (
                            (t[e] = n[0]),
                            (t[e + 1] = n[1]),
                            (t[e + 2] = n[2]),
                            (t[e + 3] = n[3]),
                            (t[e + 4] = n[4]),
                            (t[e + 5] = n[5]),
                            (t[e + 6] = n[6]),
                            (t[e + 7] = n[7]),
                            (t[e + 8] = n[8]),
                            (t[e + 9] = n[9]),
                            (t[e + 10] = n[10]),
                            (t[e + 11] = n[11]),
                            (t[e + 12] = n[12]),
                            (t[e + 13] = n[13]),
                            (t[e + 14] = n[14]),
                            (t[e + 15] = n[15]),
                            t
                        );
                    }
                }
                const Qt = new St(),
                    $t = new Xt(),
                    te = new St(0, 0, 0),
                    ee = new St(1, 1, 1),
                    ne = new St(),
                    ie = new St(),
                    re = new St(),
                    ae = new Xt(),
                    se = new yt();
                class oe {
                    constructor(t = 0, e = 0, n = 0, i = oe.DefaultOrder) {
                        (this.isEuler = !0),
                            (this._x = t),
                            (this._y = e),
                            (this._z = n),
                            (this._order = i);
                    }
                    get x() {
                        return this._x;
                    }
                    set x(t) {
                        (this._x = t), this._onChangeCallback();
                    }
                    get y() {
                        return this._y;
                    }
                    set y(t) {
                        (this._y = t), this._onChangeCallback();
                    }
                    get z() {
                        return this._z;
                    }
                    set z(t) {
                        (this._z = t), this._onChangeCallback();
                    }
                    get order() {
                        return this._order;
                    }
                    set order(t) {
                        (this._order = t), this._onChangeCallback();
                    }
                    set(t, e, n, i = this._order) {
                        return (
                            (this._x = t),
                            (this._y = e),
                            (this._z = n),
                            (this._order = i),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor(
                            this._x,
                            this._y,
                            this._z,
                            this._order,
                        );
                    }
                    copy(t) {
                        return (
                            (this._x = t._x),
                            (this._y = t._y),
                            (this._z = t._z),
                            (this._order = t._order),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    setFromRotationMatrix(t, e = this._order, n = !0) {
                        const i = t.elements,
                            r = i[0],
                            a = i[4],
                            s = i[8],
                            o = i[1],
                            l = i[5],
                            c = i[9],
                            h = i[2],
                            u = i[6],
                            d = i[10];
                        switch (e) {
                            case "XYZ":
                                (this._y = Math.asin(F(s, -1, 1))),
                                    Math.abs(s) < 0.9999999
                                        ? ((this._x = Math.atan2(-c, d)),
                                          (this._z = Math.atan2(-a, r)))
                                        : ((this._x = Math.atan2(u, l)),
                                          (this._z = 0));
                                break;
                            case "YXZ":
                                (this._x = Math.asin(-F(c, -1, 1))),
                                    Math.abs(c) < 0.9999999
                                        ? ((this._y = Math.atan2(s, d)),
                                          (this._z = Math.atan2(o, l)))
                                        : ((this._y = Math.atan2(-h, r)),
                                          (this._z = 0));
                                break;
                            case "ZXY":
                                (this._x = Math.asin(F(u, -1, 1))),
                                    Math.abs(u) < 0.9999999
                                        ? ((this._y = Math.atan2(-h, d)),
                                          (this._z = Math.atan2(-a, l)))
                                        : ((this._y = 0),
                                          (this._z = Math.atan2(o, r)));
                                break;
                            case "ZYX":
                                (this._y = Math.asin(-F(h, -1, 1))),
                                    Math.abs(h) < 0.9999999
                                        ? ((this._x = Math.atan2(u, d)),
                                          (this._z = Math.atan2(o, r)))
                                        : ((this._x = 0),
                                          (this._z = Math.atan2(-a, l)));
                                break;
                            case "YZX":
                                (this._z = Math.asin(F(o, -1, 1))),
                                    Math.abs(o) < 0.9999999
                                        ? ((this._x = Math.atan2(-c, l)),
                                          (this._y = Math.atan2(-h, r)))
                                        : ((this._x = 0),
                                          (this._y = Math.atan2(s, d)));
                                break;
                            case "XZY":
                                (this._z = Math.asin(-F(a, -1, 1))),
                                    Math.abs(a) < 0.9999999
                                        ? ((this._x = Math.atan2(u, l)),
                                          (this._y = Math.atan2(s, r)))
                                        : ((this._x = Math.atan2(-c, d)),
                                          (this._y = 0));
                                break;
                            default:
                                console.warn(
                                    "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                                        e,
                                );
                        }
                        return (
                            (this._order = e),
                            !0 === n && this._onChangeCallback(),
                            this
                        );
                    }
                    setFromQuaternion(t, e, n) {
                        return (
                            ae.makeRotationFromQuaternion(t),
                            this.setFromRotationMatrix(ae, e, n)
                        );
                    }
                    setFromVector3(t, e = this._order) {
                        return this.set(t.x, t.y, t.z, e);
                    }
                    reorder(t) {
                        return (
                            se.setFromEuler(this), this.setFromQuaternion(se, t)
                        );
                    }
                    equals(t) {
                        return (
                            t._x === this._x &&
                            t._y === this._y &&
                            t._z === this._z &&
                            t._order === this._order
                        );
                    }
                    fromArray(t) {
                        return (
                            (this._x = t[0]),
                            (this._y = t[1]),
                            (this._z = t[2]),
                            void 0 !== t[3] && (this._order = t[3]),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    toArray(t = [], e = 0) {
                        return (
                            (t[e] = this._x),
                            (t[e + 1] = this._y),
                            (t[e + 2] = this._z),
                            (t[e + 3] = this._order),
                            t
                        );
                    }
                    _onChange(t) {
                        return (this._onChangeCallback = t), this;
                    }
                    _onChangeCallback() {}
                    *[Symbol.iterator]() {
                        yield this._x,
                            yield this._y,
                            yield this._z,
                            yield this._order;
                    }
                    toVector3() {
                        console.error(
                            "THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead",
                        );
                    }
                }
                (oe.DefaultOrder = "XYZ"),
                    (oe.RotationOrders = [
                        "XYZ",
                        "YZX",
                        "ZXY",
                        "XZY",
                        "YXZ",
                        "ZYX",
                    ]);
                class le {
                    constructor() {
                        this.mask = 1;
                    }
                    set(t) {
                        this.mask = ((1 << t) | 0) >>> 0;
                    }
                    enable(t) {
                        this.mask |= (1 << t) | 0;
                    }
                    enableAll() {
                        this.mask = -1;
                    }
                    toggle(t) {
                        this.mask ^= (1 << t) | 0;
                    }
                    disable(t) {
                        this.mask &= ~((1 << t) | 0);
                    }
                    disableAll() {
                        this.mask = 0;
                    }
                    test(t) {
                        return 0 != (this.mask & t.mask);
                    }
                    isEnabled(t) {
                        return 0 != (this.mask & ((1 << t) | 0));
                    }
                }
                let ce = 0;
                const he = new St(),
                    ue = new yt(),
                    de = new Xt(),
                    pe = new St(),
                    fe = new St(),
                    me = new St(),
                    ge = new yt(),
                    ve = new St(1, 0, 0),
                    xe = new St(0, 1, 0),
                    be = new St(0, 0, 1),
                    ye = { type: "added" },
                    Se = { type: "removed" };
                class Me extends V {
                    constructor() {
                        super(),
                            (this.isObject3D = !0),
                            Object.defineProperty(this, "id", { value: ce++ }),
                            (this.uuid = H()),
                            (this.name = ""),
                            (this.type = "Object3D"),
                            (this.parent = null),
                            (this.children = []),
                            (this.up = Me.DefaultUp.clone());
                        const t = new St(),
                            e = new oe(),
                            n = new yt(),
                            i = new St(1, 1, 1);
                        e._onChange(function () {
                            n.setFromEuler(e, !1);
                        }),
                            n._onChange(function () {
                                e.setFromQuaternion(n, void 0, !1);
                            }),
                            Object.defineProperties(this, {
                                position: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: t,
                                },
                                rotation: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: e,
                                },
                                quaternion: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: n,
                                },
                                scale: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: i,
                                },
                                modelViewMatrix: { value: new Xt() },
                                normalMatrix: { value: new J() },
                            }),
                            (this.matrix = new Xt()),
                            (this.matrixWorld = new Xt()),
                            (this.matrixAutoUpdate =
                                Me.DefaultMatrixAutoUpdate),
                            (this.matrixWorldNeedsUpdate = !1),
                            (this.matrixWorldAutoUpdate =
                                Me.DefaultMatrixWorldAutoUpdate),
                            (this.layers = new le()),
                            (this.visible = !0),
                            (this.castShadow = !1),
                            (this.receiveShadow = !1),
                            (this.frustumCulled = !0),
                            (this.renderOrder = 0),
                            (this.animations = []),
                            (this.userData = {});
                    }
                    onBeforeRender() {}
                    onAfterRender() {}
                    applyMatrix4(t) {
                        this.matrixAutoUpdate && this.updateMatrix(),
                            this.matrix.premultiply(t),
                            this.matrix.decompose(
                                this.position,
                                this.quaternion,
                                this.scale,
                            );
                    }
                    applyQuaternion(t) {
                        return this.quaternion.premultiply(t), this;
                    }
                    setRotationFromAxisAngle(t, e) {
                        this.quaternion.setFromAxisAngle(t, e);
                    }
                    setRotationFromEuler(t) {
                        this.quaternion.setFromEuler(t, !0);
                    }
                    setRotationFromMatrix(t) {
                        this.quaternion.setFromRotationMatrix(t);
                    }
                    setRotationFromQuaternion(t) {
                        this.quaternion.copy(t);
                    }
                    rotateOnAxis(t, e) {
                        return (
                            ue.setFromAxisAngle(t, e),
                            this.quaternion.multiply(ue),
                            this
                        );
                    }
                    rotateOnWorldAxis(t, e) {
                        return (
                            ue.setFromAxisAngle(t, e),
                            this.quaternion.premultiply(ue),
                            this
                        );
                    }
                    rotateX(t) {
                        return this.rotateOnAxis(ve, t);
                    }
                    rotateY(t) {
                        return this.rotateOnAxis(xe, t);
                    }
                    rotateZ(t) {
                        return this.rotateOnAxis(be, t);
                    }
                    translateOnAxis(t, e) {
                        return (
                            he.copy(t).applyQuaternion(this.quaternion),
                            this.position.add(he.multiplyScalar(e)),
                            this
                        );
                    }
                    translateX(t) {
                        return this.translateOnAxis(ve, t);
                    }
                    translateY(t) {
                        return this.translateOnAxis(xe, t);
                    }
                    translateZ(t) {
                        return this.translateOnAxis(be, t);
                    }
                    localToWorld(t) {
                        return (
                            this.updateWorldMatrix(!0, !1),
                            t.applyMatrix4(this.matrixWorld)
                        );
                    }
                    worldToLocal(t) {
                        return (
                            this.updateWorldMatrix(!0, !1),
                            t.applyMatrix4(de.copy(this.matrixWorld).invert())
                        );
                    }
                    lookAt(t, e, n) {
                        t.isVector3 ? pe.copy(t) : pe.set(t, e, n);
                        const i = this.parent;
                        this.updateWorldMatrix(!0, !1),
                            fe.setFromMatrixPosition(this.matrixWorld),
                            this.isCamera || this.isLight
                                ? de.lookAt(fe, pe, this.up)
                                : de.lookAt(pe, fe, this.up),
                            this.quaternion.setFromRotationMatrix(de),
                            i &&
                                (de.extractRotation(i.matrixWorld),
                                ue.setFromRotationMatrix(de),
                                this.quaternion.premultiply(ue.invert()));
                    }
                    add(t) {
                        if (arguments.length > 1) {
                            for (let t = 0; t < arguments.length; t++)
                                this.add(arguments[t]);
                            return this;
                        }
                        return t === this
                            ? (console.error(
                                  "THREE.Object3D.add: object can't be added as a child of itself.",
                                  t,
                              ),
                              this)
                            : (t && t.isObject3D
                                  ? (null !== t.parent && t.parent.remove(t),
                                    (t.parent = this),
                                    this.children.push(t),
                                    t.dispatchEvent(ye))
                                  : console.error(
                                        "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                                        t,
                                    ),
                              this);
                    }
                    remove(t) {
                        if (arguments.length > 1) {
                            for (let t = 0; t < arguments.length; t++)
                                this.remove(arguments[t]);
                            return this;
                        }
                        const e = this.children.indexOf(t);
                        return (
                            -1 !== e &&
                                ((t.parent = null),
                                this.children.splice(e, 1),
                                t.dispatchEvent(Se)),
                            this
                        );
                    }
                    removeFromParent() {
                        const t = this.parent;
                        return null !== t && t.remove(this), this;
                    }
                    clear() {
                        for (let t = 0; t < this.children.length; t++) {
                            const e = this.children[t];
                            (e.parent = null), e.dispatchEvent(Se);
                        }
                        return (this.children.length = 0), this;
                    }
                    attach(t) {
                        return (
                            this.updateWorldMatrix(!0, !1),
                            de.copy(this.matrixWorld).invert(),
                            null !== t.parent &&
                                (t.parent.updateWorldMatrix(!0, !1),
                                de.multiply(t.parent.matrixWorld)),
                            t.applyMatrix4(de),
                            this.add(t),
                            t.updateWorldMatrix(!1, !0),
                            this
                        );
                    }
                    getObjectById(t) {
                        return this.getObjectByProperty("id", t);
                    }
                    getObjectByName(t) {
                        return this.getObjectByProperty("name", t);
                    }
                    getObjectByProperty(t, e) {
                        if (this[t] === e) return this;
                        for (let n = 0, i = this.children.length; n < i; n++) {
                            const i = this.children[n].getObjectByProperty(
                                t,
                                e,
                            );
                            if (void 0 !== i) return i;
                        }
                    }
                    getObjectsByProperty(t, e) {
                        let n = [];
                        this[t] === e && n.push(this);
                        for (let i = 0, r = this.children.length; i < r; i++) {
                            const r = this.children[i].getObjectsByProperty(
                                t,
                                e,
                            );
                            r.length > 0 && (n = n.concat(r));
                        }
                        return n;
                    }
                    getWorldPosition(t) {
                        return (
                            this.updateWorldMatrix(!0, !1),
                            t.setFromMatrixPosition(this.matrixWorld)
                        );
                    }
                    getWorldQuaternion(t) {
                        return (
                            this.updateWorldMatrix(!0, !1),
                            this.matrixWorld.decompose(fe, t, me),
                            t
                        );
                    }
                    getWorldScale(t) {
                        return (
                            this.updateWorldMatrix(!0, !1),
                            this.matrixWorld.decompose(fe, ge, t),
                            t
                        );
                    }
                    getWorldDirection(t) {
                        this.updateWorldMatrix(!0, !1);
                        const e = this.matrixWorld.elements;
                        return t.set(e[8], e[9], e[10]).normalize();
                    }
                    raycast() {}
                    traverse(t) {
                        t(this);
                        const e = this.children;
                        for (let n = 0, i = e.length; n < i; n++)
                            e[n].traverse(t);
                    }
                    traverseVisible(t) {
                        if (!1 === this.visible) return;
                        t(this);
                        const e = this.children;
                        for (let n = 0, i = e.length; n < i; n++)
                            e[n].traverseVisible(t);
                    }
                    traverseAncestors(t) {
                        const e = this.parent;
                        null !== e && (t(e), e.traverseAncestors(t));
                    }
                    updateMatrix() {
                        this.matrix.compose(
                            this.position,
                            this.quaternion,
                            this.scale,
                        ),
                            (this.matrixWorldNeedsUpdate = !0);
                    }
                    updateMatrixWorld(t) {
                        this.matrixAutoUpdate && this.updateMatrix(),
                            (this.matrixWorldNeedsUpdate || t) &&
                                (null === this.parent
                                    ? this.matrixWorld.copy(this.matrix)
                                    : this.matrixWorld.multiplyMatrices(
                                          this.parent.matrixWorld,
                                          this.matrix,
                                      ),
                                (this.matrixWorldNeedsUpdate = !1),
                                (t = !0));
                        const e = this.children;
                        for (let n = 0, i = e.length; n < i; n++) {
                            const i = e[n];
                            (!0 !== i.matrixWorldAutoUpdate && !0 !== t) ||
                                i.updateMatrixWorld(t);
                        }
                    }
                    updateWorldMatrix(t, e) {
                        const n = this.parent;
                        if (
                            (!0 === t &&
                                null !== n &&
                                !0 === n.matrixWorldAutoUpdate &&
                                n.updateWorldMatrix(!0, !1),
                            this.matrixAutoUpdate && this.updateMatrix(),
                            null === this.parent
                                ? this.matrixWorld.copy(this.matrix)
                                : this.matrixWorld.multiplyMatrices(
                                      this.parent.matrixWorld,
                                      this.matrix,
                                  ),
                            !0 === e)
                        ) {
                            const t = this.children;
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                !0 === n.matrixWorldAutoUpdate &&
                                    n.updateWorldMatrix(!1, !0);
                            }
                        }
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t,
                            n = {};
                        e &&
                            ((t = {
                                geometries: {},
                                materials: {},
                                textures: {},
                                images: {},
                                shapes: {},
                                skeletons: {},
                                animations: {},
                                nodes: {},
                            }),
                            (n.metadata = {
                                version: 4.5,
                                type: "Object",
                                generator: "Object3D.toJSON",
                            }));
                        const i = {};
                        function r(e, n) {
                            return (
                                void 0 === e[n.uuid] &&
                                    (e[n.uuid] = n.toJSON(t)),
                                n.uuid
                            );
                        }
                        if (
                            ((i.uuid = this.uuid),
                            (i.type = this.type),
                            "" !== this.name && (i.name = this.name),
                            !0 === this.castShadow && (i.castShadow = !0),
                            !0 === this.receiveShadow && (i.receiveShadow = !0),
                            !1 === this.visible && (i.visible = !1),
                            !1 === this.frustumCulled && (i.frustumCulled = !1),
                            0 !== this.renderOrder &&
                                (i.renderOrder = this.renderOrder),
                            Object.keys(this.userData).length > 0 &&
                                (i.userData = this.userData),
                            (i.layers = this.layers.mask),
                            (i.matrix = this.matrix.toArray()),
                            !1 === this.matrixAutoUpdate &&
                                (i.matrixAutoUpdate = !1),
                            this.isInstancedMesh &&
                                ((i.type = "InstancedMesh"),
                                (i.count = this.count),
                                (i.instanceMatrix =
                                    this.instanceMatrix.toJSON()),
                                null !== this.instanceColor &&
                                    (i.instanceColor =
                                        this.instanceColor.toJSON())),
                            this.isScene)
                        )
                            this.background &&
                                (this.background.isColor
                                    ? (i.background = this.background.toJSON())
                                    : this.background.isTexture &&
                                      (i.background =
                                          this.background.toJSON(t).uuid)),
                                this.environment &&
                                    this.environment.isTexture &&
                                    !0 !==
                                        this.environment
                                            .isRenderTargetTexture &&
                                    (i.environment =
                                        this.environment.toJSON(t).uuid);
                        else if (this.isMesh || this.isLine || this.isPoints) {
                            i.geometry = r(t.geometries, this.geometry);
                            const e = this.geometry.parameters;
                            if (void 0 !== e && void 0 !== e.shapes) {
                                const n = e.shapes;
                                if (Array.isArray(n))
                                    for (let e = 0, i = n.length; e < i; e++) {
                                        const i = n[e];
                                        r(t.shapes, i);
                                    }
                                else r(t.shapes, n);
                            }
                        }
                        if (
                            (this.isSkinnedMesh &&
                                ((i.bindMode = this.bindMode),
                                (i.bindMatrix = this.bindMatrix.toArray()),
                                void 0 !== this.skeleton &&
                                    (r(t.skeletons, this.skeleton),
                                    (i.skeleton = this.skeleton.uuid))),
                            void 0 !== this.material)
                        )
                            if (Array.isArray(this.material)) {
                                const e = [];
                                for (
                                    let n = 0, i = this.material.length;
                                    n < i;
                                    n++
                                )
                                    e.push(r(t.materials, this.material[n]));
                                i.material = e;
                            } else i.material = r(t.materials, this.material);
                        if (this.children.length > 0) {
                            i.children = [];
                            for (let e = 0; e < this.children.length; e++)
                                i.children.push(
                                    this.children[e].toJSON(t).object,
                                );
                        }
                        if (this.animations.length > 0) {
                            i.animations = [];
                            for (let e = 0; e < this.animations.length; e++) {
                                const n = this.animations[e];
                                i.animations.push(r(t.animations, n));
                            }
                        }
                        if (e) {
                            const e = a(t.geometries),
                                i = a(t.materials),
                                r = a(t.textures),
                                s = a(t.images),
                                o = a(t.shapes),
                                l = a(t.skeletons),
                                c = a(t.animations),
                                h = a(t.nodes);
                            e.length > 0 && (n.geometries = e),
                                i.length > 0 && (n.materials = i),
                                r.length > 0 && (n.textures = r),
                                s.length > 0 && (n.images = s),
                                o.length > 0 && (n.shapes = o),
                                l.length > 0 && (n.skeletons = l),
                                c.length > 0 && (n.animations = c),
                                h.length > 0 && (n.nodes = h);
                        }
                        return (n.object = i), n;
                        function a(t) {
                            const e = [];
                            for (const n in t) {
                                const i = t[n];
                                delete i.metadata, e.push(i);
                            }
                            return e;
                        }
                    }
                    clone(t) {
                        return new this.constructor().copy(this, t);
                    }
                    copy(t, e = !0) {
                        if (
                            ((this.name = t.name),
                            this.up.copy(t.up),
                            this.position.copy(t.position),
                            (this.rotation.order = t.rotation.order),
                            this.quaternion.copy(t.quaternion),
                            this.scale.copy(t.scale),
                            this.matrix.copy(t.matrix),
                            this.matrixWorld.copy(t.matrixWorld),
                            (this.matrixAutoUpdate = t.matrixAutoUpdate),
                            (this.matrixWorldNeedsUpdate =
                                t.matrixWorldNeedsUpdate),
                            (this.matrixWorldAutoUpdate =
                                t.matrixWorldAutoUpdate),
                            (this.layers.mask = t.layers.mask),
                            (this.visible = t.visible),
                            (this.castShadow = t.castShadow),
                            (this.receiveShadow = t.receiveShadow),
                            (this.frustumCulled = t.frustumCulled),
                            (this.renderOrder = t.renderOrder),
                            (this.userData = JSON.parse(
                                JSON.stringify(t.userData),
                            )),
                            !0 === e)
                        )
                            for (let e = 0; e < t.children.length; e++) {
                                const n = t.children[e];
                                this.add(n.clone());
                            }
                        return this;
                    }
                }
                (Me.DefaultUp = new St(0, 1, 0)),
                    (Me.DefaultMatrixAutoUpdate = !0),
                    (Me.DefaultMatrixWorldAutoUpdate = !0);
                const Ae = new St(),
                    _e = new St(),
                    we = new St(),
                    Te = new St(),
                    Ee = new St(),
                    Re = new St(),
                    ke = new St(),
                    Ce = new St(),
                    Le = new St(),
                    Ie = new St();
                class Oe {
                    constructor(t = new St(), e = new St(), n = new St()) {
                        (this.a = t), (this.b = e), (this.c = n);
                    }
                    static getNormal(t, e, n, i) {
                        i.subVectors(n, e), Ae.subVectors(t, e), i.cross(Ae);
                        const r = i.lengthSq();
                        return r > 0
                            ? i.multiplyScalar(1 / Math.sqrt(r))
                            : i.set(0, 0, 0);
                    }
                    static getBarycoord(t, e, n, i, r) {
                        Ae.subVectors(i, e),
                            _e.subVectors(n, e),
                            we.subVectors(t, e);
                        const a = Ae.dot(Ae),
                            s = Ae.dot(_e),
                            o = Ae.dot(we),
                            l = _e.dot(_e),
                            c = _e.dot(we),
                            h = a * l - s * s;
                        if (0 === h) return r.set(-2, -1, -1);
                        const u = 1 / h,
                            d = (l * o - s * c) * u,
                            p = (a * c - s * o) * u;
                        return r.set(1 - d - p, p, d);
                    }
                    static containsPoint(t, e, n, i) {
                        return (
                            this.getBarycoord(t, e, n, i, Te),
                            Te.x >= 0 && Te.y >= 0 && Te.x + Te.y <= 1
                        );
                    }
                    static getUV(t, e, n, i, r, a, s, o) {
                        return (
                            this.getBarycoord(t, e, n, i, Te),
                            o.set(0, 0),
                            o.addScaledVector(r, Te.x),
                            o.addScaledVector(a, Te.y),
                            o.addScaledVector(s, Te.z),
                            o
                        );
                    }
                    static isFrontFacing(t, e, n, i) {
                        return (
                            Ae.subVectors(n, e),
                            _e.subVectors(t, e),
                            Ae.cross(_e).dot(i) < 0
                        );
                    }
                    set(t, e, n) {
                        return (
                            this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                        );
                    }
                    setFromPointsAndIndices(t, e, n, i) {
                        return (
                            this.a.copy(t[e]),
                            this.b.copy(t[n]),
                            this.c.copy(t[i]),
                            this
                        );
                    }
                    setFromAttributeAndIndices(t, e, n, i) {
                        return (
                            this.a.fromBufferAttribute(t, e),
                            this.b.fromBufferAttribute(t, n),
                            this.c.fromBufferAttribute(t, i),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(t) {
                        return (
                            this.a.copy(t.a),
                            this.b.copy(t.b),
                            this.c.copy(t.c),
                            this
                        );
                    }
                    getArea() {
                        return (
                            Ae.subVectors(this.c, this.b),
                            _e.subVectors(this.a, this.b),
                            0.5 * Ae.cross(_e).length()
                        );
                    }
                    getMidpoint(t) {
                        return t
                            .addVectors(this.a, this.b)
                            .add(this.c)
                            .multiplyScalar(1 / 3);
                    }
                    getNormal(t) {
                        return Oe.getNormal(this.a, this.b, this.c, t);
                    }
                    getPlane(t) {
                        return t.setFromCoplanarPoints(this.a, this.b, this.c);
                    }
                    getBarycoord(t, e) {
                        return Oe.getBarycoord(t, this.a, this.b, this.c, e);
                    }
                    getUV(t, e, n, i, r) {
                        return Oe.getUV(t, this.a, this.b, this.c, e, n, i, r);
                    }
                    containsPoint(t) {
                        return Oe.containsPoint(t, this.a, this.b, this.c);
                    }
                    isFrontFacing(t) {
                        return Oe.isFrontFacing(this.a, this.b, this.c, t);
                    }
                    intersectsBox(t) {
                        return t.intersectsTriangle(this);
                    }
                    closestPointToPoint(t, e) {
                        const n = this.a,
                            i = this.b,
                            r = this.c;
                        let a, s;
                        Ee.subVectors(i, n),
                            Re.subVectors(r, n),
                            Ce.subVectors(t, n);
                        const o = Ee.dot(Ce),
                            l = Re.dot(Ce);
                        if (o <= 0 && l <= 0) return e.copy(n);
                        Le.subVectors(t, i);
                        const c = Ee.dot(Le),
                            h = Re.dot(Le);
                        if (c >= 0 && h <= c) return e.copy(i);
                        const u = o * h - c * l;
                        if (u <= 0 && o >= 0 && c <= 0)
                            return (
                                (a = o / (o - c)),
                                e.copy(n).addScaledVector(Ee, a)
                            );
                        Ie.subVectors(t, r);
                        const d = Ee.dot(Ie),
                            p = Re.dot(Ie);
                        if (p >= 0 && d <= p) return e.copy(r);
                        const f = d * l - o * p;
                        if (f <= 0 && l >= 0 && p <= 0)
                            return (
                                (s = l / (l - p)),
                                e.copy(n).addScaledVector(Re, s)
                            );
                        const m = c * p - d * h;
                        if (m <= 0 && h - c >= 0 && d - p >= 0)
                            return (
                                ke.subVectors(r, i),
                                (s = (h - c) / (h - c + (d - p))),
                                e.copy(i).addScaledVector(ke, s)
                            );
                        const g = 1 / (m + f + u);
                        return (
                            (a = f * g),
                            (s = u * g),
                            e
                                .copy(n)
                                .addScaledVector(Ee, a)
                                .addScaledVector(Re, s)
                        );
                    }
                    equals(t) {
                        return (
                            t.a.equals(this.a) &&
                            t.b.equals(this.b) &&
                            t.c.equals(this.c)
                        );
                    }
                }
                let De = 0;
                class Pe extends V {
                    constructor() {
                        super(),
                            (this.isMaterial = !0),
                            Object.defineProperty(this, "id", { value: De++ }),
                            (this.uuid = H()),
                            (this.name = ""),
                            (this.type = "Material"),
                            (this.blending = 1),
                            (this.side = 0),
                            (this.vertexColors = !1),
                            (this.opacity = 1),
                            (this.transparent = !1),
                            (this.blendSrc = 204),
                            (this.blendDst = 205),
                            (this.blendEquation = e),
                            (this.blendSrcAlpha = null),
                            (this.blendDstAlpha = null),
                            (this.blendEquationAlpha = null),
                            (this.depthFunc = 3),
                            (this.depthTest = !0),
                            (this.depthWrite = !0),
                            (this.stencilWriteMask = 255),
                            (this.stencilFunc = 519),
                            (this.stencilRef = 0),
                            (this.stencilFuncMask = 255),
                            (this.stencilFail = D),
                            (this.stencilZFail = D),
                            (this.stencilZPass = D),
                            (this.stencilWrite = !1),
                            (this.clippingPlanes = null),
                            (this.clipIntersection = !1),
                            (this.clipShadows = !1),
                            (this.shadowSide = null),
                            (this.colorWrite = !0),
                            (this.precision = null),
                            (this.polygonOffset = !1),
                            (this.polygonOffsetFactor = 0),
                            (this.polygonOffsetUnits = 0),
                            (this.dithering = !1),
                            (this.alphaToCoverage = !1),
                            (this.premultipliedAlpha = !1),
                            (this.visible = !0),
                            (this.toneMapped = !0),
                            (this.userData = {}),
                            (this.version = 0),
                            (this._alphaTest = 0);
                    }
                    get alphaTest() {
                        return this._alphaTest;
                    }
                    set alphaTest(t) {
                        this._alphaTest > 0 != t > 0 && this.version++,
                            (this._alphaTest = t);
                    }
                    onBuild() {}
                    onBeforeRender() {}
                    onBeforeCompile() {}
                    customProgramCacheKey() {
                        return this.onBeforeCompile.toString();
                    }
                    setValues(t) {
                        if (void 0 !== t)
                            for (const e in t) {
                                const n = t[e];
                                if (void 0 === n) {
                                    console.warn(
                                        "THREE.Material: '" +
                                            e +
                                            "' parameter is undefined.",
                                    );
                                    continue;
                                }
                                const i = this[e];
                                void 0 !== i
                                    ? i && i.isColor
                                        ? i.set(n)
                                        : i && i.isVector3 && n && n.isVector3
                                        ? i.copy(n)
                                        : (this[e] = n)
                                    : console.warn(
                                          "THREE." +
                                              this.type +
                                              ": '" +
                                              e +
                                              "' is not a property of this material.",
                                      );
                            }
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t;
                        e && (t = { textures: {}, images: {} });
                        const n = {
                            metadata: {
                                version: 4.5,
                                type: "Material",
                                generator: "Material.toJSON",
                            },
                        };
                        function i(t) {
                            const e = [];
                            for (const n in t) {
                                const i = t[n];
                                delete i.metadata, e.push(i);
                            }
                            return e;
                        }
                        if (
                            ((n.uuid = this.uuid),
                            (n.type = this.type),
                            "" !== this.name && (n.name = this.name),
                            this.color &&
                                this.color.isColor &&
                                (n.color = this.color.getHex()),
                            void 0 !== this.roughness &&
                                (n.roughness = this.roughness),
                            void 0 !== this.metalness &&
                                (n.metalness = this.metalness),
                            void 0 !== this.sheen && (n.sheen = this.sheen),
                            this.sheenColor &&
                                this.sheenColor.isColor &&
                                (n.sheenColor = this.sheenColor.getHex()),
                            void 0 !== this.sheenRoughness &&
                                (n.sheenRoughness = this.sheenRoughness),
                            this.emissive &&
                                this.emissive.isColor &&
                                (n.emissive = this.emissive.getHex()),
                            this.emissiveIntensity &&
                                1 !== this.emissiveIntensity &&
                                (n.emissiveIntensity = this.emissiveIntensity),
                            this.specular &&
                                this.specular.isColor &&
                                (n.specular = this.specular.getHex()),
                            void 0 !== this.specularIntensity &&
                                (n.specularIntensity = this.specularIntensity),
                            this.specularColor &&
                                this.specularColor.isColor &&
                                (n.specularColor = this.specularColor.getHex()),
                            void 0 !== this.shininess &&
                                (n.shininess = this.shininess),
                            void 0 !== this.clearcoat &&
                                (n.clearcoat = this.clearcoat),
                            void 0 !== this.clearcoatRoughness &&
                                (n.clearcoatRoughness =
                                    this.clearcoatRoughness),
                            this.clearcoatMap &&
                                this.clearcoatMap.isTexture &&
                                (n.clearcoatMap =
                                    this.clearcoatMap.toJSON(t).uuid),
                            this.clearcoatRoughnessMap &&
                                this.clearcoatRoughnessMap.isTexture &&
                                (n.clearcoatRoughnessMap =
                                    this.clearcoatRoughnessMap.toJSON(t).uuid),
                            this.clearcoatNormalMap &&
                                this.clearcoatNormalMap.isTexture &&
                                ((n.clearcoatNormalMap =
                                    this.clearcoatNormalMap.toJSON(t).uuid),
                                (n.clearcoatNormalScale =
                                    this.clearcoatNormalScale.toArray())),
                            void 0 !== this.iridescence &&
                                (n.iridescence = this.iridescence),
                            void 0 !== this.iridescenceIOR &&
                                (n.iridescenceIOR = this.iridescenceIOR),
                            void 0 !== this.iridescenceThicknessRange &&
                                (n.iridescenceThicknessRange =
                                    this.iridescenceThicknessRange),
                            this.iridescenceMap &&
                                this.iridescenceMap.isTexture &&
                                (n.iridescenceMap =
                                    this.iridescenceMap.toJSON(t).uuid),
                            this.iridescenceThicknessMap &&
                                this.iridescenceThicknessMap.isTexture &&
                                (n.iridescenceThicknessMap =
                                    this.iridescenceThicknessMap.toJSON(
                                        t,
                                    ).uuid),
                            this.map &&
                                this.map.isTexture &&
                                (n.map = this.map.toJSON(t).uuid),
                            this.matcap &&
                                this.matcap.isTexture &&
                                (n.matcap = this.matcap.toJSON(t).uuid),
                            this.alphaMap &&
                                this.alphaMap.isTexture &&
                                (n.alphaMap = this.alphaMap.toJSON(t).uuid),
                            this.lightMap &&
                                this.lightMap.isTexture &&
                                ((n.lightMap = this.lightMap.toJSON(t).uuid),
                                (n.lightMapIntensity = this.lightMapIntensity)),
                            this.aoMap &&
                                this.aoMap.isTexture &&
                                ((n.aoMap = this.aoMap.toJSON(t).uuid),
                                (n.aoMapIntensity = this.aoMapIntensity)),
                            this.bumpMap &&
                                this.bumpMap.isTexture &&
                                ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
                                (n.bumpScale = this.bumpScale)),
                            this.normalMap &&
                                this.normalMap.isTexture &&
                                ((n.normalMap = this.normalMap.toJSON(t).uuid),
                                (n.normalMapType = this.normalMapType),
                                (n.normalScale = this.normalScale.toArray())),
                            this.displacementMap &&
                                this.displacementMap.isTexture &&
                                ((n.displacementMap =
                                    this.displacementMap.toJSON(t).uuid),
                                (n.displacementScale = this.displacementScale),
                                (n.displacementBias = this.displacementBias)),
                            this.roughnessMap &&
                                this.roughnessMap.isTexture &&
                                (n.roughnessMap =
                                    this.roughnessMap.toJSON(t).uuid),
                            this.metalnessMap &&
                                this.metalnessMap.isTexture &&
                                (n.metalnessMap =
                                    this.metalnessMap.toJSON(t).uuid),
                            this.emissiveMap &&
                                this.emissiveMap.isTexture &&
                                (n.emissiveMap =
                                    this.emissiveMap.toJSON(t).uuid),
                            this.specularMap &&
                                this.specularMap.isTexture &&
                                (n.specularMap =
                                    this.specularMap.toJSON(t).uuid),
                            this.specularIntensityMap &&
                                this.specularIntensityMap.isTexture &&
                                (n.specularIntensityMap =
                                    this.specularIntensityMap.toJSON(t).uuid),
                            this.specularColorMap &&
                                this.specularColorMap.isTexture &&
                                (n.specularColorMap =
                                    this.specularColorMap.toJSON(t).uuid),
                            this.envMap &&
                                this.envMap.isTexture &&
                                ((n.envMap = this.envMap.toJSON(t).uuid),
                                void 0 !== this.combine &&
                                    (n.combine = this.combine)),
                            void 0 !== this.envMapIntensity &&
                                (n.envMapIntensity = this.envMapIntensity),
                            void 0 !== this.reflectivity &&
                                (n.reflectivity = this.reflectivity),
                            void 0 !== this.refractionRatio &&
                                (n.refractionRatio = this.refractionRatio),
                            this.gradientMap &&
                                this.gradientMap.isTexture &&
                                (n.gradientMap =
                                    this.gradientMap.toJSON(t).uuid),
                            void 0 !== this.transmission &&
                                (n.transmission = this.transmission),
                            this.transmissionMap &&
                                this.transmissionMap.isTexture &&
                                (n.transmissionMap =
                                    this.transmissionMap.toJSON(t).uuid),
                            void 0 !== this.thickness &&
                                (n.thickness = this.thickness),
                            this.thicknessMap &&
                                this.thicknessMap.isTexture &&
                                (n.thicknessMap =
                                    this.thicknessMap.toJSON(t).uuid),
                            void 0 !== this.attenuationDistance &&
                                this.attenuationDistance !== 1 / 0 &&
                                (n.attenuationDistance =
                                    this.attenuationDistance),
                            void 0 !== this.attenuationColor &&
                                (n.attenuationColor =
                                    this.attenuationColor.getHex()),
                            void 0 !== this.size && (n.size = this.size),
                            null !== this.shadowSide &&
                                (n.shadowSide = this.shadowSide),
                            void 0 !== this.sizeAttenuation &&
                                (n.sizeAttenuation = this.sizeAttenuation),
                            1 !== this.blending && (n.blending = this.blending),
                            0 !== this.side && (n.side = this.side),
                            this.vertexColors && (n.vertexColors = !0),
                            this.opacity < 1 && (n.opacity = this.opacity),
                            !0 === this.transparent &&
                                (n.transparent = this.transparent),
                            (n.depthFunc = this.depthFunc),
                            (n.depthTest = this.depthTest),
                            (n.depthWrite = this.depthWrite),
                            (n.colorWrite = this.colorWrite),
                            (n.stencilWrite = this.stencilWrite),
                            (n.stencilWriteMask = this.stencilWriteMask),
                            (n.stencilFunc = this.stencilFunc),
                            (n.stencilRef = this.stencilRef),
                            (n.stencilFuncMask = this.stencilFuncMask),
                            (n.stencilFail = this.stencilFail),
                            (n.stencilZFail = this.stencilZFail),
                            (n.stencilZPass = this.stencilZPass),
                            void 0 !== this.rotation &&
                                0 !== this.rotation &&
                                (n.rotation = this.rotation),
                            !0 === this.polygonOffset && (n.polygonOffset = !0),
                            0 !== this.polygonOffsetFactor &&
                                (n.polygonOffsetFactor =
                                    this.polygonOffsetFactor),
                            0 !== this.polygonOffsetUnits &&
                                (n.polygonOffsetUnits =
                                    this.polygonOffsetUnits),
                            void 0 !== this.linewidth &&
                                1 !== this.linewidth &&
                                (n.linewidth = this.linewidth),
                            void 0 !== this.dashSize &&
                                (n.dashSize = this.dashSize),
                            void 0 !== this.gapSize &&
                                (n.gapSize = this.gapSize),
                            void 0 !== this.scale && (n.scale = this.scale),
                            !0 === this.dithering && (n.dithering = !0),
                            this.alphaTest > 0 &&
                                (n.alphaTest = this.alphaTest),
                            !0 === this.alphaToCoverage &&
                                (n.alphaToCoverage = this.alphaToCoverage),
                            !0 === this.premultipliedAlpha &&
                                (n.premultipliedAlpha =
                                    this.premultipliedAlpha),
                            !0 === this.wireframe &&
                                (n.wireframe = this.wireframe),
                            this.wireframeLinewidth > 1 &&
                                (n.wireframeLinewidth =
                                    this.wireframeLinewidth),
                            "round" !== this.wireframeLinecap &&
                                (n.wireframeLinecap = this.wireframeLinecap),
                            "round" !== this.wireframeLinejoin &&
                                (n.wireframeLinejoin = this.wireframeLinejoin),
                            !0 === this.flatShading &&
                                (n.flatShading = this.flatShading),
                            !1 === this.visible && (n.visible = !1),
                            !1 === this.toneMapped && (n.toneMapped = !1),
                            !1 === this.fog && (n.fog = !1),
                            Object.keys(this.userData).length > 0 &&
                                (n.userData = this.userData),
                            e)
                        ) {
                            const e = i(t.textures),
                                r = i(t.images);
                            e.length > 0 && (n.textures = e),
                                r.length > 0 && (n.images = r);
                        }
                        return n;
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(t) {
                        (this.name = t.name),
                            (this.blending = t.blending),
                            (this.side = t.side),
                            (this.vertexColors = t.vertexColors),
                            (this.opacity = t.opacity),
                            (this.transparent = t.transparent),
                            (this.blendSrc = t.blendSrc),
                            (this.blendDst = t.blendDst),
                            (this.blendEquation = t.blendEquation),
                            (this.blendSrcAlpha = t.blendSrcAlpha),
                            (this.blendDstAlpha = t.blendDstAlpha),
                            (this.blendEquationAlpha = t.blendEquationAlpha),
                            (this.depthFunc = t.depthFunc),
                            (this.depthTest = t.depthTest),
                            (this.depthWrite = t.depthWrite),
                            (this.stencilWriteMask = t.stencilWriteMask),
                            (this.stencilFunc = t.stencilFunc),
                            (this.stencilRef = t.stencilRef),
                            (this.stencilFuncMask = t.stencilFuncMask),
                            (this.stencilFail = t.stencilFail),
                            (this.stencilZFail = t.stencilZFail),
                            (this.stencilZPass = t.stencilZPass),
                            (this.stencilWrite = t.stencilWrite);
                        const e = t.clippingPlanes;
                        let n = null;
                        if (null !== e) {
                            const t = e.length;
                            n = new Array(t);
                            for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
                        }
                        return (
                            (this.clippingPlanes = n),
                            (this.clipIntersection = t.clipIntersection),
                            (this.clipShadows = t.clipShadows),
                            (this.shadowSide = t.shadowSide),
                            (this.colorWrite = t.colorWrite),
                            (this.precision = t.precision),
                            (this.polygonOffset = t.polygonOffset),
                            (this.polygonOffsetFactor = t.polygonOffsetFactor),
                            (this.polygonOffsetUnits = t.polygonOffsetUnits),
                            (this.dithering = t.dithering),
                            (this.alphaTest = t.alphaTest),
                            (this.alphaToCoverage = t.alphaToCoverage),
                            (this.premultipliedAlpha = t.premultipliedAlpha),
                            (this.visible = t.visible),
                            (this.toneMapped = t.toneMapped),
                            (this.userData = JSON.parse(
                                JSON.stringify(t.userData),
                            )),
                            this
                        );
                    }
                    dispose() {
                        this.dispatchEvent({ type: "dispose" });
                    }
                    set needsUpdate(t) {
                        !0 === t && this.version++;
                    }
                }
                class Ue extends Pe {
                    constructor(t) {
                        super(),
                            (this.isMeshBasicMaterial = !0),
                            (this.type = "MeshBasicMaterial"),
                            (this.color = new ct(16777215)),
                            (this.map = null),
                            (this.lightMap = null),
                            (this.lightMapIntensity = 1),
                            (this.aoMap = null),
                            (this.aoMapIntensity = 1),
                            (this.specularMap = null),
                            (this.alphaMap = null),
                            (this.envMap = null),
                            (this.combine = 0),
                            (this.reflectivity = 1),
                            (this.refractionRatio = 0.98),
                            (this.wireframe = !1),
                            (this.wireframeLinewidth = 1),
                            (this.wireframeLinecap = "round"),
                            (this.wireframeLinejoin = "round"),
                            (this.fog = !0),
                            this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            this.color.copy(t.color),
                            (this.map = t.map),
                            (this.lightMap = t.lightMap),
                            (this.lightMapIntensity = t.lightMapIntensity),
                            (this.aoMap = t.aoMap),
                            (this.aoMapIntensity = t.aoMapIntensity),
                            (this.specularMap = t.specularMap),
                            (this.alphaMap = t.alphaMap),
                            (this.envMap = t.envMap),
                            (this.combine = t.combine),
                            (this.reflectivity = t.reflectivity),
                            (this.refractionRatio = t.refractionRatio),
                            (this.wireframe = t.wireframe),
                            (this.wireframeLinewidth = t.wireframeLinewidth),
                            (this.wireframeLinecap = t.wireframeLinecap),
                            (this.wireframeLinejoin = t.wireframeLinejoin),
                            (this.fog = t.fog),
                            this
                        );
                    }
                }
                const Ve = new St(),
                    Ne = new K();
                class Ge {
                    constructor(t, e, n = !1) {
                        if (Array.isArray(t))
                            throw new TypeError(
                                "THREE.BufferAttribute: array should be a Typed Array.",
                            );
                        (this.isBufferAttribute = !0),
                            (this.name = ""),
                            (this.array = t),
                            (this.itemSize = e),
                            (this.count = void 0 !== t ? t.length / e : 0),
                            (this.normalized = n),
                            (this.usage = 35044),
                            (this.updateRange = { offset: 0, count: -1 }),
                            (this.version = 0);
                    }
                    onUploadCallback() {}
                    set needsUpdate(t) {
                        !0 === t && this.version++;
                    }
                    setUsage(t) {
                        return (this.usage = t), this;
                    }
                    copy(t) {
                        return (
                            (this.name = t.name),
                            (this.array = new t.array.constructor(t.array)),
                            (this.itemSize = t.itemSize),
                            (this.count = t.count),
                            (this.normalized = t.normalized),
                            (this.usage = t.usage),
                            this
                        );
                    }
                    copyAt(t, e, n) {
                        (t *= this.itemSize), (n *= e.itemSize);
                        for (let i = 0, r = this.itemSize; i < r; i++)
                            this.array[t + i] = e.array[n + i];
                        return this;
                    }
                    copyArray(t) {
                        return this.array.set(t), this;
                    }
                    applyMatrix3(t) {
                        if (2 === this.itemSize)
                            for (let e = 0, n = this.count; e < n; e++)
                                Ne.fromBufferAttribute(this, e),
                                    Ne.applyMatrix3(t),
                                    this.setXY(e, Ne.x, Ne.y);
                        else if (3 === this.itemSize)
                            for (let e = 0, n = this.count; e < n; e++)
                                Ve.fromBufferAttribute(this, e),
                                    Ve.applyMatrix3(t),
                                    this.setXYZ(e, Ve.x, Ve.y, Ve.z);
                        return this;
                    }
                    applyMatrix4(t) {
                        for (let e = 0, n = this.count; e < n; e++)
                            Ve.fromBufferAttribute(this, e),
                                Ve.applyMatrix4(t),
                                this.setXYZ(e, Ve.x, Ve.y, Ve.z);
                        return this;
                    }
                    applyNormalMatrix(t) {
                        for (let e = 0, n = this.count; e < n; e++)
                            Ve.fromBufferAttribute(this, e),
                                Ve.applyNormalMatrix(t),
                                this.setXYZ(e, Ve.x, Ve.y, Ve.z);
                        return this;
                    }
                    transformDirection(t) {
                        for (let e = 0, n = this.count; e < n; e++)
                            Ve.fromBufferAttribute(this, e),
                                Ve.transformDirection(t),
                                this.setXYZ(e, Ve.x, Ve.y, Ve.z);
                        return this;
                    }
                    set(t, e = 0) {
                        return this.array.set(t, e), this;
                    }
                    getX(t) {
                        let e = this.array[t * this.itemSize];
                        return this.normalized && (e = q(e, this.array)), e;
                    }
                    setX(t, e) {
                        return (
                            this.normalized && (e = Y(e, this.array)),
                            (this.array[t * this.itemSize] = e),
                            this
                        );
                    }
                    getY(t) {
                        let e = this.array[t * this.itemSize + 1];
                        return this.normalized && (e = q(e, this.array)), e;
                    }
                    setY(t, e) {
                        return (
                            this.normalized && (e = Y(e, this.array)),
                            (this.array[t * this.itemSize + 1] = e),
                            this
                        );
                    }
                    getZ(t) {
                        let e = this.array[t * this.itemSize + 2];
                        return this.normalized && (e = q(e, this.array)), e;
                    }
                    setZ(t, e) {
                        return (
                            this.normalized && (e = Y(e, this.array)),
                            (this.array[t * this.itemSize + 2] = e),
                            this
                        );
                    }
                    getW(t) {
                        let e = this.array[t * this.itemSize + 3];
                        return this.normalized && (e = q(e, this.array)), e;
                    }
                    setW(t, e) {
                        return (
                            this.normalized && (e = Y(e, this.array)),
                            (this.array[t * this.itemSize + 3] = e),
                            this
                        );
                    }
                    setXY(t, e, n) {
                        return (
                            (t *= this.itemSize),
                            this.normalized &&
                                ((e = Y(e, this.array)),
                                (n = Y(n, this.array))),
                            (this.array[t + 0] = e),
                            (this.array[t + 1] = n),
                            this
                        );
                    }
                    setXYZ(t, e, n, i) {
                        return (
                            (t *= this.itemSize),
                            this.normalized &&
                                ((e = Y(e, this.array)),
                                (n = Y(n, this.array)),
                                (i = Y(i, this.array))),
                            (this.array[t + 0] = e),
                            (this.array[t + 1] = n),
                            (this.array[t + 2] = i),
                            this
                        );
                    }
                    setXYZW(t, e, n, i, r) {
                        return (
                            (t *= this.itemSize),
                            this.normalized &&
                                ((e = Y(e, this.array)),
                                (n = Y(n, this.array)),
                                (i = Y(i, this.array)),
                                (r = Y(r, this.array))),
                            (this.array[t + 0] = e),
                            (this.array[t + 1] = n),
                            (this.array[t + 2] = i),
                            (this.array[t + 3] = r),
                            this
                        );
                    }
                    onUpload(t) {
                        return (this.onUploadCallback = t), this;
                    }
                    clone() {
                        return new this.constructor(
                            this.array,
                            this.itemSize,
                        ).copy(this);
                    }
                    toJSON() {
                        const t = {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: Array.from(this.array),
                            normalized: this.normalized,
                        };
                        return (
                            "" !== this.name && (t.name = this.name),
                            35044 !== this.usage && (t.usage = this.usage),
                            (0 === this.updateRange.offset &&
                                -1 === this.updateRange.count) ||
                                (t.updateRange = this.updateRange),
                            t
                        );
                    }
                    copyColorsArray() {
                        console.error(
                            "THREE.BufferAttribute: copyColorsArray() was removed in r144.",
                        );
                    }
                    copyVector2sArray() {
                        console.error(
                            "THREE.BufferAttribute: copyVector2sArray() was removed in r144.",
                        );
                    }
                    copyVector3sArray() {
                        console.error(
                            "THREE.BufferAttribute: copyVector3sArray() was removed in r144.",
                        );
                    }
                    copyVector4sArray() {
                        console.error(
                            "THREE.BufferAttribute: copyVector4sArray() was removed in r144.",
                        );
                    }
                }
                class je extends Ge {
                    constructor(t, e, n) {
                        super(new Uint16Array(t), e, n);
                    }
                }
                class He extends Ge {
                    constructor(t, e, n) {
                        super(new Uint32Array(t), e, n);
                    }
                }
                class Fe extends Ge {
                    constructor(t, e, n) {
                        super(new Float32Array(t), e, n);
                    }
                }
                let Be = 0;
                const ze = new Xt(),
                    We = new Me(),
                    qe = new St(),
                    Ye = new _t(),
                    Ke = new _t(),
                    Je = new St();
                class Ze extends V {
                    constructor() {
                        super(),
                            (this.isBufferGeometry = !0),
                            Object.defineProperty(this, "id", { value: Be++ }),
                            (this.uuid = H()),
                            (this.name = ""),
                            (this.type = "BufferGeometry"),
                            (this.index = null),
                            (this.attributes = {}),
                            (this.morphAttributes = {}),
                            (this.morphTargetsRelative = !1),
                            (this.groups = []),
                            (this.boundingBox = null),
                            (this.boundingSphere = null),
                            (this.drawRange = { start: 0, count: 1 / 0 }),
                            (this.userData = {});
                    }
                    getIndex() {
                        return this.index;
                    }
                    setIndex(t) {
                        return (
                            Array.isArray(t)
                                ? (this.index = new (X(t) ? He : je)(t, 1))
                                : (this.index = t),
                            this
                        );
                    }
                    getAttribute(t) {
                        return this.attributes[t];
                    }
                    setAttribute(t, e) {
                        return (this.attributes[t] = e), this;
                    }
                    deleteAttribute(t) {
                        return delete this.attributes[t], this;
                    }
                    hasAttribute(t) {
                        return void 0 !== this.attributes[t];
                    }
                    addGroup(t, e, n = 0) {
                        this.groups.push({
                            start: t,
                            count: e,
                            materialIndex: n,
                        });
                    }
                    clearGroups() {
                        this.groups = [];
                    }
                    setDrawRange(t, e) {
                        (this.drawRange.start = t), (this.drawRange.count = e);
                    }
                    applyMatrix4(t) {
                        const e = this.attributes.position;
                        void 0 !== e &&
                            (e.applyMatrix4(t), (e.needsUpdate = !0));
                        const n = this.attributes.normal;
                        if (void 0 !== n) {
                            const e = new J().getNormalMatrix(t);
                            n.applyNormalMatrix(e), (n.needsUpdate = !0);
                        }
                        const i = this.attributes.tangent;
                        return (
                            void 0 !== i &&
                                (i.transformDirection(t), (i.needsUpdate = !0)),
                            null !== this.boundingBox &&
                                this.computeBoundingBox(),
                            null !== this.boundingSphere &&
                                this.computeBoundingSphere(),
                            this
                        );
                    }
                    applyQuaternion(t) {
                        return (
                            ze.makeRotationFromQuaternion(t),
                            this.applyMatrix4(ze),
                            this
                        );
                    }
                    rotateX(t) {
                        return ze.makeRotationX(t), this.applyMatrix4(ze), this;
                    }
                    rotateY(t) {
                        return ze.makeRotationY(t), this.applyMatrix4(ze), this;
                    }
                    rotateZ(t) {
                        return ze.makeRotationZ(t), this.applyMatrix4(ze), this;
                    }
                    translate(t, e, n) {
                        return (
                            ze.makeTranslation(t, e, n),
                            this.applyMatrix4(ze),
                            this
                        );
                    }
                    scale(t, e, n) {
                        return (
                            ze.makeScale(t, e, n), this.applyMatrix4(ze), this
                        );
                    }
                    lookAt(t) {
                        return (
                            We.lookAt(t),
                            We.updateMatrix(),
                            this.applyMatrix4(We.matrix),
                            this
                        );
                    }
                    center() {
                        return (
                            this.computeBoundingBox(),
                            this.boundingBox.getCenter(qe).negate(),
                            this.translate(qe.x, qe.y, qe.z),
                            this
                        );
                    }
                    setFromPoints(t) {
                        const e = [];
                        for (let n = 0, i = t.length; n < i; n++) {
                            const i = t[n];
                            e.push(i.x, i.y, i.z || 0);
                        }
                        return (
                            this.setAttribute("position", new Fe(e, 3)), this
                        );
                    }
                    computeBoundingBox() {
                        null === this.boundingBox &&
                            (this.boundingBox = new _t());
                        const t = this.attributes.position,
                            e = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute)
                            return (
                                console.error(
                                    'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                                    this,
                                ),
                                void this.boundingBox.set(
                                    new St(-1 / 0, -1 / 0, -1 / 0),
                                    new St(1 / 0, 1 / 0, 1 / 0),
                                )
                            );
                        if (void 0 !== t) {
                            if ((this.boundingBox.setFromBufferAttribute(t), e))
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    Ye.setFromBufferAttribute(n),
                                        this.morphTargetsRelative
                                            ? (Je.addVectors(
                                                  this.boundingBox.min,
                                                  Ye.min,
                                              ),
                                              this.boundingBox.expandByPoint(
                                                  Je,
                                              ),
                                              Je.addVectors(
                                                  this.boundingBox.max,
                                                  Ye.max,
                                              ),
                                              this.boundingBox.expandByPoint(
                                                  Je,
                                              ))
                                            : (this.boundingBox.expandByPoint(
                                                  Ye.min,
                                              ),
                                              this.boundingBox.expandByPoint(
                                                  Ye.max,
                                              ));
                                }
                        } else this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) ||
                            isNaN(this.boundingBox.min.y) ||
                            isNaN(this.boundingBox.min.z)) &&
                            console.error(
                                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                                this,
                            );
                    }
                    computeBoundingSphere() {
                        null === this.boundingSphere &&
                            (this.boundingSphere = new Ft());
                        const t = this.attributes.position,
                            e = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute)
                            return (
                                console.error(
                                    'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                                    this,
                                ),
                                void this.boundingSphere.set(new St(), 1 / 0)
                            );
                        if (t) {
                            const n = this.boundingSphere.center;
                            if ((Ye.setFromBufferAttribute(t), e))
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    Ke.setFromBufferAttribute(n),
                                        this.morphTargetsRelative
                                            ? (Je.addVectors(Ye.min, Ke.min),
                                              Ye.expandByPoint(Je),
                                              Je.addVectors(Ye.max, Ke.max),
                                              Ye.expandByPoint(Je))
                                            : (Ye.expandByPoint(Ke.min),
                                              Ye.expandByPoint(Ke.max));
                                }
                            Ye.getCenter(n);
                            let i = 0;
                            for (let e = 0, r = t.count; e < r; e++)
                                Je.fromBufferAttribute(t, e),
                                    (i = Math.max(i, n.distanceToSquared(Je)));
                            if (e)
                                for (let r = 0, a = e.length; r < a; r++) {
                                    const a = e[r],
                                        s = this.morphTargetsRelative;
                                    for (let e = 0, r = a.count; e < r; e++)
                                        Je.fromBufferAttribute(a, e),
                                            s &&
                                                (qe.fromBufferAttribute(t, e),
                                                Je.add(qe)),
                                            (i = Math.max(
                                                i,
                                                n.distanceToSquared(Je),
                                            ));
                                }
                            (this.boundingSphere.radius = Math.sqrt(i)),
                                isNaN(this.boundingSphere.radius) &&
                                    console.error(
                                        'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                                        this,
                                    );
                        }
                    }
                    computeTangents() {
                        const t = this.index,
                            e = this.attributes;
                        if (
                            null === t ||
                            void 0 === e.position ||
                            void 0 === e.normal ||
                            void 0 === e.uv
                        )
                            return void console.error(
                                "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)",
                            );
                        const n = t.array,
                            i = e.position.array,
                            r = e.normal.array,
                            a = e.uv.array,
                            s = i.length / 3;
                        !1 === this.hasAttribute("tangent") &&
                            this.setAttribute(
                                "tangent",
                                new Ge(new Float32Array(4 * s), 4),
                            );
                        const o = this.getAttribute("tangent").array,
                            l = [],
                            c = [];
                        for (let t = 0; t < s; t++)
                            (l[t] = new St()), (c[t] = new St());
                        const h = new St(),
                            u = new St(),
                            d = new St(),
                            p = new K(),
                            f = new K(),
                            m = new K(),
                            g = new St(),
                            v = new St();
                        function x(t, e, n) {
                            h.fromArray(i, 3 * t),
                                u.fromArray(i, 3 * e),
                                d.fromArray(i, 3 * n),
                                p.fromArray(a, 2 * t),
                                f.fromArray(a, 2 * e),
                                m.fromArray(a, 2 * n),
                                u.sub(h),
                                d.sub(h),
                                f.sub(p),
                                m.sub(p);
                            const r = 1 / (f.x * m.y - m.x * f.y);
                            isFinite(r) &&
                                (g
                                    .copy(u)
                                    .multiplyScalar(m.y)
                                    .addScaledVector(d, -f.y)
                                    .multiplyScalar(r),
                                v
                                    .copy(d)
                                    .multiplyScalar(f.x)
                                    .addScaledVector(u, -m.x)
                                    .multiplyScalar(r),
                                l[t].add(g),
                                l[e].add(g),
                                l[n].add(g),
                                c[t].add(v),
                                c[e].add(v),
                                c[n].add(v));
                        }
                        let b = this.groups;
                        0 === b.length && (b = [{ start: 0, count: n.length }]);
                        for (let t = 0, e = b.length; t < e; ++t) {
                            const e = b[t],
                                i = e.start;
                            for (let t = i, r = i + e.count; t < r; t += 3)
                                x(n[t + 0], n[t + 1], n[t + 2]);
                        }
                        const y = new St(),
                            S = new St(),
                            M = new St(),
                            A = new St();
                        function _(t) {
                            M.fromArray(r, 3 * t), A.copy(M);
                            const e = l[t];
                            y.copy(e),
                                y.sub(M.multiplyScalar(M.dot(e))).normalize(),
                                S.crossVectors(A, e);
                            const n = S.dot(c[t]) < 0 ? -1 : 1;
                            (o[4 * t] = y.x),
                                (o[4 * t + 1] = y.y),
                                (o[4 * t + 2] = y.z),
                                (o[4 * t + 3] = n);
                        }
                        for (let t = 0, e = b.length; t < e; ++t) {
                            const e = b[t],
                                i = e.start;
                            for (let t = i, r = i + e.count; t < r; t += 3)
                                _(n[t + 0]), _(n[t + 1]), _(n[t + 2]);
                        }
                    }
                    computeVertexNormals() {
                        const t = this.index,
                            e = this.getAttribute("position");
                        if (void 0 !== e) {
                            let n = this.getAttribute("normal");
                            if (void 0 === n)
                                (n = new Ge(new Float32Array(3 * e.count), 3)),
                                    this.setAttribute("normal", n);
                            else
                                for (let t = 0, e = n.count; t < e; t++)
                                    n.setXYZ(t, 0, 0, 0);
                            const i = new St(),
                                r = new St(),
                                a = new St(),
                                s = new St(),
                                o = new St(),
                                l = new St(),
                                c = new St(),
                                h = new St();
                            if (t)
                                for (let u = 0, d = t.count; u < d; u += 3) {
                                    const d = t.getX(u + 0),
                                        p = t.getX(u + 1),
                                        f = t.getX(u + 2);
                                    i.fromBufferAttribute(e, d),
                                        r.fromBufferAttribute(e, p),
                                        a.fromBufferAttribute(e, f),
                                        c.subVectors(a, r),
                                        h.subVectors(i, r),
                                        c.cross(h),
                                        s.fromBufferAttribute(n, d),
                                        o.fromBufferAttribute(n, p),
                                        l.fromBufferAttribute(n, f),
                                        s.add(c),
                                        o.add(c),
                                        l.add(c),
                                        n.setXYZ(d, s.x, s.y, s.z),
                                        n.setXYZ(p, o.x, o.y, o.z),
                                        n.setXYZ(f, l.x, l.y, l.z);
                                }
                            else
                                for (let t = 0, s = e.count; t < s; t += 3)
                                    i.fromBufferAttribute(e, t + 0),
                                        r.fromBufferAttribute(e, t + 1),
                                        a.fromBufferAttribute(e, t + 2),
                                        c.subVectors(a, r),
                                        h.subVectors(i, r),
                                        c.cross(h),
                                        n.setXYZ(t + 0, c.x, c.y, c.z),
                                        n.setXYZ(t + 1, c.x, c.y, c.z),
                                        n.setXYZ(t + 2, c.x, c.y, c.z);
                            this.normalizeNormals(), (n.needsUpdate = !0);
                        }
                    }
                    merge() {
                        return (
                            console.error(
                                "THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead.",
                            ),
                            this
                        );
                    }
                    normalizeNormals() {
                        const t = this.attributes.normal;
                        for (let e = 0, n = t.count; e < n; e++)
                            Je.fromBufferAttribute(t, e),
                                Je.normalize(),
                                t.setXYZ(e, Je.x, Je.y, Je.z);
                    }
                    toNonIndexed() {
                        function t(t, e) {
                            const n = t.array,
                                i = t.itemSize,
                                r = t.normalized,
                                a = new n.constructor(e.length * i);
                            let s = 0,
                                o = 0;
                            for (let r = 0, l = e.length; r < l; r++) {
                                s = t.isInterleavedBufferAttribute
                                    ? e[r] * t.data.stride + t.offset
                                    : e[r] * i;
                                for (let t = 0; t < i; t++) a[o++] = n[s++];
                            }
                            return new Ge(a, i, r);
                        }
                        if (null === this.index)
                            return (
                                console.warn(
                                    "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.",
                                ),
                                this
                            );
                        const e = new Ze(),
                            n = this.index.array,
                            i = this.attributes;
                        for (const r in i) {
                            const a = t(i[r], n);
                            e.setAttribute(r, a);
                        }
                        const r = this.morphAttributes;
                        for (const i in r) {
                            const a = [],
                                s = r[i];
                            for (let e = 0, i = s.length; e < i; e++) {
                                const i = t(s[e], n);
                                a.push(i);
                            }
                            e.morphAttributes[i] = a;
                        }
                        e.morphTargetsRelative = this.morphTargetsRelative;
                        const a = this.groups;
                        for (let t = 0, n = a.length; t < n; t++) {
                            const n = a[t];
                            e.addGroup(n.start, n.count, n.materialIndex);
                        }
                        return e;
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.5,
                                type: "BufferGeometry",
                                generator: "BufferGeometry.toJSON",
                            },
                        };
                        if (
                            ((t.uuid = this.uuid),
                            (t.type = this.type),
                            "" !== this.name && (t.name = this.name),
                            Object.keys(this.userData).length > 0 &&
                                (t.userData = this.userData),
                            void 0 !== this.parameters)
                        ) {
                            const e = this.parameters;
                            for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                            return t;
                        }
                        t.data = { attributes: {} };
                        const e = this.index;
                        null !== e &&
                            (t.data.index = {
                                type: e.array.constructor.name,
                                array: Array.prototype.slice.call(e.array),
                            });
                        const n = this.attributes;
                        for (const e in n) {
                            const i = n[e];
                            t.data.attributes[e] = i.toJSON(t.data);
                        }
                        const i = {};
                        let r = !1;
                        for (const e in this.morphAttributes) {
                            const n = this.morphAttributes[e],
                                a = [];
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                a.push(i.toJSON(t.data));
                            }
                            a.length > 0 && ((i[e] = a), (r = !0));
                        }
                        r &&
                            ((t.data.morphAttributes = i),
                            (t.data.morphTargetsRelative =
                                this.morphTargetsRelative));
                        const a = this.groups;
                        a.length > 0 &&
                            (t.data.groups = JSON.parse(JSON.stringify(a)));
                        const s = this.boundingSphere;
                        return (
                            null !== s &&
                                (t.data.boundingSphere = {
                                    center: s.center.toArray(),
                                    radius: s.radius,
                                }),
                            t
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(t) {
                        (this.index = null),
                            (this.attributes = {}),
                            (this.morphAttributes = {}),
                            (this.groups = []),
                            (this.boundingBox = null),
                            (this.boundingSphere = null);
                        const e = {};
                        this.name = t.name;
                        const n = t.index;
                        null !== n && this.setIndex(n.clone(e));
                        const i = t.attributes;
                        for (const t in i) {
                            const n = i[t];
                            this.setAttribute(t, n.clone(e));
                        }
                        const r = t.morphAttributes;
                        for (const t in r) {
                            const n = [],
                                i = r[t];
                            for (let t = 0, r = i.length; t < r; t++)
                                n.push(i[t].clone(e));
                            this.morphAttributes[t] = n;
                        }
                        this.morphTargetsRelative = t.morphTargetsRelative;
                        const a = t.groups;
                        for (let t = 0, e = a.length; t < e; t++) {
                            const e = a[t];
                            this.addGroup(e.start, e.count, e.materialIndex);
                        }
                        const s = t.boundingBox;
                        null !== s && (this.boundingBox = s.clone());
                        const o = t.boundingSphere;
                        return (
                            null !== o && (this.boundingSphere = o.clone()),
                            (this.drawRange.start = t.drawRange.start),
                            (this.drawRange.count = t.drawRange.count),
                            (this.userData = t.userData),
                            void 0 !== t.parameters &&
                                (this.parameters = Object.assign(
                                    {},
                                    t.parameters,
                                )),
                            this
                        );
                    }
                    dispose() {
                        this.dispatchEvent({ type: "dispose" });
                    }
                }
                const Xe = new Xt(),
                    Qe = new Zt(),
                    $e = new Ft(),
                    tn = new St(),
                    en = new St(),
                    nn = new St(),
                    rn = new St(),
                    an = new St(),
                    sn = new K(),
                    on = new K(),
                    ln = new K(),
                    cn = new St(),
                    hn = new St();
                class un extends Me {
                    constructor(t = new Ze(), e = new Ue()) {
                        super(),
                            (this.isMesh = !0),
                            (this.type = "Mesh"),
                            (this.geometry = t),
                            (this.material = e),
                            this.updateMorphTargets();
                    }
                    copy(t, e) {
                        return (
                            super.copy(t, e),
                            void 0 !== t.morphTargetInfluences &&
                                (this.morphTargetInfluences =
                                    t.morphTargetInfluences.slice()),
                            void 0 !== t.morphTargetDictionary &&
                                (this.morphTargetDictionary = Object.assign(
                                    {},
                                    t.morphTargetDictionary,
                                )),
                            (this.material = t.material),
                            (this.geometry = t.geometry),
                            this
                        );
                    }
                    updateMorphTargets() {
                        const t = this.geometry.morphAttributes,
                            e = Object.keys(t);
                        if (e.length > 0) {
                            const n = t[e[0]];
                            if (void 0 !== n) {
                                (this.morphTargetInfluences = []),
                                    (this.morphTargetDictionary = {});
                                for (let t = 0, e = n.length; t < e; t++) {
                                    const e = n[t].name || String(t);
                                    this.morphTargetInfluences.push(0),
                                        (this.morphTargetDictionary[e] = t);
                                }
                            }
                        }
                    }
                    getVertexPosition(t, e) {
                        const n = this.geometry,
                            i = n.attributes.position,
                            r = n.morphAttributes.position,
                            a = n.morphTargetsRelative;
                        e.fromBufferAttribute(i, t);
                        const s = this.morphTargetInfluences;
                        if (r && s) {
                            an.set(0, 0, 0);
                            for (let n = 0, i = r.length; n < i; n++) {
                                const i = s[n],
                                    o = r[n];
                                0 !== i &&
                                    (rn.fromBufferAttribute(o, t),
                                    a
                                        ? an.addScaledVector(rn, i)
                                        : an.addScaledVector(rn.sub(e), i));
                            }
                            e.add(an);
                        }
                        return (
                            this.isSkinnedMesh && this.boneTransform(t, e), e
                        );
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            i = this.material,
                            r = this.matrixWorld;
                        if (void 0 === i) return;
                        if (
                            (null === n.boundingSphere &&
                                n.computeBoundingSphere(),
                            $e.copy(n.boundingSphere),
                            $e.applyMatrix4(r),
                            !1 === t.ray.intersectsSphere($e))
                        )
                            return;
                        if (
                            (Xe.copy(r).invert(),
                            Qe.copy(t.ray).applyMatrix4(Xe),
                            null !== n.boundingBox &&
                                !1 === Qe.intersectsBox(n.boundingBox))
                        )
                            return;
                        let a;
                        const s = n.index,
                            o = n.attributes.position,
                            l = n.attributes.uv,
                            c = n.attributes.uv2,
                            h = n.groups,
                            u = n.drawRange;
                        if (null !== s)
                            if (Array.isArray(i))
                                for (let n = 0, r = h.length; n < r; n++) {
                                    const r = h[n],
                                        o = i[r.materialIndex];
                                    for (
                                        let n = Math.max(r.start, u.start),
                                            i = Math.min(
                                                s.count,
                                                Math.min(
                                                    r.start + r.count,
                                                    u.start + u.count,
                                                ),
                                            );
                                        n < i;
                                        n += 3
                                    ) {
                                        const i = s.getX(n),
                                            h = s.getX(n + 1),
                                            u = s.getX(n + 2);
                                        (a = dn(this, o, t, Qe, l, c, i, h, u)),
                                            a &&
                                                ((a.faceIndex = Math.floor(
                                                    n / 3,
                                                )),
                                                (a.face.materialIndex =
                                                    r.materialIndex),
                                                e.push(a));
                                    }
                                }
                            else
                                for (
                                    let n = Math.max(0, u.start),
                                        r = Math.min(
                                            s.count,
                                            u.start + u.count,
                                        );
                                    n < r;
                                    n += 3
                                ) {
                                    const r = s.getX(n),
                                        o = s.getX(n + 1),
                                        h = s.getX(n + 2);
                                    (a = dn(this, i, t, Qe, l, c, r, o, h)),
                                        a &&
                                            ((a.faceIndex = Math.floor(n / 3)),
                                            e.push(a));
                                }
                        else if (void 0 !== o)
                            if (Array.isArray(i))
                                for (let n = 0, r = h.length; n < r; n++) {
                                    const r = h[n],
                                        s = i[r.materialIndex];
                                    for (
                                        let n = Math.max(r.start, u.start),
                                            i = Math.min(
                                                o.count,
                                                Math.min(
                                                    r.start + r.count,
                                                    u.start + u.count,
                                                ),
                                            );
                                        n < i;
                                        n += 3
                                    )
                                        (a = dn(
                                            this,
                                            s,
                                            t,
                                            Qe,
                                            l,
                                            c,
                                            n,
                                            n + 1,
                                            n + 2,
                                        )),
                                            a &&
                                                ((a.faceIndex = Math.floor(
                                                    n / 3,
                                                )),
                                                (a.face.materialIndex =
                                                    r.materialIndex),
                                                e.push(a));
                                }
                            else
                                for (
                                    let n = Math.max(0, u.start),
                                        r = Math.min(
                                            o.count,
                                            u.start + u.count,
                                        );
                                    n < r;
                                    n += 3
                                )
                                    (a = dn(
                                        this,
                                        i,
                                        t,
                                        Qe,
                                        l,
                                        c,
                                        n,
                                        n + 1,
                                        n + 2,
                                    )),
                                        a &&
                                            ((a.faceIndex = Math.floor(n / 3)),
                                            e.push(a));
                    }
                }
                function dn(t, e, n, i, r, a, s, o, l) {
                    t.getVertexPosition(s, tn),
                        t.getVertexPosition(o, en),
                        t.getVertexPosition(l, nn);
                    const c = (function (t, e, n, i, r, a, s, o) {
                        let l;
                        if (
                            ((l =
                                1 === e.side
                                    ? i.intersectTriangle(s, a, r, !0, o)
                                    : i.intersectTriangle(
                                          r,
                                          a,
                                          s,
                                          0 === e.side,
                                          o,
                                      )),
                            null === l)
                        )
                            return null;
                        hn.copy(o), hn.applyMatrix4(t.matrixWorld);
                        const c = n.ray.origin.distanceTo(hn);
                        return c < n.near || c > n.far
                            ? null
                            : { distance: c, point: hn.clone(), object: t };
                    })(t, e, n, i, tn, en, nn, cn);
                    if (c) {
                        r &&
                            (sn.fromBufferAttribute(r, s),
                            on.fromBufferAttribute(r, o),
                            ln.fromBufferAttribute(r, l),
                            (c.uv = Oe.getUV(
                                cn,
                                tn,
                                en,
                                nn,
                                sn,
                                on,
                                ln,
                                new K(),
                            ))),
                            a &&
                                (sn.fromBufferAttribute(a, s),
                                on.fromBufferAttribute(a, o),
                                ln.fromBufferAttribute(a, l),
                                (c.uv2 = Oe.getUV(
                                    cn,
                                    tn,
                                    en,
                                    nn,
                                    sn,
                                    on,
                                    ln,
                                    new K(),
                                )));
                        const t = {
                            a: s,
                            b: o,
                            c: l,
                            normal: new St(),
                            materialIndex: 0,
                        };
                        Oe.getNormal(tn, en, nn, t.normal), (c.face = t);
                    }
                    return c;
                }
                class pn extends Ze {
                    constructor(t = 1, e = 1, n = 1, i = 1, r = 1, a = 1) {
                        super(),
                            (this.type = "BoxGeometry"),
                            (this.parameters = {
                                width: t,
                                height: e,
                                depth: n,
                                widthSegments: i,
                                heightSegments: r,
                                depthSegments: a,
                            });
                        const s = this;
                        (i = Math.floor(i)),
                            (r = Math.floor(r)),
                            (a = Math.floor(a));
                        const o = [],
                            l = [],
                            c = [],
                            h = [];
                        let u = 0,
                            d = 0;
                        function p(t, e, n, i, r, a, p, f, m, g, v) {
                            const x = a / m,
                                b = p / g,
                                y = a / 2,
                                S = p / 2,
                                M = f / 2,
                                A = m + 1,
                                _ = g + 1;
                            let w = 0,
                                T = 0;
                            const E = new St();
                            for (let a = 0; a < _; a++) {
                                const s = a * b - S;
                                for (let o = 0; o < A; o++) {
                                    const u = o * x - y;
                                    (E[t] = u * i),
                                        (E[e] = s * r),
                                        (E[n] = M),
                                        l.push(E.x, E.y, E.z),
                                        (E[t] = 0),
                                        (E[e] = 0),
                                        (E[n] = f > 0 ? 1 : -1),
                                        c.push(E.x, E.y, E.z),
                                        h.push(o / m),
                                        h.push(1 - a / g),
                                        (w += 1);
                                }
                            }
                            for (let t = 0; t < g; t++)
                                for (let e = 0; e < m; e++) {
                                    const n = u + e + A * t,
                                        i = u + e + A * (t + 1),
                                        r = u + (e + 1) + A * (t + 1),
                                        a = u + (e + 1) + A * t;
                                    o.push(n, i, a), o.push(i, r, a), (T += 6);
                                }
                            s.addGroup(d, T, v), (d += T), (u += w);
                        }
                        p("z", "y", "x", -1, -1, n, e, t, a, r, 0),
                            p("z", "y", "x", 1, -1, n, e, -t, a, r, 1),
                            p("x", "z", "y", 1, 1, t, n, e, i, a, 2),
                            p("x", "z", "y", 1, -1, t, n, -e, i, a, 3),
                            p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
                            p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
                            this.setIndex(o),
                            this.setAttribute("position", new Fe(l, 3)),
                            this.setAttribute("normal", new Fe(c, 3)),
                            this.setAttribute("uv", new Fe(h, 2));
                    }
                    static fromJSON(t) {
                        return new pn(
                            t.width,
                            t.height,
                            t.depth,
                            t.widthSegments,
                            t.heightSegments,
                            t.depthSegments,
                        );
                    }
                }
                function fn(t) {
                    const e = {};
                    for (const n in t) {
                        e[n] = {};
                        for (const i in t[n]) {
                            const r = t[n][i];
                            r &&
                            (r.isColor ||
                                r.isMatrix3 ||
                                r.isMatrix4 ||
                                r.isVector2 ||
                                r.isVector3 ||
                                r.isVector4 ||
                                r.isTexture ||
                                r.isQuaternion)
                                ? (e[n][i] = r.clone())
                                : Array.isArray(r)
                                ? (e[n][i] = r.slice())
                                : (e[n][i] = r);
                        }
                    }
                    return e;
                }
                function mn(t) {
                    const e = {};
                    for (let n = 0; n < t.length; n++) {
                        const i = fn(t[n]);
                        for (const t in i) e[t] = i[t];
                    }
                    return e;
                }
                function gn(t) {
                    return null === t.getRenderTarget() &&
                        t.outputEncoding === L
                        ? I
                        : O;
                }
                const vn = { clone: fn, merge: mn };
                class xn extends Pe {
                    constructor(t) {
                        super(),
                            (this.isShaderMaterial = !0),
                            (this.type = "ShaderMaterial"),
                            (this.defines = {}),
                            (this.uniforms = {}),
                            (this.uniformsGroups = []),
                            (this.vertexShader =
                                "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
                            (this.fragmentShader =
                                "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
                            (this.linewidth = 1),
                            (this.wireframe = !1),
                            (this.wireframeLinewidth = 1),
                            (this.fog = !1),
                            (this.lights = !1),
                            (this.clipping = !1),
                            (this.extensions = {
                                derivatives: !1,
                                fragDepth: !1,
                                drawBuffers: !1,
                                shaderTextureLOD: !1,
                            }),
                            (this.defaultAttributeValues = {
                                color: [1, 1, 1],
                                uv: [0, 0],
                                uv2: [0, 0],
                            }),
                            (this.index0AttributeName = void 0),
                            (this.uniformsNeedUpdate = !1),
                            (this.glslVersion = null),
                            void 0 !== t && this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            (this.fragmentShader = t.fragmentShader),
                            (this.vertexShader = t.vertexShader),
                            (this.uniforms = fn(t.uniforms)),
                            (this.uniformsGroups = (function (t) {
                                const e = [];
                                for (let n = 0; n < t.length; n++)
                                    e.push(t[n].clone());
                                return e;
                            })(t.uniformsGroups)),
                            (this.defines = Object.assign({}, t.defines)),
                            (this.wireframe = t.wireframe),
                            (this.wireframeLinewidth = t.wireframeLinewidth),
                            (this.fog = t.fog),
                            (this.lights = t.lights),
                            (this.clipping = t.clipping),
                            (this.extensions = Object.assign({}, t.extensions)),
                            (this.glslVersion = t.glslVersion),
                            this
                        );
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        (e.glslVersion = this.glslVersion), (e.uniforms = {});
                        for (const n in this.uniforms) {
                            const i = this.uniforms[n].value;
                            i && i.isTexture
                                ? (e.uniforms[n] = {
                                      type: "t",
                                      value: i.toJSON(t).uuid,
                                  })
                                : i && i.isColor
                                ? (e.uniforms[n] = {
                                      type: "c",
                                      value: i.getHex(),
                                  })
                                : i && i.isVector2
                                ? (e.uniforms[n] = {
                                      type: "v2",
                                      value: i.toArray(),
                                  })
                                : i && i.isVector3
                                ? (e.uniforms[n] = {
                                      type: "v3",
                                      value: i.toArray(),
                                  })
                                : i && i.isVector4
                                ? (e.uniforms[n] = {
                                      type: "v4",
                                      value: i.toArray(),
                                  })
                                : i && i.isMatrix3
                                ? (e.uniforms[n] = {
                                      type: "m3",
                                      value: i.toArray(),
                                  })
                                : i && i.isMatrix4
                                ? (e.uniforms[n] = {
                                      type: "m4",
                                      value: i.toArray(),
                                  })
                                : (e.uniforms[n] = { value: i });
                        }
                        Object.keys(this.defines).length > 0 &&
                            (e.defines = this.defines),
                            (e.vertexShader = this.vertexShader),
                            (e.fragmentShader = this.fragmentShader);
                        const n = {};
                        for (const t in this.extensions)
                            !0 === this.extensions[t] && (n[t] = !0);
                        return (
                            Object.keys(n).length > 0 && (e.extensions = n), e
                        );
                    }
                }
                class bn extends Me {
                    constructor() {
                        super(),
                            (this.isCamera = !0),
                            (this.type = "Camera"),
                            (this.matrixWorldInverse = new Xt()),
                            (this.projectionMatrix = new Xt()),
                            (this.projectionMatrixInverse = new Xt());
                    }
                    copy(t, e) {
                        return (
                            super.copy(t, e),
                            this.matrixWorldInverse.copy(t.matrixWorldInverse),
                            this.projectionMatrix.copy(t.projectionMatrix),
                            this.projectionMatrixInverse.copy(
                                t.projectionMatrixInverse,
                            ),
                            this
                        );
                    }
                    getWorldDirection(t) {
                        this.updateWorldMatrix(!0, !1);
                        const e = this.matrixWorld.elements;
                        return t.set(-e[8], -e[9], -e[10]).normalize();
                    }
                    updateMatrixWorld(t) {
                        super.updateMatrixWorld(t),
                            this.matrixWorldInverse
                                .copy(this.matrixWorld)
                                .invert();
                    }
                    updateWorldMatrix(t, e) {
                        super.updateWorldMatrix(t, e),
                            this.matrixWorldInverse
                                .copy(this.matrixWorld)
                                .invert();
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                class yn extends bn {
                    constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
                        super(),
                            (this.isPerspectiveCamera = !0),
                            (this.type = "PerspectiveCamera"),
                            (this.fov = t),
                            (this.zoom = 1),
                            (this.near = n),
                            (this.far = i),
                            (this.focus = 10),
                            (this.aspect = e),
                            (this.view = null),
                            (this.filmGauge = 35),
                            (this.filmOffset = 0),
                            this.updateProjectionMatrix();
                    }
                    copy(t, e) {
                        return (
                            super.copy(t, e),
                            (this.fov = t.fov),
                            (this.zoom = t.zoom),
                            (this.near = t.near),
                            (this.far = t.far),
                            (this.focus = t.focus),
                            (this.aspect = t.aspect),
                            (this.view =
                                null === t.view
                                    ? null
                                    : Object.assign({}, t.view)),
                            (this.filmGauge = t.filmGauge),
                            (this.filmOffset = t.filmOffset),
                            this
                        );
                    }
                    setFocalLength(t) {
                        const e = (0.5 * this.getFilmHeight()) / t;
                        (this.fov = 2 * j * Math.atan(e)),
                            this.updateProjectionMatrix();
                    }
                    getFocalLength() {
                        const t = Math.tan(0.5 * G * this.fov);
                        return (0.5 * this.getFilmHeight()) / t;
                    }
                    getEffectiveFOV() {
                        return (
                            2 *
                            j *
                            Math.atan(Math.tan(0.5 * G * this.fov) / this.zoom)
                        );
                    }
                    getFilmWidth() {
                        return this.filmGauge * Math.min(this.aspect, 1);
                    }
                    getFilmHeight() {
                        return this.filmGauge / Math.max(this.aspect, 1);
                    }
                    setViewOffset(t, e, n, i, r, a) {
                        (this.aspect = t / e),
                            null === this.view &&
                                (this.view = {
                                    enabled: !0,
                                    fullWidth: 1,
                                    fullHeight: 1,
                                    offsetX: 0,
                                    offsetY: 0,
                                    width: 1,
                                    height: 1,
                                }),
                            (this.view.enabled = !0),
                            (this.view.fullWidth = t),
                            (this.view.fullHeight = e),
                            (this.view.offsetX = n),
                            (this.view.offsetY = i),
                            (this.view.width = r),
                            (this.view.height = a),
                            this.updateProjectionMatrix();
                    }
                    clearViewOffset() {
                        null !== this.view && (this.view.enabled = !1),
                            this.updateProjectionMatrix();
                    }
                    updateProjectionMatrix() {
                        const t = this.near;
                        let e = (t * Math.tan(0.5 * G * this.fov)) / this.zoom,
                            n = 2 * e,
                            i = this.aspect * n,
                            r = -0.5 * i;
                        const a = this.view;
                        if (null !== this.view && this.view.enabled) {
                            const t = a.fullWidth,
                                s = a.fullHeight;
                            (r += (a.offsetX * i) / t),
                                (e -= (a.offsetY * n) / s),
                                (i *= a.width / t),
                                (n *= a.height / s);
                        }
                        const s = this.filmOffset;
                        0 !== s && (r += (t * s) / this.getFilmWidth()),
                            this.projectionMatrix.makePerspective(
                                r,
                                r + i,
                                e,
                                e - n,
                                t,
                                this.far,
                            ),
                            this.projectionMatrixInverse
                                .copy(this.projectionMatrix)
                                .invert();
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return (
                            (e.object.fov = this.fov),
                            (e.object.zoom = this.zoom),
                            (e.object.near = this.near),
                            (e.object.far = this.far),
                            (e.object.focus = this.focus),
                            (e.object.aspect = this.aspect),
                            null !== this.view &&
                                (e.object.view = Object.assign({}, this.view)),
                            (e.object.filmGauge = this.filmGauge),
                            (e.object.filmOffset = this.filmOffset),
                            e
                        );
                    }
                }
                const Sn = -90;
                class Mn extends Me {
                    constructor(t, e, n) {
                        super(),
                            (this.type = "CubeCamera"),
                            (this.renderTarget = n);
                        const i = new yn(Sn, 1, t, e);
                        (i.layers = this.layers),
                            i.up.set(0, 1, 0),
                            i.lookAt(1, 0, 0),
                            this.add(i);
                        const r = new yn(Sn, 1, t, e);
                        (r.layers = this.layers),
                            r.up.set(0, 1, 0),
                            r.lookAt(-1, 0, 0),
                            this.add(r);
                        const a = new yn(Sn, 1, t, e);
                        (a.layers = this.layers),
                            a.up.set(0, 0, -1),
                            a.lookAt(0, 1, 0),
                            this.add(a);
                        const s = new yn(Sn, 1, t, e);
                        (s.layers = this.layers),
                            s.up.set(0, 0, 1),
                            s.lookAt(0, -1, 0),
                            this.add(s);
                        const o = new yn(Sn, 1, t, e);
                        (o.layers = this.layers),
                            o.up.set(0, 1, 0),
                            o.lookAt(0, 0, 1),
                            this.add(o);
                        const l = new yn(Sn, 1, t, e);
                        (l.layers = this.layers),
                            l.up.set(0, 1, 0),
                            l.lookAt(0, 0, -1),
                            this.add(l);
                    }
                    update(t, e) {
                        null === this.parent && this.updateMatrixWorld();
                        const n = this.renderTarget,
                            [i, r, a, s, o, l] = this.children,
                            c = t.getRenderTarget(),
                            h = t.toneMapping,
                            u = t.xr.enabled;
                        (t.toneMapping = 0), (t.xr.enabled = !1);
                        const d = n.texture.generateMipmaps;
                        (n.texture.generateMipmaps = !1),
                            t.setRenderTarget(n, 0),
                            t.render(e, i),
                            t.setRenderTarget(n, 1),
                            t.render(e, r),
                            t.setRenderTarget(n, 2),
                            t.render(e, a),
                            t.setRenderTarget(n, 3),
                            t.render(e, s),
                            t.setRenderTarget(n, 4),
                            t.render(e, o),
                            (n.texture.generateMipmaps = d),
                            t.setRenderTarget(n, 5),
                            t.render(e, l),
                            t.setRenderTarget(c),
                            (t.toneMapping = h),
                            (t.xr.enabled = u),
                            (n.texture.needsPMREMUpdate = !0);
                    }
                }
                class An extends mt {
                    constructor(t, e, i, r, a, s, o, l, c, h) {
                        super(
                            (t = void 0 !== t ? t : []),
                            (e = void 0 !== e ? e : n),
                            i,
                            r,
                            a,
                            s,
                            o,
                            l,
                            c,
                            h,
                        ),
                            (this.isCubeTexture = !0),
                            (this.flipY = !1);
                    }
                    get images() {
                        return this.image;
                    }
                    set images(t) {
                        this.image = t;
                    }
                }
                class _n extends vt {
                    constructor(t = 1, e = {}) {
                        super(t, t, e), (this.isWebGLCubeRenderTarget = !0);
                        const n = { width: t, height: t, depth: 1 },
                            i = [n, n, n, n, n, n];
                        (this.texture = new An(
                            i,
                            e.mapping,
                            e.wrapS,
                            e.wrapT,
                            e.magFilter,
                            e.minFilter,
                            e.format,
                            e.type,
                            e.anisotropy,
                            e.encoding,
                        )),
                            (this.texture.isRenderTargetTexture = !0),
                            (this.texture.generateMipmaps =
                                void 0 !== e.generateMipmaps &&
                                e.generateMipmaps),
                            (this.texture.minFilter =
                                void 0 !== e.minFilter ? e.minFilter : h);
                    }
                    fromEquirectangularTexture(t, e) {
                        (this.texture.type = e.type),
                            (this.texture.encoding = e.encoding),
                            (this.texture.generateMipmaps = e.generateMipmaps),
                            (this.texture.minFilter = e.minFilter),
                            (this.texture.magFilter = e.magFilter);
                        const n = { tEquirect: { value: null } },
                            i =
                                "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                            r =
                                "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                            a = new pn(5, 5, 5),
                            s = new xn({
                                name: "CubemapFromEquirect",
                                uniforms: fn(n),
                                vertexShader: i,
                                fragmentShader: r,
                                side: 1,
                                blending: 0,
                            });
                        s.uniforms.tEquirect.value = e;
                        const o = new un(a, s),
                            l = e.minFilter;
                        return (
                            e.minFilter === u && (e.minFilter = h),
                            new Mn(1, 10, this).update(t, o),
                            (e.minFilter = l),
                            o.geometry.dispose(),
                            o.material.dispose(),
                            this
                        );
                    }
                    clear(t, e, n, i) {
                        const r = t.getRenderTarget();
                        for (let r = 0; r < 6; r++)
                            t.setRenderTarget(this, r), t.clear(e, n, i);
                        t.setRenderTarget(r);
                    }
                }
                const wn = new St(),
                    Tn = new St(),
                    En = new J();
                class Rn {
                    constructor(t = new St(1, 0, 0), e = 0) {
                        (this.isPlane = !0),
                            (this.normal = t),
                            (this.constant = e);
                    }
                    set(t, e) {
                        return this.normal.copy(t), (this.constant = e), this;
                    }
                    setComponents(t, e, n, i) {
                        return (
                            this.normal.set(t, e, n), (this.constant = i), this
                        );
                    }
                    setFromNormalAndCoplanarPoint(t, e) {
                        return (
                            this.normal.copy(t),
                            (this.constant = -e.dot(this.normal)),
                            this
                        );
                    }
                    setFromCoplanarPoints(t, e, n) {
                        const i = wn
                            .subVectors(n, e)
                            .cross(Tn.subVectors(t, e))
                            .normalize();
                        return this.setFromNormalAndCoplanarPoint(i, t), this;
                    }
                    copy(t) {
                        return (
                            this.normal.copy(t.normal),
                            (this.constant = t.constant),
                            this
                        );
                    }
                    normalize() {
                        const t = 1 / this.normal.length();
                        return (
                            this.normal.multiplyScalar(t),
                            (this.constant *= t),
                            this
                        );
                    }
                    negate() {
                        return (
                            (this.constant *= -1), this.normal.negate(), this
                        );
                    }
                    distanceToPoint(t) {
                        return this.normal.dot(t) + this.constant;
                    }
                    distanceToSphere(t) {
                        return this.distanceToPoint(t.center) - t.radius;
                    }
                    projectPoint(t, e) {
                        return e
                            .copy(this.normal)
                            .multiplyScalar(-this.distanceToPoint(t))
                            .add(t);
                    }
                    intersectLine(t, e) {
                        const n = t.delta(wn),
                            i = this.normal.dot(n);
                        if (0 === i)
                            return 0 === this.distanceToPoint(t.start)
                                ? e.copy(t.start)
                                : null;
                        const r =
                            -(t.start.dot(this.normal) + this.constant) / i;
                        return r < 0 || r > 1
                            ? null
                            : e.copy(n).multiplyScalar(r).add(t.start);
                    }
                    intersectsLine(t) {
                        const e = this.distanceToPoint(t.start),
                            n = this.distanceToPoint(t.end);
                        return (e < 0 && n > 0) || (n < 0 && e > 0);
                    }
                    intersectsBox(t) {
                        return t.intersectsPlane(this);
                    }
                    intersectsSphere(t) {
                        return t.intersectsPlane(this);
                    }
                    coplanarPoint(t) {
                        return t
                            .copy(this.normal)
                            .multiplyScalar(-this.constant);
                    }
                    applyMatrix4(t, e) {
                        const n = e || En.getNormalMatrix(t),
                            i = this.coplanarPoint(wn).applyMatrix4(t),
                            r = this.normal.applyMatrix3(n).normalize();
                        return (this.constant = -i.dot(r)), this;
                    }
                    translate(t) {
                        return (this.constant -= t.dot(this.normal)), this;
                    }
                    equals(t) {
                        return (
                            t.normal.equals(this.normal) &&
                            t.constant === this.constant
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                const kn = new Ft(),
                    Cn = new St();
                class Ln {
                    constructor(
                        t = new Rn(),
                        e = new Rn(),
                        n = new Rn(),
                        i = new Rn(),
                        r = new Rn(),
                        a = new Rn(),
                    ) {
                        this.planes = [t, e, n, i, r, a];
                    }
                    set(t, e, n, i, r, a) {
                        const s = this.planes;
                        return (
                            s[0].copy(t),
                            s[1].copy(e),
                            s[2].copy(n),
                            s[3].copy(i),
                            s[4].copy(r),
                            s[5].copy(a),
                            this
                        );
                    }
                    copy(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                        return this;
                    }
                    setFromProjectionMatrix(t) {
                        const e = this.planes,
                            n = t.elements,
                            i = n[0],
                            r = n[1],
                            a = n[2],
                            s = n[3],
                            o = n[4],
                            l = n[5],
                            c = n[6],
                            h = n[7],
                            u = n[8],
                            d = n[9],
                            p = n[10],
                            f = n[11],
                            m = n[12],
                            g = n[13],
                            v = n[14],
                            x = n[15];
                        return (
                            e[0]
                                .setComponents(s - i, h - o, f - u, x - m)
                                .normalize(),
                            e[1]
                                .setComponents(s + i, h + o, f + u, x + m)
                                .normalize(),
                            e[2]
                                .setComponents(s + r, h + l, f + d, x + g)
                                .normalize(),
                            e[3]
                                .setComponents(s - r, h - l, f - d, x - g)
                                .normalize(),
                            e[4]
                                .setComponents(s - a, h - c, f - p, x - v)
                                .normalize(),
                            e[5]
                                .setComponents(s + a, h + c, f + p, x + v)
                                .normalize(),
                            this
                        );
                    }
                    intersectsObject(t) {
                        const e = t.geometry;
                        return (
                            null === e.boundingSphere &&
                                e.computeBoundingSphere(),
                            kn
                                .copy(e.boundingSphere)
                                .applyMatrix4(t.matrixWorld),
                            this.intersectsSphere(kn)
                        );
                    }
                    intersectsSprite(t) {
                        return (
                            kn.center.set(0, 0, 0),
                            (kn.radius = 0.7071067811865476),
                            kn.applyMatrix4(t.matrixWorld),
                            this.intersectsSphere(kn)
                        );
                    }
                    intersectsSphere(t) {
                        const e = this.planes,
                            n = t.center,
                            i = -t.radius;
                        for (let t = 0; t < 6; t++)
                            if (e[t].distanceToPoint(n) < i) return !1;
                        return !0;
                    }
                    intersectsBox(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++) {
                            const i = e[n];
                            if (
                                ((Cn.x = i.normal.x > 0 ? t.max.x : t.min.x),
                                (Cn.y = i.normal.y > 0 ? t.max.y : t.min.y),
                                (Cn.z = i.normal.z > 0 ? t.max.z : t.min.z),
                                i.distanceToPoint(Cn) < 0)
                            )
                                return !1;
                        }
                        return !0;
                    }
                    containsPoint(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++)
                            if (e[n].distanceToPoint(t) < 0) return !1;
                        return !0;
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                function In() {
                    let t = null,
                        e = !1,
                        n = null,
                        i = null;
                    function r(e, a) {
                        n(e, a), (i = t.requestAnimationFrame(r));
                    }
                    return {
                        start: function () {
                            !0 !== e &&
                                null !== n &&
                                ((i = t.requestAnimationFrame(r)), (e = !0));
                        },
                        stop: function () {
                            t.cancelAnimationFrame(i), (e = !1);
                        },
                        setAnimationLoop: function (t) {
                            n = t;
                        },
                        setContext: function (e) {
                            t = e;
                        },
                    };
                }
                function On(t, e) {
                    const n = e.isWebGL2,
                        i = new WeakMap();
                    return {
                        get: function (t) {
                            return (
                                t.isInterleavedBufferAttribute && (t = t.data),
                                i.get(t)
                            );
                        },
                        remove: function (e) {
                            e.isInterleavedBufferAttribute && (e = e.data);
                            const n = i.get(e);
                            n && (t.deleteBuffer(n.buffer), i.delete(e));
                        },
                        update: function (e, r) {
                            if (e.isGLBufferAttribute) {
                                const t = i.get(e);
                                return void (
                                    (!t || t.version < e.version) &&
                                    i.set(e, {
                                        buffer: e.buffer,
                                        type: e.type,
                                        bytesPerElement: e.elementSize,
                                        version: e.version,
                                    })
                                );
                            }
                            e.isInterleavedBufferAttribute && (e = e.data);
                            const a = i.get(e);
                            void 0 === a
                                ? i.set(
                                      e,
                                      (function (e, i) {
                                          const r = e.array,
                                              a = e.usage,
                                              s = t.createBuffer();
                                          let o;
                                          if (
                                              (t.bindBuffer(i, s),
                                              t.bufferData(i, r, a),
                                              e.onUploadCallback(),
                                              r instanceof Float32Array)
                                          )
                                              o = 5126;
                                          else if (r instanceof Uint16Array)
                                              if (e.isFloat16BufferAttribute) {
                                                  if (!n)
                                                      throw new Error(
                                                          "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.",
                                                      );
                                                  o = 5131;
                                              } else o = 5123;
                                          else if (r instanceof Int16Array)
                                              o = 5122;
                                          else if (r instanceof Uint32Array)
                                              o = 5125;
                                          else if (r instanceof Int32Array)
                                              o = 5124;
                                          else if (r instanceof Int8Array)
                                              o = 5120;
                                          else if (r instanceof Uint8Array)
                                              o = 5121;
                                          else {
                                              if (
                                                  !(
                                                      r instanceof
                                                      Uint8ClampedArray
                                                  )
                                              )
                                                  throw new Error(
                                                      "THREE.WebGLAttributes: Unsupported buffer data format: " +
                                                          r,
                                                  );
                                              o = 5121;
                                          }
                                          return {
                                              buffer: s,
                                              type: o,
                                              bytesPerElement:
                                                  r.BYTES_PER_ELEMENT,
                                              version: e.version,
                                          };
                                      })(e, r),
                                  )
                                : a.version < e.version &&
                                  ((function (e, i, r) {
                                      const a = i.array,
                                          s = i.updateRange;
                                      t.bindBuffer(r, e),
                                          -1 === s.count
                                              ? t.bufferSubData(r, 0, a)
                                              : (n
                                                    ? t.bufferSubData(
                                                          r,
                                                          s.offset *
                                                              a.BYTES_PER_ELEMENT,
                                                          a,
                                                          s.offset,
                                                          s.count,
                                                      )
                                                    : t.bufferSubData(
                                                          r,
                                                          s.offset *
                                                              a.BYTES_PER_ELEMENT,
                                                          a.subarray(
                                                              s.offset,
                                                              s.offset +
                                                                  s.count,
                                                          ),
                                                      ),
                                                (s.count = -1)),
                                          i.onUploadCallback();
                                  })(a.buffer, e, r),
                                  (a.version = e.version));
                        },
                    };
                }
                class Dn extends Ze {
                    constructor(t = 1, e = 1, n = 1, i = 1) {
                        super(),
                            (this.type = "PlaneGeometry"),
                            (this.parameters = {
                                width: t,
                                height: e,
                                widthSegments: n,
                                heightSegments: i,
                            });
                        const r = t / 2,
                            a = e / 2,
                            s = Math.floor(n),
                            o = Math.floor(i),
                            l = s + 1,
                            c = o + 1,
                            h = t / s,
                            u = e / o,
                            d = [],
                            p = [],
                            f = [],
                            m = [];
                        for (let t = 0; t < c; t++) {
                            const e = t * u - a;
                            for (let n = 0; n < l; n++) {
                                const i = n * h - r;
                                p.push(i, -e, 0),
                                    f.push(0, 0, 1),
                                    m.push(n / s),
                                    m.push(1 - t / o);
                            }
                        }
                        for (let t = 0; t < o; t++)
                            for (let e = 0; e < s; e++) {
                                const n = e + l * t,
                                    i = e + l * (t + 1),
                                    r = e + 1 + l * (t + 1),
                                    a = e + 1 + l * t;
                                d.push(n, i, a), d.push(i, r, a);
                            }
                        this.setIndex(d),
                            this.setAttribute("position", new Fe(p, 3)),
                            this.setAttribute("normal", new Fe(f, 3)),
                            this.setAttribute("uv", new Fe(m, 2));
                    }
                    static fromJSON(t) {
                        return new Dn(
                            t.width,
                            t.height,
                            t.widthSegments,
                            t.heightSegments,
                        );
                    }
                }
                const Pn = {
                        alphamap_fragment:
                            "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                        alphamap_pars_fragment:
                            "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                        alphatest_fragment:
                            "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                        alphatest_pars_fragment:
                            "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                        aomap_fragment:
                            "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                        aomap_pars_fragment:
                            "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                        begin_vertex: "vec3 transformed = vec3( position );",
                        beginnormal_vertex:
                            "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                        bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
                        iridescence_fragment:
                            "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
                        bumpmap_pars_fragment:
                            "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                        clipping_planes_fragment:
                            "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                        clipping_planes_pars_fragment:
                            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                        clipping_planes_pars_vertex:
                            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                        clipping_planes_vertex:
                            "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                        color_fragment:
                            "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                        color_pars_fragment:
                            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                        color_pars_vertex:
                            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                        color_vertex:
                            "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                        common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                        cube_uv_reflection_fragment:
                            "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                        defaultnormal_vertex:
                            "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                        displacementmap_pars_vertex:
                            "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                        displacementmap_vertex:
                            "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                        emissivemap_fragment:
                            "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                        emissivemap_pars_fragment:
                            "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                        encodings_fragment:
                            "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                        encodings_pars_fragment:
                            "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
                        envmap_fragment:
                            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                        envmap_common_pars_fragment:
                            "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                        envmap_pars_fragment:
                            "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                        envmap_pars_vertex:
                            "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                        envmap_physical_pars_fragment:
                            "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
                        envmap_vertex:
                            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                        fog_vertex:
                            "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                        fog_pars_vertex:
                            "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                        fog_fragment:
                            "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                        fog_pars_fragment:
                            "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                        gradientmap_pars_fragment:
                            "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
                        lightmap_fragment:
                            "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                        lightmap_pars_fragment:
                            "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                        lights_lambert_fragment:
                            "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
                        lights_lambert_pars_fragment:
                            "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
                        lights_pars_begin:
                            "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                        lights_toon_fragment:
                            "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                        lights_toon_pars_fragment:
                            "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
                        lights_phong_fragment:
                            "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                        lights_phong_pars_fragment:
                            "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
                        lights_physical_fragment:
                            "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
                        lights_physical_pars_fragment:
                            "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                        lights_fragment_begin:
                            "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                        lights_fragment_maps:
                            "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                        lights_fragment_end:
                            "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                        logdepthbuf_fragment:
                            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                        logdepthbuf_pars_fragment:
                            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                        logdepthbuf_pars_vertex:
                            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                        logdepthbuf_vertex:
                            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                        map_fragment:
                            "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                        map_pars_fragment:
                            "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                        map_particle_fragment:
                            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                        map_particle_pars_fragment:
                            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                        metalnessmap_fragment:
                            "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                        metalnessmap_pars_fragment:
                            "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                        morphcolor_vertex:
                            "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                        morphnormal_vertex:
                            "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                        morphtarget_pars_vertex:
                            "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                        morphtarget_vertex:
                            "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                        normal_fragment_begin:
                            "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                        normal_fragment_maps:
                            "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                        normal_pars_fragment:
                            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                        normal_pars_vertex:
                            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                        normal_vertex:
                            "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                        normalmap_pars_fragment:
                            "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
                        clearcoat_normal_fragment_begin:
                            "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                        clearcoat_normal_fragment_maps:
                            "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
                        clearcoat_pars_fragment:
                            "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                        iridescence_pars_fragment:
                            "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
                        output_fragment:
                            "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                        packing:
                            "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                        premultiplied_alpha_fragment:
                            "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                        project_vertex:
                            "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                        dithering_fragment:
                            "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                        dithering_pars_fragment:
                            "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                        roughnessmap_fragment:
                            "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                        roughnessmap_pars_fragment:
                            "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                        shadowmap_pars_fragment:
                            "#if NUM_SPOT_LIGHT_COORDS > 0\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                        shadowmap_pars_vertex:
                            "#if NUM_SPOT_LIGHT_COORDS > 0\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                        shadowmap_vertex:
                            "#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                        shadowmask_pars_fragment:
                            "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                        skinbase_vertex:
                            "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                        skinning_pars_vertex:
                            "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
                        skinning_vertex:
                            "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                        skinnormal_vertex:
                            "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                        specularmap_fragment:
                            "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                        specularmap_pars_fragment:
                            "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                        tonemapping_fragment:
                            "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                        tonemapping_pars_fragment:
                            "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                        transmission_fragment:
                            "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif",
                        transmission_pars_fragment:
                            "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
                        uv_pars_fragment:
                            "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                        uv_pars_vertex:
                            "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                        uv_vertex:
                            "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                        uv2_pars_fragment:
                            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                        uv2_pars_vertex:
                            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                        uv2_vertex:
                            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                        worldpos_vertex:
                            "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                        background_vert:
                            "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                        background_frag:
                            "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                        backgroundCube_vert:
                            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                        backgroundCube_frag:
                            "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                        cube_vert:
                            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                        cube_frag:
                            "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                        depth_vert:
                            "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                        depth_frag:
                            "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                        distanceRGBA_vert:
                            "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                        distanceRGBA_frag:
                            "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                        equirect_vert:
                            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                        equirect_frag:
                            "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                        linedashed_vert:
                            "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                        linedashed_frag:
                            "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                        meshbasic_vert:
                            "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshbasic_frag:
                            "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshlambert_vert:
                            "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshlambert_frag:
                            "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshmatcap_vert:
                            "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                        meshmatcap_frag:
                            "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshnormal_vert:
                            "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                        meshnormal_frag:
                            "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                        meshphong_vert:
                            "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshphong_frag:
                            "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshphysical_vert:
                            "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                        meshphysical_frag:
                            "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshtoon_vert:
                            "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshtoon_frag:
                            "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        points_vert:
                            "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                        points_frag:
                            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                        shadow_vert:
                            "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        shadow_frag:
                            "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                        sprite_vert:
                            "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                        sprite_frag:
                            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    },
                    Un = {
                        common: {
                            diffuse: { value: new ct(16777215) },
                            opacity: { value: 1 },
                            map: { value: null },
                            uvTransform: { value: new J() },
                            uv2Transform: { value: new J() },
                            alphaMap: { value: null },
                            alphaTest: { value: 0 },
                        },
                        specularmap: { specularMap: { value: null } },
                        envmap: {
                            envMap: { value: null },
                            flipEnvMap: { value: -1 },
                            reflectivity: { value: 1 },
                            ior: { value: 1.5 },
                            refractionRatio: { value: 0.98 },
                        },
                        aomap: {
                            aoMap: { value: null },
                            aoMapIntensity: { value: 1 },
                        },
                        lightmap: {
                            lightMap: { value: null },
                            lightMapIntensity: { value: 1 },
                        },
                        emissivemap: { emissiveMap: { value: null } },
                        bumpmap: {
                            bumpMap: { value: null },
                            bumpScale: { value: 1 },
                        },
                        normalmap: {
                            normalMap: { value: null },
                            normalScale: { value: new K(1, 1) },
                        },
                        displacementmap: {
                            displacementMap: { value: null },
                            displacementScale: { value: 1 },
                            displacementBias: { value: 0 },
                        },
                        roughnessmap: { roughnessMap: { value: null } },
                        metalnessmap: { metalnessMap: { value: null } },
                        gradientmap: { gradientMap: { value: null } },
                        fog: {
                            fogDensity: { value: 25e-5 },
                            fogNear: { value: 1 },
                            fogFar: { value: 2e3 },
                            fogColor: { value: new ct(16777215) },
                        },
                        lights: {
                            ambientLightColor: { value: [] },
                            lightProbe: { value: [] },
                            directionalLights: {
                                value: [],
                                properties: { direction: {}, color: {} },
                            },
                            directionalLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {},
                                },
                            },
                            directionalShadowMap: { value: [] },
                            directionalShadowMatrix: { value: [] },
                            spotLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    direction: {},
                                    distance: {},
                                    coneCos: {},
                                    penumbraCos: {},
                                    decay: {},
                                },
                            },
                            spotLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {},
                                },
                            },
                            spotLightMap: { value: [] },
                            spotShadowMap: { value: [] },
                            spotLightMatrix: { value: [] },
                            pointLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    decay: {},
                                    distance: {},
                                },
                            },
                            pointLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {},
                                    shadowCameraNear: {},
                                    shadowCameraFar: {},
                                },
                            },
                            pointShadowMap: { value: [] },
                            pointShadowMatrix: { value: [] },
                            hemisphereLights: {
                                value: [],
                                properties: {
                                    direction: {},
                                    skyColor: {},
                                    groundColor: {},
                                },
                            },
                            rectAreaLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    width: {},
                                    height: {},
                                },
                            },
                            ltc_1: { value: null },
                            ltc_2: { value: null },
                        },
                        points: {
                            diffuse: { value: new ct(16777215) },
                            opacity: { value: 1 },
                            size: { value: 1 },
                            scale: { value: 1 },
                            map: { value: null },
                            alphaMap: { value: null },
                            alphaTest: { value: 0 },
                            uvTransform: { value: new J() },
                        },
                        sprite: {
                            diffuse: { value: new ct(16777215) },
                            opacity: { value: 1 },
                            center: { value: new K(0.5, 0.5) },
                            rotation: { value: 0 },
                            map: { value: null },
                            alphaMap: { value: null },
                            alphaTest: { value: 0 },
                            uvTransform: { value: new J() },
                        },
                    },
                    Vn = {
                        basic: {
                            uniforms: mn([
                                Un.common,
                                Un.specularmap,
                                Un.envmap,
                                Un.aomap,
                                Un.lightmap,
                                Un.fog,
                            ]),
                            vertexShader: Pn.meshbasic_vert,
                            fragmentShader: Pn.meshbasic_frag,
                        },
                        lambert: {
                            uniforms: mn([
                                Un.common,
                                Un.specularmap,
                                Un.envmap,
                                Un.aomap,
                                Un.lightmap,
                                Un.emissivemap,
                                Un.bumpmap,
                                Un.normalmap,
                                Un.displacementmap,
                                Un.fog,
                                Un.lights,
                                { emissive: { value: new ct(0) } },
                            ]),
                            vertexShader: Pn.meshlambert_vert,
                            fragmentShader: Pn.meshlambert_frag,
                        },
                        phong: {
                            uniforms: mn([
                                Un.common,
                                Un.specularmap,
                                Un.envmap,
                                Un.aomap,
                                Un.lightmap,
                                Un.emissivemap,
                                Un.bumpmap,
                                Un.normalmap,
                                Un.displacementmap,
                                Un.fog,
                                Un.lights,
                                {
                                    emissive: { value: new ct(0) },
                                    specular: { value: new ct(1118481) },
                                    shininess: { value: 30 },
                                },
                            ]),
                            vertexShader: Pn.meshphong_vert,
                            fragmentShader: Pn.meshphong_frag,
                        },
                        standard: {
                            uniforms: mn([
                                Un.common,
                                Un.envmap,
                                Un.aomap,
                                Un.lightmap,
                                Un.emissivemap,
                                Un.bumpmap,
                                Un.normalmap,
                                Un.displacementmap,
                                Un.roughnessmap,
                                Un.metalnessmap,
                                Un.fog,
                                Un.lights,
                                {
                                    emissive: { value: new ct(0) },
                                    roughness: { value: 1 },
                                    metalness: { value: 0 },
                                    envMapIntensity: { value: 1 },
                                },
                            ]),
                            vertexShader: Pn.meshphysical_vert,
                            fragmentShader: Pn.meshphysical_frag,
                        },
                        toon: {
                            uniforms: mn([
                                Un.common,
                                Un.aomap,
                                Un.lightmap,
                                Un.emissivemap,
                                Un.bumpmap,
                                Un.normalmap,
                                Un.displacementmap,
                                Un.gradientmap,
                                Un.fog,
                                Un.lights,
                                { emissive: { value: new ct(0) } },
                            ]),
                            vertexShader: Pn.meshtoon_vert,
                            fragmentShader: Pn.meshtoon_frag,
                        },
                        matcap: {
                            uniforms: mn([
                                Un.common,
                                Un.bumpmap,
                                Un.normalmap,
                                Un.displacementmap,
                                Un.fog,
                                { matcap: { value: null } },
                            ]),
                            vertexShader: Pn.meshmatcap_vert,
                            fragmentShader: Pn.meshmatcap_frag,
                        },
                        points: {
                            uniforms: mn([Un.points, Un.fog]),
                            vertexShader: Pn.points_vert,
                            fragmentShader: Pn.points_frag,
                        },
                        dashed: {
                            uniforms: mn([
                                Un.common,
                                Un.fog,
                                {
                                    scale: { value: 1 },
                                    dashSize: { value: 1 },
                                    totalSize: { value: 2 },
                                },
                            ]),
                            vertexShader: Pn.linedashed_vert,
                            fragmentShader: Pn.linedashed_frag,
                        },
                        depth: {
                            uniforms: mn([Un.common, Un.displacementmap]),
                            vertexShader: Pn.depth_vert,
                            fragmentShader: Pn.depth_frag,
                        },
                        normal: {
                            uniforms: mn([
                                Un.common,
                                Un.bumpmap,
                                Un.normalmap,
                                Un.displacementmap,
                                { opacity: { value: 1 } },
                            ]),
                            vertexShader: Pn.meshnormal_vert,
                            fragmentShader: Pn.meshnormal_frag,
                        },
                        sprite: {
                            uniforms: mn([Un.sprite, Un.fog]),
                            vertexShader: Pn.sprite_vert,
                            fragmentShader: Pn.sprite_frag,
                        },
                        background: {
                            uniforms: {
                                uvTransform: { value: new J() },
                                t2D: { value: null },
                                backgroundIntensity: { value: 1 },
                            },
                            vertexShader: Pn.background_vert,
                            fragmentShader: Pn.background_frag,
                        },
                        backgroundCube: {
                            uniforms: {
                                envMap: { value: null },
                                flipEnvMap: { value: -1 },
                                backgroundBlurriness: { value: 0 },
                                backgroundIntensity: { value: 1 },
                            },
                            vertexShader: Pn.backgroundCube_vert,
                            fragmentShader: Pn.backgroundCube_frag,
                        },
                        cube: {
                            uniforms: {
                                tCube: { value: null },
                                tFlip: { value: -1 },
                                opacity: { value: 1 },
                            },
                            vertexShader: Pn.cube_vert,
                            fragmentShader: Pn.cube_frag,
                        },
                        equirect: {
                            uniforms: { tEquirect: { value: null } },
                            vertexShader: Pn.equirect_vert,
                            fragmentShader: Pn.equirect_frag,
                        },
                        distanceRGBA: {
                            uniforms: mn([
                                Un.common,
                                Un.displacementmap,
                                {
                                    referencePosition: { value: new St() },
                                    nearDistance: { value: 1 },
                                    farDistance: { value: 1e3 },
                                },
                            ]),
                            vertexShader: Pn.distanceRGBA_vert,
                            fragmentShader: Pn.distanceRGBA_frag,
                        },
                        shadow: {
                            uniforms: mn([
                                Un.lights,
                                Un.fog,
                                {
                                    color: { value: new ct(0) },
                                    opacity: { value: 1 },
                                },
                            ]),
                            vertexShader: Pn.shadow_vert,
                            fragmentShader: Pn.shadow_frag,
                        },
                    };
                Vn.physical = {
                    uniforms: mn([
                        Vn.standard.uniforms,
                        {
                            clearcoat: { value: 0 },
                            clearcoatMap: { value: null },
                            clearcoatRoughness: { value: 0 },
                            clearcoatRoughnessMap: { value: null },
                            clearcoatNormalScale: { value: new K(1, 1) },
                            clearcoatNormalMap: { value: null },
                            iridescence: { value: 0 },
                            iridescenceMap: { value: null },
                            iridescenceIOR: { value: 1.3 },
                            iridescenceThicknessMinimum: { value: 100 },
                            iridescenceThicknessMaximum: { value: 400 },
                            iridescenceThicknessMap: { value: null },
                            sheen: { value: 0 },
                            sheenColor: { value: new ct(0) },
                            sheenColorMap: { value: null },
                            sheenRoughness: { value: 1 },
                            sheenRoughnessMap: { value: null },
                            transmission: { value: 0 },
                            transmissionMap: { value: null },
                            transmissionSamplerSize: { value: new K() },
                            transmissionSamplerMap: { value: null },
                            thickness: { value: 0 },
                            thicknessMap: { value: null },
                            attenuationDistance: { value: 0 },
                            attenuationColor: { value: new ct(0) },
                            specularIntensity: { value: 1 },
                            specularIntensityMap: { value: null },
                            specularColor: { value: new ct(1, 1, 1) },
                            specularColorMap: { value: null },
                        },
                    ]),
                    vertexShader: Pn.meshphysical_vert,
                    fragmentShader: Pn.meshphysical_frag,
                };
                const Nn = { r: 0, b: 0, g: 0 };
                function Gn(t, e, n, i, a, s, o) {
                    const l = new ct(0);
                    let c,
                        h,
                        u = !0 === s ? 0 : 1,
                        d = null,
                        p = 0,
                        f = null;
                    function m(e, n) {
                        e.getRGB(Nn, gn(t)),
                            i.buffers.color.setClear(Nn.r, Nn.g, Nn.b, n, o);
                    }
                    return {
                        getClearColor: function () {
                            return l;
                        },
                        setClearColor: function (t, e = 1) {
                            l.set(t), (u = e), m(l, u);
                        },
                        getClearAlpha: function () {
                            return u;
                        },
                        setClearAlpha: function (t) {
                            (u = t), m(l, u);
                        },
                        render: function (i, s) {
                            let o = !1,
                                g = !0 === s.isScene ? s.background : null;
                            g &&
                                g.isTexture &&
                                (g = (s.backgroundBlurriness > 0 ? n : e).get(
                                    g,
                                ));
                            const v = t.xr,
                                x = v.getSession && v.getSession();
                            x &&
                                "additive" === x.environmentBlendMode &&
                                (g = null),
                                null === g
                                    ? m(l, u)
                                    : g && g.isColor && (m(g, 1), (o = !0)),
                                (t.autoClear || o) &&
                                    t.clear(
                                        t.autoClearColor,
                                        t.autoClearDepth,
                                        t.autoClearStencil,
                                    ),
                                g && (g.isCubeTexture || g.mapping === r)
                                    ? (void 0 === h &&
                                          ((h = new un(
                                              new pn(1, 1, 1),
                                              new xn({
                                                  name: "BackgroundCubeMaterial",
                                                  uniforms: fn(
                                                      Vn.backgroundCube
                                                          .uniforms,
                                                  ),
                                                  vertexShader:
                                                      Vn.backgroundCube
                                                          .vertexShader,
                                                  fragmentShader:
                                                      Vn.backgroundCube
                                                          .fragmentShader,
                                                  side: 1,
                                                  depthTest: !1,
                                                  depthWrite: !1,
                                                  fog: !1,
                                              }),
                                          )),
                                          h.geometry.deleteAttribute("normal"),
                                          h.geometry.deleteAttribute("uv"),
                                          (h.onBeforeRender = function (
                                              t,
                                              e,
                                              n,
                                          ) {
                                              this.matrixWorld.copyPosition(
                                                  n.matrixWorld,
                                              );
                                          }),
                                          Object.defineProperty(
                                              h.material,
                                              "envMap",
                                              {
                                                  get: function () {
                                                      return this.uniforms
                                                          .envMap.value;
                                                  },
                                              },
                                          ),
                                          a.update(h)),
                                      (h.material.uniforms.envMap.value = g),
                                      (h.material.uniforms.flipEnvMap.value =
                                          g.isCubeTexture &&
                                          !1 === g.isRenderTargetTexture
                                              ? -1
                                              : 1),
                                      (h.material.uniforms.backgroundBlurriness.value =
                                          s.backgroundBlurriness),
                                      (h.material.uniforms.backgroundIntensity.value =
                                          s.backgroundIntensity),
                                      (h.material.toneMapped =
                                          g.encoding !== L),
                                      (d === g &&
                                          p === g.version &&
                                          f === t.toneMapping) ||
                                          ((h.material.needsUpdate = !0),
                                          (d = g),
                                          (p = g.version),
                                          (f = t.toneMapping)),
                                      h.layers.enableAll(),
                                      i.unshift(
                                          h,
                                          h.geometry,
                                          h.material,
                                          0,
                                          0,
                                          null,
                                      ))
                                    : g &&
                                      g.isTexture &&
                                      (void 0 === c &&
                                          ((c = new un(
                                              new Dn(2, 2),
                                              new xn({
                                                  name: "BackgroundMaterial",
                                                  uniforms: fn(
                                                      Vn.background.uniforms,
                                                  ),
                                                  vertexShader:
                                                      Vn.background
                                                          .vertexShader,
                                                  fragmentShader:
                                                      Vn.background
                                                          .fragmentShader,
                                                  side: 0,
                                                  depthTest: !1,
                                                  depthWrite: !1,
                                                  fog: !1,
                                              }),
                                          )),
                                          c.geometry.deleteAttribute("normal"),
                                          Object.defineProperty(
                                              c.material,
                                              "map",
                                              {
                                                  get: function () {
                                                      return this.uniforms.t2D
                                                          .value;
                                                  },
                                              },
                                          ),
                                          a.update(c)),
                                      (c.material.uniforms.t2D.value = g),
                                      (c.material.uniforms.backgroundIntensity.value =
                                          s.backgroundIntensity),
                                      (c.material.toneMapped =
                                          g.encoding !== L),
                                      !0 === g.matrixAutoUpdate &&
                                          g.updateMatrix(),
                                      c.material.uniforms.uvTransform.value.copy(
                                          g.matrix,
                                      ),
                                      (d === g &&
                                          p === g.version &&
                                          f === t.toneMapping) ||
                                          ((c.material.needsUpdate = !0),
                                          (d = g),
                                          (p = g.version),
                                          (f = t.toneMapping)),
                                      c.layers.enableAll(),
                                      i.unshift(
                                          c,
                                          c.geometry,
                                          c.material,
                                          0,
                                          0,
                                          null,
                                      ));
                        },
                    };
                }
                function jn(t, e, n, i) {
                    const r = t.getParameter(34921),
                        a = i.isWebGL2
                            ? null
                            : e.get("OES_vertex_array_object"),
                        s = i.isWebGL2 || null !== a,
                        o = {},
                        l = p(null);
                    let c = l,
                        h = !1;
                    function u(e) {
                        return i.isWebGL2
                            ? t.bindVertexArray(e)
                            : a.bindVertexArrayOES(e);
                    }
                    function d(e) {
                        return i.isWebGL2
                            ? t.deleteVertexArray(e)
                            : a.deleteVertexArrayOES(e);
                    }
                    function p(t) {
                        const e = [],
                            n = [],
                            i = [];
                        for (let t = 0; t < r; t++)
                            (e[t] = 0), (n[t] = 0), (i[t] = 0);
                        return {
                            geometry: null,
                            program: null,
                            wireframe: !1,
                            newAttributes: e,
                            enabledAttributes: n,
                            attributeDivisors: i,
                            object: t,
                            attributes: {},
                            index: null,
                        };
                    }
                    function f() {
                        const t = c.newAttributes;
                        for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
                    }
                    function m(t) {
                        g(t, 0);
                    }
                    function g(n, r) {
                        const a = c.newAttributes,
                            s = c.enabledAttributes,
                            o = c.attributeDivisors;
                        (a[n] = 1),
                            0 === s[n] &&
                                (t.enableVertexAttribArray(n), (s[n] = 1)),
                            o[n] !== r &&
                                ((i.isWebGL2
                                    ? t
                                    : e.get("ANGLE_instanced_arrays"))[
                                    i.isWebGL2
                                        ? "vertexAttribDivisor"
                                        : "vertexAttribDivisorANGLE"
                                ](n, r),
                                (o[n] = r));
                    }
                    function v() {
                        const e = c.newAttributes,
                            n = c.enabledAttributes;
                        for (let i = 0, r = n.length; i < r; i++)
                            n[i] !== e[i] &&
                                (t.disableVertexAttribArray(i), (n[i] = 0));
                    }
                    function x(e, n, r, a, s, o) {
                        !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
                            ? t.vertexAttribPointer(e, n, r, a, s, o)
                            : t.vertexAttribIPointer(e, n, r, s, o);
                    }
                    function b() {
                        y(), (h = !0), c !== l && ((c = l), u(c.object));
                    }
                    function y() {
                        (l.geometry = null),
                            (l.program = null),
                            (l.wireframe = !1);
                    }
                    return {
                        setup: function (r, l, d, b, y) {
                            let S = !1;
                            if (s) {
                                const e = (function (e, n, r) {
                                    const s = !0 === r.wireframe;
                                    let l = o[e.id];
                                    void 0 === l && ((l = {}), (o[e.id] = l));
                                    let c = l[n.id];
                                    void 0 === c && ((c = {}), (l[n.id] = c));
                                    let h = c[s];
                                    return (
                                        void 0 === h &&
                                            ((h = p(
                                                i.isWebGL2
                                                    ? t.createVertexArray()
                                                    : a.createVertexArrayOES(),
                                            )),
                                            (c[s] = h)),
                                        h
                                    );
                                })(b, d, l);
                                c !== e && ((c = e), u(c.object)),
                                    (S = (function (t, e, n, i) {
                                        const r = c.attributes,
                                            a = e.attributes;
                                        let s = 0;
                                        const o = n.getAttributes();
                                        for (const e in o)
                                            if (o[e].location >= 0) {
                                                const n = r[e];
                                                let i = a[e];
                                                if (
                                                    (void 0 === i &&
                                                        ("instanceMatrix" ===
                                                            e &&
                                                            t.instanceMatrix &&
                                                            (i =
                                                                t.instanceMatrix),
                                                        "instanceColor" === e &&
                                                            t.instanceColor &&
                                                            (i =
                                                                t.instanceColor)),
                                                    void 0 === n)
                                                )
                                                    return !0;
                                                if (n.attribute !== i)
                                                    return !0;
                                                if (i && n.data !== i.data)
                                                    return !0;
                                                s++;
                                            }
                                        return (
                                            c.attributesNum !== s ||
                                            c.index !== i
                                        );
                                    })(r, b, d, y)),
                                    S &&
                                        (function (t, e, n, i) {
                                            const r = {},
                                                a = e.attributes;
                                            let s = 0;
                                            const o = n.getAttributes();
                                            for (const e in o)
                                                if (o[e].location >= 0) {
                                                    let n = a[e];
                                                    void 0 === n &&
                                                        ("instanceMatrix" ===
                                                            e &&
                                                            t.instanceMatrix &&
                                                            (n =
                                                                t.instanceMatrix),
                                                        "instanceColor" === e &&
                                                            t.instanceColor &&
                                                            (n =
                                                                t.instanceColor));
                                                    const i = {};
                                                    (i.attribute = n),
                                                        n &&
                                                            n.data &&
                                                            (i.data = n.data),
                                                        (r[e] = i),
                                                        s++;
                                                }
                                            (c.attributes = r),
                                                (c.attributesNum = s),
                                                (c.index = i);
                                        })(r, b, d, y);
                            } else {
                                const t = !0 === l.wireframe;
                                (c.geometry === b.id &&
                                    c.program === d.id &&
                                    c.wireframe === t) ||
                                    ((c.geometry = b.id),
                                    (c.program = d.id),
                                    (c.wireframe = t),
                                    (S = !0));
                            }
                            null !== y && n.update(y, 34963),
                                (S || h) &&
                                    ((h = !1),
                                    (function (r, a, s, o) {
                                        if (
                                            !1 === i.isWebGL2 &&
                                            (r.isInstancedMesh ||
                                                o.isInstancedBufferGeometry) &&
                                            null ===
                                                e.get("ANGLE_instanced_arrays")
                                        )
                                            return;
                                        f();
                                        const l = o.attributes,
                                            c = s.getAttributes(),
                                            h = a.defaultAttributeValues;
                                        for (const e in c) {
                                            const i = c[e];
                                            if (i.location >= 0) {
                                                let a = l[e];
                                                if (
                                                    (void 0 === a &&
                                                        ("instanceMatrix" ===
                                                            e &&
                                                            r.instanceMatrix &&
                                                            (a =
                                                                r.instanceMatrix),
                                                        "instanceColor" === e &&
                                                            r.instanceColor &&
                                                            (a =
                                                                r.instanceColor)),
                                                    void 0 !== a)
                                                ) {
                                                    const e = a.normalized,
                                                        s = a.itemSize,
                                                        l = n.get(a);
                                                    if (void 0 === l) continue;
                                                    const c = l.buffer,
                                                        h = l.type,
                                                        u = l.bytesPerElement;
                                                    if (
                                                        a.isInterleavedBufferAttribute
                                                    ) {
                                                        const n = a.data,
                                                            l = n.stride,
                                                            d = a.offset;
                                                        if (
                                                            n.isInstancedInterleavedBuffer
                                                        ) {
                                                            for (
                                                                let t = 0;
                                                                t <
                                                                i.locationSize;
                                                                t++
                                                            )
                                                                g(
                                                                    i.location +
                                                                        t,
                                                                    n.meshPerAttribute,
                                                                );
                                                            !0 !==
                                                                r.isInstancedMesh &&
                                                                void 0 ===
                                                                    o._maxInstanceCount &&
                                                                (o._maxInstanceCount =
                                                                    n.meshPerAttribute *
                                                                    n.count);
                                                        } else
                                                            for (
                                                                let t = 0;
                                                                t <
                                                                i.locationSize;
                                                                t++
                                                            )
                                                                m(
                                                                    i.location +
                                                                        t,
                                                                );
                                                        t.bindBuffer(34962, c);
                                                        for (
                                                            let t = 0;
                                                            t < i.locationSize;
                                                            t++
                                                        )
                                                            x(
                                                                i.location + t,
                                                                s /
                                                                    i.locationSize,
                                                                h,
                                                                e,
                                                                l * u,
                                                                (d +
                                                                    (s /
                                                                        i.locationSize) *
                                                                        t) *
                                                                    u,
                                                            );
                                                    } else {
                                                        if (
                                                            a.isInstancedBufferAttribute
                                                        ) {
                                                            for (
                                                                let t = 0;
                                                                t <
                                                                i.locationSize;
                                                                t++
                                                            )
                                                                g(
                                                                    i.location +
                                                                        t,
                                                                    a.meshPerAttribute,
                                                                );
                                                            !0 !==
                                                                r.isInstancedMesh &&
                                                                void 0 ===
                                                                    o._maxInstanceCount &&
                                                                (o._maxInstanceCount =
                                                                    a.meshPerAttribute *
                                                                    a.count);
                                                        } else
                                                            for (
                                                                let t = 0;
                                                                t <
                                                                i.locationSize;
                                                                t++
                                                            )
                                                                m(
                                                                    i.location +
                                                                        t,
                                                                );
                                                        t.bindBuffer(34962, c);
                                                        for (
                                                            let t = 0;
                                                            t < i.locationSize;
                                                            t++
                                                        )
                                                            x(
                                                                i.location + t,
                                                                s /
                                                                    i.locationSize,
                                                                h,
                                                                e,
                                                                s * u,
                                                                (s /
                                                                    i.locationSize) *
                                                                    t *
                                                                    u,
                                                            );
                                                    }
                                                } else if (void 0 !== h) {
                                                    const n = h[e];
                                                    if (void 0 !== n)
                                                        switch (n.length) {
                                                            case 2:
                                                                t.vertexAttrib2fv(
                                                                    i.location,
                                                                    n,
                                                                );
                                                                break;
                                                            case 3:
                                                                t.vertexAttrib3fv(
                                                                    i.location,
                                                                    n,
                                                                );
                                                                break;
                                                            case 4:
                                                                t.vertexAttrib4fv(
                                                                    i.location,
                                                                    n,
                                                                );
                                                                break;
                                                            default:
                                                                t.vertexAttrib1fv(
                                                                    i.location,
                                                                    n,
                                                                );
                                                        }
                                                }
                                            }
                                        }
                                        v();
                                    })(r, l, d, b),
                                    null !== y &&
                                        t.bindBuffer(34963, n.get(y).buffer));
                        },
                        reset: b,
                        resetDefaultState: y,
                        dispose: function () {
                            b();
                            for (const t in o) {
                                const e = o[t];
                                for (const t in e) {
                                    const n = e[t];
                                    for (const t in n)
                                        d(n[t].object), delete n[t];
                                    delete e[t];
                                }
                                delete o[t];
                            }
                        },
                        releaseStatesOfGeometry: function (t) {
                            if (void 0 === o[t.id]) return;
                            const e = o[t.id];
                            for (const t in e) {
                                const n = e[t];
                                for (const t in n) d(n[t].object), delete n[t];
                                delete e[t];
                            }
                            delete o[t.id];
                        },
                        releaseStatesOfProgram: function (t) {
                            for (const e in o) {
                                const n = o[e];
                                if (void 0 === n[t.id]) continue;
                                const i = n[t.id];
                                for (const t in i) d(i[t].object), delete i[t];
                                delete n[t.id];
                            }
                        },
                        initAttributes: f,
                        enableAttribute: m,
                        disableUnusedAttributes: v,
                    };
                }
                function Hn(t, e, n, i) {
                    const r = i.isWebGL2;
                    let a;
                    (this.setMode = function (t) {
                        a = t;
                    }),
                        (this.render = function (e, i) {
                            t.drawArrays(a, e, i), n.update(i, a, 1);
                        }),
                        (this.renderInstances = function (i, s, o) {
                            if (0 === o) return;
                            let l, c;
                            if (r) (l = t), (c = "drawArraysInstanced");
                            else if (
                                ((l = e.get("ANGLE_instanced_arrays")),
                                (c = "drawArraysInstancedANGLE"),
                                null === l)
                            )
                                return void console.error(
                                    "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
                                );
                            l[c](a, i, s, o), n.update(s, a, o);
                        });
                }
                function Fn(t, e, n) {
                    let i;
                    function r(e) {
                        if ("highp" === e) {
                            if (
                                t.getShaderPrecisionFormat(35633, 36338)
                                    .precision > 0 &&
                                t.getShaderPrecisionFormat(35632, 36338)
                                    .precision > 0
                            )
                                return "highp";
                            e = "mediump";
                        }
                        return "mediump" === e &&
                            t.getShaderPrecisionFormat(35633, 36337).precision >
                                0 &&
                            t.getShaderPrecisionFormat(35632, 36337).precision >
                                0
                            ? "mediump"
                            : "lowp";
                    }
                    const a =
                        ("undefined" != typeof WebGL2RenderingContext &&
                            t instanceof WebGL2RenderingContext) ||
                        ("undefined" != typeof WebGL2ComputeRenderingContext &&
                            t instanceof WebGL2ComputeRenderingContext);
                    let s = void 0 !== n.precision ? n.precision : "highp";
                    const o = r(s);
                    o !== s &&
                        (console.warn(
                            "THREE.WebGLRenderer:",
                            s,
                            "not supported, using",
                            o,
                            "instead.",
                        ),
                        (s = o));
                    const l = a || e.has("WEBGL_draw_buffers"),
                        c = !0 === n.logarithmicDepthBuffer,
                        h = t.getParameter(34930),
                        u = t.getParameter(35660),
                        d = t.getParameter(3379),
                        p = t.getParameter(34076),
                        f = t.getParameter(34921),
                        m = t.getParameter(36347),
                        g = t.getParameter(36348),
                        v = t.getParameter(36349),
                        x = u > 0,
                        b = a || e.has("OES_texture_float");
                    return {
                        isWebGL2: a,
                        drawBuffers: l,
                        getMaxAnisotropy: function () {
                            if (void 0 !== i) return i;
                            if (
                                !0 === e.has("EXT_texture_filter_anisotropic")
                            ) {
                                const n = e.get(
                                    "EXT_texture_filter_anisotropic",
                                );
                                i = t.getParameter(
                                    n.MAX_TEXTURE_MAX_ANISOTROPY_EXT,
                                );
                            } else i = 0;
                            return i;
                        },
                        getMaxPrecision: r,
                        precision: s,
                        logarithmicDepthBuffer: c,
                        maxTextures: h,
                        maxVertexTextures: u,
                        maxTextureSize: d,
                        maxCubemapSize: p,
                        maxAttributes: f,
                        maxVertexUniforms: m,
                        maxVaryings: g,
                        maxFragmentUniforms: v,
                        vertexTextures: x,
                        floatFragmentTextures: b,
                        floatVertexTextures: x && b,
                        maxSamples: a ? t.getParameter(36183) : 0,
                    };
                }
                function Bn(t) {
                    const e = this;
                    let n = null,
                        i = 0,
                        r = !1,
                        a = !1;
                    const s = new Rn(),
                        o = new J(),
                        l = { value: null, needsUpdate: !1 };
                    function c() {
                        l.value !== n &&
                            ((l.value = n), (l.needsUpdate = i > 0)),
                            (e.numPlanes = i),
                            (e.numIntersection = 0);
                    }
                    function h(t, n, i, r) {
                        const a = null !== t ? t.length : 0;
                        let c = null;
                        if (0 !== a) {
                            if (((c = l.value), !0 !== r || null === c)) {
                                const e = i + 4 * a,
                                    r = n.matrixWorldInverse;
                                o.getNormalMatrix(r),
                                    (null === c || c.length < e) &&
                                        (c = new Float32Array(e));
                                for (let e = 0, n = i; e !== a; ++e, n += 4)
                                    s.copy(t[e]).applyMatrix4(r, o),
                                        s.normal.toArray(c, n),
                                        (c[n + 3] = s.constant);
                            }
                            (l.value = c), (l.needsUpdate = !0);
                        }
                        return (e.numPlanes = a), (e.numIntersection = 0), c;
                    }
                    (this.uniform = l),
                        (this.numPlanes = 0),
                        (this.numIntersection = 0),
                        (this.init = function (t, e, a) {
                            const s = 0 !== t.length || e || 0 !== i || r;
                            return (r = e), (n = h(t, a, 0)), (i = t.length), s;
                        }),
                        (this.beginShadows = function () {
                            (a = !0), h(null);
                        }),
                        (this.endShadows = function () {
                            (a = !1), c();
                        }),
                        (this.setState = function (e, s, o) {
                            const u = e.clippingPlanes,
                                d = e.clipIntersection,
                                p = e.clipShadows,
                                f = t.get(e);
                            if (!r || null === u || 0 === u.length || (a && !p))
                                a ? h(null) : c();
                            else {
                                const t = a ? 0 : i,
                                    e = 4 * t;
                                let r = f.clippingState || null;
                                (l.value = r), (r = h(u, s, e, o));
                                for (let t = 0; t !== e; ++t) r[t] = n[t];
                                (f.clippingState = r),
                                    (this.numIntersection = d
                                        ? this.numPlanes
                                        : 0),
                                    (this.numPlanes += t);
                            }
                        });
                }
                function zn(t) {
                    let e = new WeakMap();
                    function r(t, e) {
                        return (
                            303 === e
                                ? (t.mapping = n)
                                : 304 === e && (t.mapping = i),
                            t
                        );
                    }
                    function a(t) {
                        const n = t.target;
                        n.removeEventListener("dispose", a);
                        const i = e.get(n);
                        void 0 !== i && (e.delete(n), i.dispose());
                    }
                    return {
                        get: function (n) {
                            if (
                                n &&
                                n.isTexture &&
                                !1 === n.isRenderTargetTexture
                            ) {
                                const i = n.mapping;
                                if (303 === i || 304 === i) {
                                    if (e.has(n))
                                        return r(e.get(n).texture, n.mapping);
                                    {
                                        const i = n.image;
                                        if (i && i.height > 0) {
                                            const s = new _n(i.height / 2);
                                            return (
                                                s.fromEquirectangularTexture(
                                                    t,
                                                    n,
                                                ),
                                                e.set(n, s),
                                                n.addEventListener(
                                                    "dispose",
                                                    a,
                                                ),
                                                r(s.texture, n.mapping)
                                            );
                                        }
                                        return null;
                                    }
                                }
                            }
                            return n;
                        },
                        dispose: function () {
                            e = new WeakMap();
                        },
                    };
                }
                class Wn extends bn {
                    constructor(
                        t = -1,
                        e = 1,
                        n = 1,
                        i = -1,
                        r = 0.1,
                        a = 2e3,
                    ) {
                        super(),
                            (this.isOrthographicCamera = !0),
                            (this.type = "OrthographicCamera"),
                            (this.zoom = 1),
                            (this.view = null),
                            (this.left = t),
                            (this.right = e),
                            (this.top = n),
                            (this.bottom = i),
                            (this.near = r),
                            (this.far = a),
                            this.updateProjectionMatrix();
                    }
                    copy(t, e) {
                        return (
                            super.copy(t, e),
                            (this.left = t.left),
                            (this.right = t.right),
                            (this.top = t.top),
                            (this.bottom = t.bottom),
                            (this.near = t.near),
                            (this.far = t.far),
                            (this.zoom = t.zoom),
                            (this.view =
                                null === t.view
                                    ? null
                                    : Object.assign({}, t.view)),
                            this
                        );
                    }
                    setViewOffset(t, e, n, i, r, a) {
                        null === this.view &&
                            (this.view = {
                                enabled: !0,
                                fullWidth: 1,
                                fullHeight: 1,
                                offsetX: 0,
                                offsetY: 0,
                                width: 1,
                                height: 1,
                            }),
                            (this.view.enabled = !0),
                            (this.view.fullWidth = t),
                            (this.view.fullHeight = e),
                            (this.view.offsetX = n),
                            (this.view.offsetY = i),
                            (this.view.width = r),
                            (this.view.height = a),
                            this.updateProjectionMatrix();
                    }
                    clearViewOffset() {
                        null !== this.view && (this.view.enabled = !1),
                            this.updateProjectionMatrix();
                    }
                    updateProjectionMatrix() {
                        const t = (this.right - this.left) / (2 * this.zoom),
                            e = (this.top - this.bottom) / (2 * this.zoom),
                            n = (this.right + this.left) / 2,
                            i = (this.top + this.bottom) / 2;
                        let r = n - t,
                            a = n + t,
                            s = i + e,
                            o = i - e;
                        if (null !== this.view && this.view.enabled) {
                            const t =
                                    (this.right - this.left) /
                                    this.view.fullWidth /
                                    this.zoom,
                                e =
                                    (this.top - this.bottom) /
                                    this.view.fullHeight /
                                    this.zoom;
                            (r += t * this.view.offsetX),
                                (a = r + t * this.view.width),
                                (s -= e * this.view.offsetY),
                                (o = s - e * this.view.height);
                        }
                        this.projectionMatrix.makeOrthographic(
                            r,
                            a,
                            s,
                            o,
                            this.near,
                            this.far,
                        ),
                            this.projectionMatrixInverse
                                .copy(this.projectionMatrix)
                                .invert();
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return (
                            (e.object.zoom = this.zoom),
                            (e.object.left = this.left),
                            (e.object.right = this.right),
                            (e.object.top = this.top),
                            (e.object.bottom = this.bottom),
                            (e.object.near = this.near),
                            (e.object.far = this.far),
                            null !== this.view &&
                                (e.object.view = Object.assign({}, this.view)),
                            e
                        );
                    }
                }
                const qn = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
                    Yn = new Wn(),
                    Kn = new ct();
                let Jn = null;
                const Zn = (1 + Math.sqrt(5)) / 2,
                    Xn = 1 / Zn,
                    Qn = [
                        new St(1, 1, 1),
                        new St(-1, 1, 1),
                        new St(1, 1, -1),
                        new St(-1, 1, -1),
                        new St(0, Zn, Xn),
                        new St(0, Zn, -Xn),
                        new St(Xn, 0, Zn),
                        new St(-Xn, 0, Zn),
                        new St(Zn, Xn, 0),
                        new St(-Zn, Xn, 0),
                    ];
                class $n {
                    constructor(t) {
                        (this._renderer = t),
                            (this._pingPongRenderTarget = null),
                            (this._lodMax = 0),
                            (this._cubeSize = 0),
                            (this._lodPlanes = []),
                            (this._sizeLods = []),
                            (this._sigmas = []),
                            (this._blurMaterial = null),
                            (this._cubemapMaterial = null),
                            (this._equirectMaterial = null),
                            this._compileMaterial(this._blurMaterial);
                    }
                    fromScene(t, e = 0, n = 0.1, i = 100) {
                        (Jn = this._renderer.getRenderTarget()),
                            this._setSize(256);
                        const r = this._allocateTargets();
                        return (
                            (r.depthBuffer = !0),
                            this._sceneToCubeUV(t, n, i, r),
                            e > 0 && this._blur(r, 0, 0, e),
                            this._applyPMREM(r),
                            this._cleanup(r),
                            r
                        );
                    }
                    fromEquirectangular(t, e = null) {
                        return this._fromTexture(t, e);
                    }
                    fromCubemap(t, e = null) {
                        return this._fromTexture(t, e);
                    }
                    compileCubemapShader() {
                        null === this._cubemapMaterial &&
                            ((this._cubemapMaterial = ii()),
                            this._compileMaterial(this._cubemapMaterial));
                    }
                    compileEquirectangularShader() {
                        null === this._equirectMaterial &&
                            ((this._equirectMaterial = ni()),
                            this._compileMaterial(this._equirectMaterial));
                    }
                    dispose() {
                        this._dispose(),
                            null !== this._cubemapMaterial &&
                                this._cubemapMaterial.dispose(),
                            null !== this._equirectMaterial &&
                                this._equirectMaterial.dispose();
                    }
                    _setSize(t) {
                        (this._lodMax = Math.floor(Math.log2(t))),
                            (this._cubeSize = Math.pow(2, this._lodMax));
                    }
                    _dispose() {
                        null !== this._blurMaterial &&
                            this._blurMaterial.dispose(),
                            null !== this._pingPongRenderTarget &&
                                this._pingPongRenderTarget.dispose();
                        for (let t = 0; t < this._lodPlanes.length; t++)
                            this._lodPlanes[t].dispose();
                    }
                    _cleanup(t) {
                        this._renderer.setRenderTarget(Jn),
                            (t.scissorTest = !1),
                            ei(t, 0, 0, t.width, t.height);
                    }
                    _fromTexture(t, e) {
                        t.mapping === n || t.mapping === i
                            ? this._setSize(
                                  0 === t.image.length
                                      ? 16
                                      : t.image[0].width ||
                                            t.image[0].image.width,
                              )
                            : this._setSize(t.image.width / 4),
                            (Jn = this._renderer.getRenderTarget());
                        const r = e || this._allocateTargets();
                        return (
                            this._textureToCubeUV(t, r),
                            this._applyPMREM(r),
                            this._cleanup(r),
                            r
                        );
                    }
                    _allocateTargets() {
                        const t = 3 * Math.max(this._cubeSize, 112),
                            e = 4 * this._cubeSize,
                            n = {
                                magFilter: h,
                                minFilter: h,
                                generateMipmaps: !1,
                                type: m,
                                format: v,
                                encoding: C,
                                depthBuffer: !1,
                            },
                            i = ti(t, e, n);
                        if (
                            null === this._pingPongRenderTarget ||
                            this._pingPongRenderTarget.width !== t
                        ) {
                            null !== this._pingPongRenderTarget &&
                                this._dispose(),
                                (this._pingPongRenderTarget = ti(t, e, n));
                            const { _lodMax: i } = this;
                            ({
                                sizeLods: this._sizeLods,
                                lodPlanes: this._lodPlanes,
                                sigmas: this._sigmas,
                            } = (function (t) {
                                const e = [],
                                    n = [],
                                    i = [];
                                let r = t;
                                const a = t - 4 + 1 + qn.length;
                                for (let s = 0; s < a; s++) {
                                    const a = Math.pow(2, r);
                                    n.push(a);
                                    let o = 1 / a;
                                    s > t - 4
                                        ? (o = qn[s - t + 4 - 1])
                                        : 0 === s && (o = 0),
                                        i.push(o);
                                    const l = 1 / (a - 2),
                                        c = -l,
                                        h = 1 + l,
                                        u = [
                                            c,
                                            c,
                                            h,
                                            c,
                                            h,
                                            h,
                                            c,
                                            c,
                                            h,
                                            h,
                                            c,
                                            h,
                                        ],
                                        d = 6,
                                        p = 6,
                                        f = 3,
                                        m = 2,
                                        g = 1,
                                        v = new Float32Array(f * p * d),
                                        x = new Float32Array(m * p * d),
                                        b = new Float32Array(g * p * d);
                                    for (let t = 0; t < d; t++) {
                                        const e = ((t % 3) * 2) / 3 - 1,
                                            n = t > 2 ? 0 : -1,
                                            i = [
                                                e,
                                                n,
                                                0,
                                                e + 2 / 3,
                                                n,
                                                0,
                                                e + 2 / 3,
                                                n + 1,
                                                0,
                                                e,
                                                n,
                                                0,
                                                e + 2 / 3,
                                                n + 1,
                                                0,
                                                e,
                                                n + 1,
                                                0,
                                            ];
                                        v.set(i, f * p * t),
                                            x.set(u, m * p * t);
                                        const r = [t, t, t, t, t, t];
                                        b.set(r, g * p * t);
                                    }
                                    const y = new Ze();
                                    y.setAttribute("position", new Ge(v, f)),
                                        y.setAttribute("uv", new Ge(x, m)),
                                        y.setAttribute(
                                            "faceIndex",
                                            new Ge(b, g),
                                        ),
                                        e.push(y),
                                        r > 4 && r--;
                                }
                                return { lodPlanes: e, sizeLods: n, sigmas: i };
                            })(i)),
                                (this._blurMaterial = (function (t, e, n) {
                                    const i = new Float32Array(20),
                                        r = new St(0, 1, 0);
                                    return new xn({
                                        name: "SphericalGaussianBlur",
                                        defines: {
                                            n: 20,
                                            CUBEUV_TEXEL_WIDTH: 1 / e,
                                            CUBEUV_TEXEL_HEIGHT: 1 / n,
                                            CUBEUV_MAX_MIP: `${t}.0`,
                                        },
                                        uniforms: {
                                            envMap: { value: null },
                                            samples: { value: 1 },
                                            weights: { value: i },
                                            latitudinal: { value: !1 },
                                            dTheta: { value: 0 },
                                            mipInt: { value: 0 },
                                            poleAxis: { value: r },
                                        },
                                        vertexShader:
                                            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                                        fragmentShader:
                                            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                                        blending: 0,
                                        depthTest: !1,
                                        depthWrite: !1,
                                    });
                                })(i, t, e));
                        }
                        return i;
                    }
                    _compileMaterial(t) {
                        const e = new un(this._lodPlanes[0], t);
                        this._renderer.compile(e, Yn);
                    }
                    _sceneToCubeUV(t, e, n, i) {
                        const r = new yn(90, 1, e, n),
                            a = [1, -1, 1, 1, 1, 1],
                            s = [1, 1, 1, -1, -1, -1],
                            o = this._renderer,
                            l = o.autoClear,
                            c = o.toneMapping;
                        o.getClearColor(Kn),
                            (o.toneMapping = 0),
                            (o.autoClear = !1);
                        const h = new Ue({
                                name: "PMREM.Background",
                                side: 1,
                                depthWrite: !1,
                                depthTest: !1,
                            }),
                            u = new un(new pn(), h);
                        let d = !1;
                        const p = t.background;
                        p
                            ? p.isColor &&
                              (h.color.copy(p), (t.background = null), (d = !0))
                            : (h.color.copy(Kn), (d = !0));
                        for (let e = 0; e < 6; e++) {
                            const n = e % 3;
                            0 === n
                                ? (r.up.set(0, a[e], 0), r.lookAt(s[e], 0, 0))
                                : 1 === n
                                ? (r.up.set(0, 0, a[e]), r.lookAt(0, s[e], 0))
                                : (r.up.set(0, a[e], 0), r.lookAt(0, 0, s[e]));
                            const l = this._cubeSize;
                            ei(i, n * l, e > 2 ? l : 0, l, l),
                                o.setRenderTarget(i),
                                d && o.render(u, r),
                                o.render(t, r);
                        }
                        u.geometry.dispose(),
                            u.material.dispose(),
                            (o.toneMapping = c),
                            (o.autoClear = l),
                            (t.background = p);
                    }
                    _textureToCubeUV(t, e) {
                        const r = this._renderer,
                            a = t.mapping === n || t.mapping === i;
                        a
                            ? (null === this._cubemapMaterial &&
                                  (this._cubemapMaterial = ii()),
                              (this._cubemapMaterial.uniforms.flipEnvMap.value =
                                  !1 === t.isRenderTargetTexture ? -1 : 1))
                            : null === this._equirectMaterial &&
                              (this._equirectMaterial = ni());
                        const s = a
                                ? this._cubemapMaterial
                                : this._equirectMaterial,
                            o = new un(this._lodPlanes[0], s);
                        s.uniforms.envMap.value = t;
                        const l = this._cubeSize;
                        ei(e, 0, 0, 3 * l, 2 * l),
                            r.setRenderTarget(e),
                            r.render(o, Yn);
                    }
                    _applyPMREM(t) {
                        const e = this._renderer,
                            n = e.autoClear;
                        e.autoClear = !1;
                        for (let e = 1; e < this._lodPlanes.length; e++) {
                            const n = Math.sqrt(
                                    this._sigmas[e] * this._sigmas[e] -
                                        this._sigmas[e - 1] *
                                            this._sigmas[e - 1],
                                ),
                                i = Qn[(e - 1) % Qn.length];
                            this._blur(t, e - 1, e, n, i);
                        }
                        e.autoClear = n;
                    }
                    _blur(t, e, n, i, r) {
                        const a = this._pingPongRenderTarget;
                        this._halfBlur(t, a, e, n, i, "latitudinal", r),
                            this._halfBlur(a, t, n, n, i, "longitudinal", r);
                    }
                    _halfBlur(t, e, n, i, r, a, s) {
                        const o = this._renderer,
                            l = this._blurMaterial;
                        "latitudinal" !== a &&
                            "longitudinal" !== a &&
                            console.error(
                                "blur direction must be either latitudinal or longitudinal!",
                            );
                        const c = new un(this._lodPlanes[i], l),
                            h = l.uniforms,
                            u = this._sizeLods[n] - 1,
                            d = isFinite(r)
                                ? Math.PI / (2 * u)
                                : (2 * Math.PI) / 39,
                            p = r / d,
                            f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                        f > 20 &&
                            console.warn(
                                `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`,
                            );
                        const m = [];
                        let g = 0;
                        for (let t = 0; t < 20; ++t) {
                            const e = t / p,
                                n = Math.exp((-e * e) / 2);
                            m.push(n),
                                0 === t ? (g += n) : t < f && (g += 2 * n);
                        }
                        for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
                        (h.envMap.value = t.texture),
                            (h.samples.value = f),
                            (h.weights.value = m),
                            (h.latitudinal.value = "latitudinal" === a),
                            s && (h.poleAxis.value = s);
                        const { _lodMax: v } = this;
                        (h.dTheta.value = d), (h.mipInt.value = v - n);
                        const x = this._sizeLods[i];
                        ei(
                            e,
                            3 * x * (i > v - 4 ? i - v + 4 : 0),
                            4 * (this._cubeSize - x),
                            3 * x,
                            2 * x,
                        ),
                            o.setRenderTarget(e),
                            o.render(c, Yn);
                    }
                }
                function ti(t, e, n) {
                    const i = new vt(t, e, n);
                    return (
                        (i.texture.mapping = r),
                        (i.texture.name = "PMREM.cubeUv"),
                        (i.scissorTest = !0),
                        i
                    );
                }
                function ei(t, e, n, i, r) {
                    t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
                }
                function ni() {
                    return new xn({
                        name: "EquirectangularToCubeUV",
                        uniforms: { envMap: { value: null } },
                        vertexShader:
                            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                        fragmentShader:
                            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1,
                    });
                }
                function ii() {
                    return new xn({
                        name: "CubemapToCubeUV",
                        uniforms: {
                            envMap: { value: null },
                            flipEnvMap: { value: -1 },
                        },
                        vertexShader:
                            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                        fragmentShader:
                            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1,
                    });
                }
                function ri(t) {
                    let e = new WeakMap(),
                        r = null;
                    function a(t) {
                        const n = t.target;
                        n.removeEventListener("dispose", a);
                        const i = e.get(n);
                        void 0 !== i && (e.delete(n), i.dispose());
                    }
                    return {
                        get: function (s) {
                            if (s && s.isTexture) {
                                const o = s.mapping,
                                    l = 303 === o || 304 === o,
                                    c = o === n || o === i;
                                if (l || c) {
                                    if (
                                        s.isRenderTargetTexture &&
                                        !0 === s.needsPMREMUpdate
                                    ) {
                                        s.needsPMREMUpdate = !1;
                                        let n = e.get(s);
                                        return (
                                            null === r && (r = new $n(t)),
                                            (n = l
                                                ? r.fromEquirectangular(s, n)
                                                : r.fromCubemap(s, n)),
                                            e.set(s, n),
                                            n.texture
                                        );
                                    }
                                    if (e.has(s)) return e.get(s).texture;
                                    {
                                        const n = s.image;
                                        if (
                                            (l && n && n.height > 0) ||
                                            (c &&
                                                n &&
                                                (function (t) {
                                                    let e = 0;
                                                    for (let n = 0; n < 6; n++)
                                                        void 0 !== t[n] && e++;
                                                    return 6 === e;
                                                })(n))
                                        ) {
                                            null === r && (r = new $n(t));
                                            const n = l
                                                ? r.fromEquirectangular(s)
                                                : r.fromCubemap(s);
                                            return (
                                                e.set(s, n),
                                                s.addEventListener(
                                                    "dispose",
                                                    a,
                                                ),
                                                n.texture
                                            );
                                        }
                                        return null;
                                    }
                                }
                            }
                            return s;
                        },
                        dispose: function () {
                            (e = new WeakMap()),
                                null !== r && (r.dispose(), (r = null));
                        },
                    };
                }
                function ai(t) {
                    const e = {};
                    function n(n) {
                        if (void 0 !== e[n]) return e[n];
                        let i;
                        switch (n) {
                            case "WEBGL_depth_texture":
                                i =
                                    t.getExtension("WEBGL_depth_texture") ||
                                    t.getExtension("MOZ_WEBGL_depth_texture") ||
                                    t.getExtension(
                                        "WEBKIT_WEBGL_depth_texture",
                                    );
                                break;
                            case "EXT_texture_filter_anisotropic":
                                i =
                                    t.getExtension(
                                        "EXT_texture_filter_anisotropic",
                                    ) ||
                                    t.getExtension(
                                        "MOZ_EXT_texture_filter_anisotropic",
                                    ) ||
                                    t.getExtension(
                                        "WEBKIT_EXT_texture_filter_anisotropic",
                                    );
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                i =
                                    t.getExtension(
                                        "WEBGL_compressed_texture_s3tc",
                                    ) ||
                                    t.getExtension(
                                        "MOZ_WEBGL_compressed_texture_s3tc",
                                    ) ||
                                    t.getExtension(
                                        "WEBKIT_WEBGL_compressed_texture_s3tc",
                                    );
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                i =
                                    t.getExtension(
                                        "WEBGL_compressed_texture_pvrtc",
                                    ) ||
                                    t.getExtension(
                                        "WEBKIT_WEBGL_compressed_texture_pvrtc",
                                    );
                                break;
                            default:
                                i = t.getExtension(n);
                        }
                        return (e[n] = i), i;
                    }
                    return {
                        has: function (t) {
                            return null !== n(t);
                        },
                        init: function (t) {
                            t.isWebGL2
                                ? n("EXT_color_buffer_float")
                                : (n("WEBGL_depth_texture"),
                                  n("OES_texture_float"),
                                  n("OES_texture_half_float"),
                                  n("OES_texture_half_float_linear"),
                                  n("OES_standard_derivatives"),
                                  n("OES_element_index_uint"),
                                  n("OES_vertex_array_object"),
                                  n("ANGLE_instanced_arrays")),
                                n("OES_texture_float_linear"),
                                n("EXT_color_buffer_half_float"),
                                n("WEBGL_multisampled_render_to_texture");
                        },
                        get: function (t) {
                            const e = n(t);
                            return (
                                null === e &&
                                    console.warn(
                                        "THREE.WebGLRenderer: " +
                                            t +
                                            " extension not supported.",
                                    ),
                                e
                            );
                        },
                    };
                }
                function si(t, e, n, i) {
                    const r = {},
                        a = new WeakMap();
                    function s(t) {
                        const o = t.target;
                        null !== o.index && e.remove(o.index);
                        for (const t in o.attributes) e.remove(o.attributes[t]);
                        o.removeEventListener("dispose", s), delete r[o.id];
                        const l = a.get(o);
                        l && (e.remove(l), a.delete(o)),
                            i.releaseStatesOfGeometry(o),
                            !0 === o.isInstancedBufferGeometry &&
                                delete o._maxInstanceCount,
                            n.memory.geometries--;
                    }
                    function o(t) {
                        const n = [],
                            i = t.index,
                            r = t.attributes.position;
                        let s = 0;
                        if (null !== i) {
                            const t = i.array;
                            s = i.version;
                            for (let e = 0, i = t.length; e < i; e += 3) {
                                const i = t[e + 0],
                                    r = t[e + 1],
                                    a = t[e + 2];
                                n.push(i, r, r, a, a, i);
                            }
                        } else {
                            const t = r.array;
                            s = r.version;
                            for (
                                let e = 0, i = t.length / 3 - 1;
                                e < i;
                                e += 3
                            ) {
                                const t = e + 0,
                                    i = e + 1,
                                    r = e + 2;
                                n.push(t, i, i, r, r, t);
                            }
                        }
                        const o = new (X(n) ? He : je)(n, 1);
                        o.version = s;
                        const l = a.get(t);
                        l && e.remove(l), a.set(t, o);
                    }
                    return {
                        get: function (t, e) {
                            return (
                                !0 === r[e.id] ||
                                    (e.addEventListener("dispose", s),
                                    (r[e.id] = !0),
                                    n.memory.geometries++),
                                e
                            );
                        },
                        update: function (t) {
                            const n = t.attributes;
                            for (const t in n) e.update(n[t], 34962);
                            const i = t.morphAttributes;
                            for (const t in i) {
                                const n = i[t];
                                for (let t = 0, i = n.length; t < i; t++)
                                    e.update(n[t], 34962);
                            }
                        },
                        getWireframeAttribute: function (t) {
                            const e = a.get(t);
                            if (e) {
                                const n = t.index;
                                null !== n && e.version < n.version && o(t);
                            } else o(t);
                            return a.get(t);
                        },
                    };
                }
                function oi(t, e, n, i) {
                    const r = i.isWebGL2;
                    let a, s, o;
                    (this.setMode = function (t) {
                        a = t;
                    }),
                        (this.setIndex = function (t) {
                            (s = t.type), (o = t.bytesPerElement);
                        }),
                        (this.render = function (e, i) {
                            t.drawElements(a, i, s, e * o), n.update(i, a, 1);
                        }),
                        (this.renderInstances = function (i, l, c) {
                            if (0 === c) return;
                            let h, u;
                            if (r) (h = t), (u = "drawElementsInstanced");
                            else if (
                                ((h = e.get("ANGLE_instanced_arrays")),
                                (u = "drawElementsInstancedANGLE"),
                                null === h)
                            )
                                return void console.error(
                                    "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
                                );
                            h[u](a, l, s, i * o, c), n.update(l, a, c);
                        });
                }
                function li(t) {
                    const e = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0,
                    };
                    return {
                        memory: { geometries: 0, textures: 0 },
                        render: e,
                        programs: null,
                        autoReset: !0,
                        reset: function () {
                            e.frame++,
                                (e.calls = 0),
                                (e.triangles = 0),
                                (e.points = 0),
                                (e.lines = 0);
                        },
                        update: function (t, n, i) {
                            switch ((e.calls++, n)) {
                                case 4:
                                    e.triangles += i * (t / 3);
                                    break;
                                case 1:
                                    e.lines += i * (t / 2);
                                    break;
                                case 3:
                                    e.lines += i * (t - 1);
                                    break;
                                case 2:
                                    e.lines += i * t;
                                    break;
                                case 0:
                                    e.points += i * t;
                                    break;
                                default:
                                    console.error(
                                        "THREE.WebGLInfo: Unknown draw mode:",
                                        n,
                                    );
                            }
                        },
                    };
                }
                function ci(t, e) {
                    return t[0] - e[0];
                }
                function hi(t, e) {
                    return Math.abs(e[1]) - Math.abs(t[1]);
                }
                function ui(t, e, n) {
                    const i = {},
                        r = new Float32Array(8),
                        a = new WeakMap(),
                        s = new gt(),
                        o = [];
                    for (let t = 0; t < 8; t++) o[t] = [t, 0];
                    return {
                        update: function (l, c, h, u) {
                            const d = l.morphTargetInfluences;
                            if (!0 === e.isWebGL2) {
                                const p =
                                        c.morphAttributes.position ||
                                        c.morphAttributes.normal ||
                                        c.morphAttributes.color,
                                    m = void 0 !== p ? p.length : 0;
                                let g = a.get(c);
                                if (void 0 === g || g.count !== m) {
                                    void 0 !== g && g.texture.dispose();
                                    const b =
                                            void 0 !==
                                            c.morphAttributes.position,
                                        y = void 0 !== c.morphAttributes.normal,
                                        S = void 0 !== c.morphAttributes.color,
                                        M = c.morphAttributes.position || [],
                                        A = c.morphAttributes.normal || [],
                                        _ = c.morphAttributes.color || [];
                                    let w = 0;
                                    !0 === b && (w = 1),
                                        !0 === y && (w = 2),
                                        !0 === S && (w = 3);
                                    let T = c.attributes.position.count * w,
                                        E = 1;
                                    T > e.maxTextureSize &&
                                        ((E = Math.ceil(T / e.maxTextureSize)),
                                        (T = e.maxTextureSize));
                                    const R = new Float32Array(T * E * 4 * m),
                                        k = new xt(R, T, E, m);
                                    (k.type = f), (k.needsUpdate = !0);
                                    const C = 4 * w;
                                    for (let I = 0; I < m; I++) {
                                        const O = M[I],
                                            D = A[I],
                                            P = _[I],
                                            U = T * E * 4 * I;
                                        for (let V = 0; V < O.count; V++) {
                                            const N = V * C;
                                            !0 === b &&
                                                (s.fromBufferAttribute(O, V),
                                                (R[U + N + 0] = s.x),
                                                (R[U + N + 1] = s.y),
                                                (R[U + N + 2] = s.z),
                                                (R[U + N + 3] = 0)),
                                                !0 === y &&
                                                    (s.fromBufferAttribute(
                                                        D,
                                                        V,
                                                    ),
                                                    (R[U + N + 4] = s.x),
                                                    (R[U + N + 5] = s.y),
                                                    (R[U + N + 6] = s.z),
                                                    (R[U + N + 7] = 0)),
                                                !0 === S &&
                                                    (s.fromBufferAttribute(
                                                        P,
                                                        V,
                                                    ),
                                                    (R[U + N + 8] = s.x),
                                                    (R[U + N + 9] = s.y),
                                                    (R[U + N + 10] = s.z),
                                                    (R[U + N + 11] =
                                                        4 === P.itemSize
                                                            ? s.w
                                                            : 1));
                                        }
                                    }
                                    function L() {
                                        k.dispose(),
                                            a.delete(c),
                                            c.removeEventListener("dispose", L);
                                    }
                                    (g = {
                                        count: m,
                                        texture: k,
                                        size: new K(T, E),
                                    }),
                                        a.set(c, g),
                                        c.addEventListener("dispose", L);
                                }
                                let v = 0;
                                for (let G = 0; G < d.length; G++) v += d[G];
                                const x = c.morphTargetsRelative ? 1 : 1 - v;
                                u
                                    .getUniforms()
                                    .setValue(t, "morphTargetBaseInfluence", x),
                                    u
                                        .getUniforms()
                                        .setValue(
                                            t,
                                            "morphTargetInfluences",
                                            d,
                                        ),
                                    u
                                        .getUniforms()
                                        .setValue(
                                            t,
                                            "morphTargetsTexture",
                                            g.texture,
                                            n,
                                        ),
                                    u
                                        .getUniforms()
                                        .setValue(
                                            t,
                                            "morphTargetsTextureSize",
                                            g.size,
                                        );
                            } else {
                                const j = void 0 === d ? 0 : d.length;
                                let H = i[c.id];
                                if (void 0 === H || H.length !== j) {
                                    H = [];
                                    for (let q = 0; q < j; q++) H[q] = [q, 0];
                                    i[c.id] = H;
                                }
                                for (let Y = 0; Y < j; Y++) {
                                    const J = H[Y];
                                    (J[0] = Y), (J[1] = d[Y]);
                                }
                                H.sort(hi);
                                for (let Z = 0; Z < 8; Z++)
                                    Z < j && H[Z][1]
                                        ? ((o[Z][0] = H[Z][0]),
                                          (o[Z][1] = H[Z][1]))
                                        : ((o[Z][0] = Number.MAX_SAFE_INTEGER),
                                          (o[Z][1] = 0));
                                o.sort(ci);
                                const F = c.morphAttributes.position,
                                    B = c.morphAttributes.normal;
                                let z = 0;
                                for (let X = 0; X < 8; X++) {
                                    const Q = o[X],
                                        $ = Q[0],
                                        tt = Q[1];
                                    $ !== Number.MAX_SAFE_INTEGER && tt
                                        ? (F &&
                                              c.getAttribute(
                                                  "morphTarget" + X,
                                              ) !== F[$] &&
                                              c.setAttribute(
                                                  "morphTarget" + X,
                                                  F[$],
                                              ),
                                          B &&
                                              c.getAttribute(
                                                  "morphNormal" + X,
                                              ) !== B[$] &&
                                              c.setAttribute(
                                                  "morphNormal" + X,
                                                  B[$],
                                              ),
                                          (r[X] = tt),
                                          (z += tt))
                                        : (F &&
                                              !0 ===
                                                  c.hasAttribute(
                                                      "morphTarget" + X,
                                                  ) &&
                                              c.deleteAttribute(
                                                  "morphTarget" + X,
                                              ),
                                          B &&
                                              !0 ===
                                                  c.hasAttribute(
                                                      "morphNormal" + X,
                                                  ) &&
                                              c.deleteAttribute(
                                                  "morphNormal" + X,
                                              ),
                                          (r[X] = 0));
                                }
                                const W = c.morphTargetsRelative ? 1 : 1 - z;
                                u
                                    .getUniforms()
                                    .setValue(t, "morphTargetBaseInfluence", W),
                                    u
                                        .getUniforms()
                                        .setValue(
                                            t,
                                            "morphTargetInfluences",
                                            r,
                                        );
                            }
                        },
                    };
                }
                function di(t, e, n, i) {
                    let r = new WeakMap();
                    function a(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", a),
                            n.remove(e.instanceMatrix),
                            null !== e.instanceColor &&
                                n.remove(e.instanceColor);
                    }
                    return {
                        update: function (t) {
                            const s = i.render.frame,
                                o = t.geometry,
                                l = e.get(t, o);
                            return (
                                r.get(l) !== s && (e.update(l), r.set(l, s)),
                                t.isInstancedMesh &&
                                    (!1 === t.hasEventListener("dispose", a) &&
                                        t.addEventListener("dispose", a),
                                    n.update(t.instanceMatrix, 34962),
                                    null !== t.instanceColor &&
                                        n.update(t.instanceColor, 34962)),
                                l
                            );
                        },
                        dispose: function () {
                            r = new WeakMap();
                        },
                    };
                }
                const pi = new mt(),
                    fi = new xt(),
                    mi = new bt(),
                    gi = new An(),
                    vi = [],
                    xi = [],
                    bi = new Float32Array(16),
                    yi = new Float32Array(9),
                    Si = new Float32Array(4);
                function Mi(t, e, n) {
                    const i = t[0];
                    if (i <= 0 || i > 0) return t;
                    const r = e * n;
                    let a = vi[r];
                    if (
                        (void 0 === a &&
                            ((a = new Float32Array(r)), (vi[r] = a)),
                        0 !== e)
                    ) {
                        i.toArray(a, 0);
                        for (let i = 1, r = 0; i !== e; ++i)
                            (r += n), t[i].toArray(a, r);
                    }
                    return a;
                }
                function Ai(t, e) {
                    if (t.length !== e.length) return !1;
                    for (let n = 0, i = t.length; n < i; n++)
                        if (t[n] !== e[n]) return !1;
                    return !0;
                }
                function _i(t, e) {
                    for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
                }
                function wi(t, e) {
                    let n = xi[e];
                    void 0 === n && ((n = new Int32Array(e)), (xi[e] = n));
                    for (let i = 0; i !== e; ++i)
                        n[i] = t.allocateTextureUnit();
                    return n;
                }
                function Ti(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
                }
                function Ei(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x && n[1] === e.y) ||
                            (t.uniform2f(this.addr, e.x, e.y),
                            (n[0] = e.x),
                            (n[1] = e.y));
                    else {
                        if (Ai(n, e)) return;
                        t.uniform2fv(this.addr, e), _i(n, e);
                    }
                }
                function Ri(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
                            (t.uniform3f(this.addr, e.x, e.y, e.z),
                            (n[0] = e.x),
                            (n[1] = e.y),
                            (n[2] = e.z));
                    else if (void 0 !== e.r)
                        (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
                            (t.uniform3f(this.addr, e.r, e.g, e.b),
                            (n[0] = e.r),
                            (n[1] = e.g),
                            (n[2] = e.b));
                    else {
                        if (Ai(n, e)) return;
                        t.uniform3fv(this.addr, e), _i(n, e);
                    }
                }
                function ki(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x &&
                            n[1] === e.y &&
                            n[2] === e.z &&
                            n[3] === e.w) ||
                            (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
                            (n[0] = e.x),
                            (n[1] = e.y),
                            (n[2] = e.z),
                            (n[3] = e.w));
                    else {
                        if (Ai(n, e)) return;
                        t.uniform4fv(this.addr, e), _i(n, e);
                    }
                }
                function Ci(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (Ai(n, e)) return;
                        t.uniformMatrix2fv(this.addr, !1, e), _i(n, e);
                    } else {
                        if (Ai(n, i)) return;
                        Si.set(i),
                            t.uniformMatrix2fv(this.addr, !1, Si),
                            _i(n, i);
                    }
                }
                function Li(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (Ai(n, e)) return;
                        t.uniformMatrix3fv(this.addr, !1, e), _i(n, e);
                    } else {
                        if (Ai(n, i)) return;
                        yi.set(i),
                            t.uniformMatrix3fv(this.addr, !1, yi),
                            _i(n, i);
                    }
                }
                function Ii(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (Ai(n, e)) return;
                        t.uniformMatrix4fv(this.addr, !1, e), _i(n, e);
                    } else {
                        if (Ai(n, i)) return;
                        bi.set(i),
                            t.uniformMatrix4fv(this.addr, !1, bi),
                            _i(n, i);
                    }
                }
                function Oi(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
                }
                function Di(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x && n[1] === e.y) ||
                            (t.uniform2i(this.addr, e.x, e.y),
                            (n[0] = e.x),
                            (n[1] = e.y));
                    else {
                        if (Ai(n, e)) return;
                        t.uniform2iv(this.addr, e), _i(n, e);
                    }
                }
                function Pi(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
                            (t.uniform3i(this.addr, e.x, e.y, e.z),
                            (n[0] = e.x),
                            (n[1] = e.y),
                            (n[2] = e.z));
                    else {
                        if (Ai(n, e)) return;
                        t.uniform3iv(this.addr, e), _i(n, e);
                    }
                }
                function Ui(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x &&
                            n[1] === e.y &&
                            n[2] === e.z &&
                            n[3] === e.w) ||
                            (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
                            (n[0] = e.x),
                            (n[1] = e.y),
                            (n[2] = e.z),
                            (n[3] = e.w));
                    else {
                        if (Ai(n, e)) return;
                        t.uniform4iv(this.addr, e), _i(n, e);
                    }
                }
                function Vi(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
                }
                function Ni(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x && n[1] === e.y) ||
                            (t.uniform2ui(this.addr, e.x, e.y),
                            (n[0] = e.x),
                            (n[1] = e.y));
                    else {
                        if (Ai(n, e)) return;
                        t.uniform2uiv(this.addr, e), _i(n, e);
                    }
                }
                function Gi(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
                            (t.uniform3ui(this.addr, e.x, e.y, e.z),
                            (n[0] = e.x),
                            (n[1] = e.y),
                            (n[2] = e.z));
                    else {
                        if (Ai(n, e)) return;
                        t.uniform3uiv(this.addr, e), _i(n, e);
                    }
                }
                function ji(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x &&
                            n[1] === e.y &&
                            n[2] === e.z &&
                            n[3] === e.w) ||
                            (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
                            (n[0] = e.x),
                            (n[1] = e.y),
                            (n[2] = e.z),
                            (n[3] = e.w));
                    else {
                        if (Ai(n, e)) return;
                        t.uniform4uiv(this.addr, e), _i(n, e);
                    }
                }
                function Hi(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
                        n.setTexture2D(e || pi, r);
                }
                function Fi(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
                        n.setTexture3D(e || mi, r);
                }
                function Bi(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
                        n.setTextureCube(e || gi, r);
                }
                function zi(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
                        n.setTexture2DArray(e || fi, r);
                }
                function Wi(t, e) {
                    t.uniform1fv(this.addr, e);
                }
                function qi(t, e) {
                    const n = Mi(e, this.size, 2);
                    t.uniform2fv(this.addr, n);
                }
                function Yi(t, e) {
                    const n = Mi(e, this.size, 3);
                    t.uniform3fv(this.addr, n);
                }
                function Ki(t, e) {
                    const n = Mi(e, this.size, 4);
                    t.uniform4fv(this.addr, n);
                }
                function Ji(t, e) {
                    const n = Mi(e, this.size, 4);
                    t.uniformMatrix2fv(this.addr, !1, n);
                }
                function Zi(t, e) {
                    const n = Mi(e, this.size, 9);
                    t.uniformMatrix3fv(this.addr, !1, n);
                }
                function Xi(t, e) {
                    const n = Mi(e, this.size, 16);
                    t.uniformMatrix4fv(this.addr, !1, n);
                }
                function Qi(t, e) {
                    t.uniform1iv(this.addr, e);
                }
                function $i(t, e) {
                    t.uniform2iv(this.addr, e);
                }
                function tr(t, e) {
                    t.uniform3iv(this.addr, e);
                }
                function er(t, e) {
                    t.uniform4iv(this.addr, e);
                }
                function nr(t, e) {
                    t.uniform1uiv(this.addr, e);
                }
                function ir(t, e) {
                    t.uniform2uiv(this.addr, e);
                }
                function rr(t, e) {
                    t.uniform3uiv(this.addr, e);
                }
                function ar(t, e) {
                    t.uniform4uiv(this.addr, e);
                }
                function sr(t, e, n) {
                    const i = this.cache,
                        r = e.length,
                        a = wi(n, r);
                    Ai(i, a) || (t.uniform1iv(this.addr, a), _i(i, a));
                    for (let t = 0; t !== r; ++t)
                        n.setTexture2D(e[t] || pi, a[t]);
                }
                function or(t, e, n) {
                    const i = this.cache,
                        r = e.length,
                        a = wi(n, r);
                    Ai(i, a) || (t.uniform1iv(this.addr, a), _i(i, a));
                    for (let t = 0; t !== r; ++t)
                        n.setTexture3D(e[t] || mi, a[t]);
                }
                function lr(t, e, n) {
                    const i = this.cache,
                        r = e.length,
                        a = wi(n, r);
                    Ai(i, a) || (t.uniform1iv(this.addr, a), _i(i, a));
                    for (let t = 0; t !== r; ++t)
                        n.setTextureCube(e[t] || gi, a[t]);
                }
                function cr(t, e, n) {
                    const i = this.cache,
                        r = e.length,
                        a = wi(n, r);
                    Ai(i, a) || (t.uniform1iv(this.addr, a), _i(i, a));
                    for (let t = 0; t !== r; ++t)
                        n.setTexture2DArray(e[t] || fi, a[t]);
                }
                class hr {
                    constructor(t, e, n) {
                        (this.id = t),
                            (this.addr = n),
                            (this.cache = []),
                            (this.setValue = (function (t) {
                                switch (t) {
                                    case 5126:
                                        return Ti;
                                    case 35664:
                                        return Ei;
                                    case 35665:
                                        return Ri;
                                    case 35666:
                                        return ki;
                                    case 35674:
                                        return Ci;
                                    case 35675:
                                        return Li;
                                    case 35676:
                                        return Ii;
                                    case 5124:
                                    case 35670:
                                        return Oi;
                                    case 35667:
                                    case 35671:
                                        return Di;
                                    case 35668:
                                    case 35672:
                                        return Pi;
                                    case 35669:
                                    case 35673:
                                        return Ui;
                                    case 5125:
                                        return Vi;
                                    case 36294:
                                        return Ni;
                                    case 36295:
                                        return Gi;
                                    case 36296:
                                        return ji;
                                    case 35678:
                                    case 36198:
                                    case 36298:
                                    case 36306:
                                    case 35682:
                                        return Hi;
                                    case 35679:
                                    case 36299:
                                    case 36307:
                                        return Fi;
                                    case 35680:
                                    case 36300:
                                    case 36308:
                                    case 36293:
                                        return Bi;
                                    case 36289:
                                    case 36303:
                                    case 36311:
                                    case 36292:
                                        return zi;
                                }
                            })(e.type));
                    }
                }
                class ur {
                    constructor(t, e, n) {
                        (this.id = t),
                            (this.addr = n),
                            (this.cache = []),
                            (this.size = e.size),
                            (this.setValue = (function (t) {
                                switch (t) {
                                    case 5126:
                                        return Wi;
                                    case 35664:
                                        return qi;
                                    case 35665:
                                        return Yi;
                                    case 35666:
                                        return Ki;
                                    case 35674:
                                        return Ji;
                                    case 35675:
                                        return Zi;
                                    case 35676:
                                        return Xi;
                                    case 5124:
                                    case 35670:
                                        return Qi;
                                    case 35667:
                                    case 35671:
                                        return $i;
                                    case 35668:
                                    case 35672:
                                        return tr;
                                    case 35669:
                                    case 35673:
                                        return er;
                                    case 5125:
                                        return nr;
                                    case 36294:
                                        return ir;
                                    case 36295:
                                        return rr;
                                    case 36296:
                                        return ar;
                                    case 35678:
                                    case 36198:
                                    case 36298:
                                    case 36306:
                                    case 35682:
                                        return sr;
                                    case 35679:
                                    case 36299:
                                    case 36307:
                                        return or;
                                    case 35680:
                                    case 36300:
                                    case 36308:
                                    case 36293:
                                        return lr;
                                    case 36289:
                                    case 36303:
                                    case 36311:
                                    case 36292:
                                        return cr;
                                }
                            })(e.type));
                    }
                }
                class dr {
                    constructor(t) {
                        (this.id = t), (this.seq = []), (this.map = {});
                    }
                    setValue(t, e, n) {
                        const i = this.seq;
                        for (let r = 0, a = i.length; r !== a; ++r) {
                            const a = i[r];
                            a.setValue(t, e[a.id], n);
                        }
                    }
                }
                const pr = /(\w+)(\])?(\[|\.)?/g;
                function fr(t, e) {
                    t.seq.push(e), (t.map[e.id] = e);
                }
                function mr(t, e, n) {
                    const i = t.name,
                        r = i.length;
                    for (pr.lastIndex = 0; ; ) {
                        const a = pr.exec(i),
                            s = pr.lastIndex;
                        let o = a[1];
                        const l = "]" === a[2],
                            c = a[3];
                        if (
                            (l && (o |= 0),
                            void 0 === c || ("[" === c && s + 2 === r))
                        ) {
                            fr(
                                n,
                                void 0 === c
                                    ? new hr(o, t, e)
                                    : new ur(o, t, e),
                            );
                            break;
                        }
                        {
                            let t = n.map[o];
                            void 0 === t && ((t = new dr(o)), fr(n, t)),
                                (n = t);
                        }
                    }
                }
                class gr {
                    constructor(t, e) {
                        (this.seq = []), (this.map = {});
                        const n = t.getProgramParameter(e, 35718);
                        for (let i = 0; i < n; ++i) {
                            const n = t.getActiveUniform(e, i);
                            mr(n, t.getUniformLocation(e, n.name), this);
                        }
                    }
                    setValue(t, e, n, i) {
                        const r = this.map[e];
                        void 0 !== r && r.setValue(t, n, i);
                    }
                    setOptional(t, e, n) {
                        const i = e[n];
                        void 0 !== i && this.setValue(t, n, i);
                    }
                    static upload(t, e, n, i) {
                        for (let r = 0, a = e.length; r !== a; ++r) {
                            const a = e[r],
                                s = n[a.id];
                            !1 !== s.needsUpdate && a.setValue(t, s.value, i);
                        }
                    }
                    static seqWithValue(t, e) {
                        const n = [];
                        for (let i = 0, r = t.length; i !== r; ++i) {
                            const r = t[i];
                            r.id in e && n.push(r);
                        }
                        return n;
                    }
                }
                function vr(t, e, n) {
                    const i = t.createShader(e);
                    return t.shaderSource(i, n), t.compileShader(i), i;
                }
                let xr = 0;
                function br(t, e, n) {
                    const i = t.getShaderParameter(e, 35713),
                        r = t.getShaderInfoLog(e).trim();
                    if (i && "" === r) return "";
                    const a = /ERROR: 0:(\d+)/.exec(r);
                    if (a) {
                        const i = parseInt(a[1]);
                        return (
                            n.toUpperCase() +
                            "\n\n" +
                            r +
                            "\n\n" +
                            (function (t, e) {
                                const n = t.split("\n"),
                                    i = [],
                                    r = Math.max(e - 6, 0),
                                    a = Math.min(e + 6, n.length);
                                for (let t = r; t < a; t++) {
                                    const r = t + 1;
                                    i.push(
                                        `${r === e ? ">" : " "} ${r}: ${n[t]}`,
                                    );
                                }
                                return i.join("\n");
                            })(t.getShaderSource(e), i)
                        );
                    }
                    return r;
                }
                function yr(t, e) {
                    const n = (function (t) {
                        switch (t) {
                            case C:
                                return ["Linear", "( value )"];
                            case L:
                                return ["sRGB", "( value )"];
                            default:
                                return (
                                    console.warn(
                                        "THREE.WebGLProgram: Unsupported encoding:",
                                        t,
                                    ),
                                    ["Linear", "( value )"]
                                );
                        }
                    })(e);
                    return (
                        "vec4 " +
                        t +
                        "( vec4 value ) { return LinearTo" +
                        n[0] +
                        n[1] +
                        "; }"
                    );
                }
                function Sr(t, e) {
                    let n;
                    switch (e) {
                        case 1:
                            n = "Linear";
                            break;
                        case 2:
                            n = "Reinhard";
                            break;
                        case 3:
                            n = "OptimizedCineon";
                            break;
                        case 4:
                            n = "ACESFilmic";
                            break;
                        case 5:
                            n = "Custom";
                            break;
                        default:
                            console.warn(
                                "THREE.WebGLProgram: Unsupported toneMapping:",
                                e,
                            ),
                                (n = "Linear");
                    }
                    return (
                        "vec3 " +
                        t +
                        "( vec3 color ) { return " +
                        n +
                        "ToneMapping( color ); }"
                    );
                }
                function Mr(t) {
                    return "" !== t;
                }
                function Ar(t, e) {
                    const n =
                        e.numSpotLightShadows +
                        e.numSpotLightMaps -
                        e.numSpotLightShadowsWithMaps;
                    return t
                        .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
                        .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
                        .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
                        .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
                        .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
                        .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
                        .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
                        .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
                        .replace(
                            /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
                            e.numSpotLightShadowsWithMaps,
                        )
                        .replace(
                            /NUM_SPOT_LIGHT_SHADOWS/g,
                            e.numSpotLightShadows,
                        )
                        .replace(
                            /NUM_POINT_LIGHT_SHADOWS/g,
                            e.numPointLightShadows,
                        );
                }
                function _r(t, e) {
                    return t
                        .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
                        .replace(
                            /UNION_CLIPPING_PLANES/g,
                            e.numClippingPlanes - e.numClipIntersection,
                        );
                }
                const wr = /^[ \t]*#include +<([\w\d./]+)>/gm;
                function Tr(t) {
                    return t.replace(wr, Er);
                }
                function Er(t, e) {
                    const n = Pn[e];
                    if (void 0 === n)
                        throw new Error("Can not resolve #include <" + e + ">");
                    return Tr(n);
                }
                const Rr =
                    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
                function kr(t) {
                    return t.replace(Rr, Cr);
                }
                function Cr(t, e, n, i) {
                    let r = "";
                    for (let t = parseInt(e); t < parseInt(n); t++)
                        r += i
                            .replace(/\[\s*i\s*\]/g, "[ " + t + " ]")
                            .replace(/UNROLLED_LOOP_INDEX/g, t);
                    return r;
                }
                function Lr(t) {
                    let e =
                        "precision " +
                        t.precision +
                        " float;\nprecision " +
                        t.precision +
                        " int;";
                    return (
                        "highp" === t.precision
                            ? (e += "\n#define HIGH_PRECISION")
                            : "mediump" === t.precision
                            ? (e += "\n#define MEDIUM_PRECISION")
                            : "lowp" === t.precision &&
                              (e += "\n#define LOW_PRECISION"),
                        e
                    );
                }
                function Ir(t, e, a, s) {
                    const o = t.getContext(),
                        l = a.defines;
                    let c = a.vertexShader,
                        h = a.fragmentShader;
                    const u = (function (t) {
                            let e = "SHADOWMAP_TYPE_BASIC";
                            return (
                                1 === t.shadowMapType
                                    ? (e = "SHADOWMAP_TYPE_PCF")
                                    : 2 === t.shadowMapType
                                    ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
                                    : 3 === t.shadowMapType &&
                                      (e = "SHADOWMAP_TYPE_VSM"),
                                e
                            );
                        })(a),
                        d = (function (t) {
                            let e = "ENVMAP_TYPE_CUBE";
                            if (t.envMap)
                                switch (t.envMapMode) {
                                    case n:
                                    case i:
                                        e = "ENVMAP_TYPE_CUBE";
                                        break;
                                    case r:
                                        e = "ENVMAP_TYPE_CUBE_UV";
                                }
                            return e;
                        })(a),
                        p = (function (t) {
                            let e = "ENVMAP_MODE_REFLECTION";
                            return (
                                t.envMap &&
                                    t.envMapMode === i &&
                                    (e = "ENVMAP_MODE_REFRACTION"),
                                e
                            );
                        })(a),
                        f = (function (t) {
                            let e = "ENVMAP_BLENDING_NONE";
                            if (t.envMap)
                                switch (t.combine) {
                                    case 0:
                                        e = "ENVMAP_BLENDING_MULTIPLY";
                                        break;
                                    case 1:
                                        e = "ENVMAP_BLENDING_MIX";
                                        break;
                                    case 2:
                                        e = "ENVMAP_BLENDING_ADD";
                                }
                            return e;
                        })(a),
                        m = (function (t) {
                            const e = t.envMapCubeUVHeight;
                            if (null === e) return null;
                            const n = Math.log2(e) - 2,
                                i = 1 / e;
                            return {
                                texelWidth:
                                    1 / (3 * Math.max(Math.pow(2, n), 112)),
                                texelHeight: i,
                                maxMip: n,
                            };
                        })(a),
                        g = a.isWebGL2
                            ? ""
                            : (function (t) {
                                  return [
                                      t.extensionDerivatives ||
                                      t.envMapCubeUVHeight ||
                                      t.bumpMap ||
                                      t.tangentSpaceNormalMap ||
                                      t.clearcoatNormalMap ||
                                      t.flatShading ||
                                      "physical" === t.shaderID
                                          ? "#extension GL_OES_standard_derivatives : enable"
                                          : "",
                                      (t.extensionFragDepth ||
                                          t.logarithmicDepthBuffer) &&
                                      t.rendererExtensionFragDepth
                                          ? "#extension GL_EXT_frag_depth : enable"
                                          : "",
                                      t.extensionDrawBuffers &&
                                      t.rendererExtensionDrawBuffers
                                          ? "#extension GL_EXT_draw_buffers : require"
                                          : "",
                                      (t.extensionShaderTextureLOD ||
                                          t.envMap ||
                                          t.transmission) &&
                                      t.rendererExtensionShaderTextureLod
                                          ? "#extension GL_EXT_shader_texture_lod : enable"
                                          : "",
                                  ]
                                      .filter(Mr)
                                      .join("\n");
                              })(a),
                        v = (function (t) {
                            const e = [];
                            for (const n in t) {
                                const i = t[n];
                                !1 !== i && e.push("#define " + n + " " + i);
                            }
                            return e.join("\n");
                        })(l),
                        x = o.createProgram();
                    let b,
                        y,
                        S = a.glslVersion
                            ? "#version " + a.glslVersion + "\n"
                            : "";
                    a.isRawShaderMaterial
                        ? ((b = [v].filter(Mr).join("\n")),
                          b.length > 0 && (b += "\n"),
                          (y = [g, v].filter(Mr).join("\n")),
                          y.length > 0 && (y += "\n"))
                        : ((b = [
                              Lr(a),
                              "#define SHADER_NAME " + a.shaderName,
                              v,
                              a.instancing ? "#define USE_INSTANCING" : "",
                              a.instancingColor
                                  ? "#define USE_INSTANCING_COLOR"
                                  : "",
                              a.supportsVertexTextures
                                  ? "#define VERTEX_TEXTURES"
                                  : "",
                              a.useFog && a.fog ? "#define USE_FOG" : "",
                              a.useFog && a.fogExp2 ? "#define FOG_EXP2" : "",
                              a.map ? "#define USE_MAP" : "",
                              a.envMap ? "#define USE_ENVMAP" : "",
                              a.envMap ? "#define " + p : "",
                              a.lightMap ? "#define USE_LIGHTMAP" : "",
                              a.aoMap ? "#define USE_AOMAP" : "",
                              a.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                              a.bumpMap ? "#define USE_BUMPMAP" : "",
                              a.normalMap ? "#define USE_NORMALMAP" : "",
                              a.normalMap && a.objectSpaceNormalMap
                                  ? "#define OBJECTSPACE_NORMALMAP"
                                  : "",
                              a.normalMap && a.tangentSpaceNormalMap
                                  ? "#define TANGENTSPACE_NORMALMAP"
                                  : "",
                              a.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                              a.clearcoatRoughnessMap
                                  ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                                  : "",
                              a.clearcoatNormalMap
                                  ? "#define USE_CLEARCOAT_NORMALMAP"
                                  : "",
                              a.iridescenceMap
                                  ? "#define USE_IRIDESCENCEMAP"
                                  : "",
                              a.iridescenceThicknessMap
                                  ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                                  : "",
                              a.displacementMap && a.supportsVertexTextures
                                  ? "#define USE_DISPLACEMENTMAP"
                                  : "",
                              a.specularMap ? "#define USE_SPECULARMAP" : "",
                              a.specularIntensityMap
                                  ? "#define USE_SPECULARINTENSITYMAP"
                                  : "",
                              a.specularColorMap
                                  ? "#define USE_SPECULARCOLORMAP"
                                  : "",
                              a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                              a.metalnessMap ? "#define USE_METALNESSMAP" : "",
                              a.alphaMap ? "#define USE_ALPHAMAP" : "",
                              a.transmission ? "#define USE_TRANSMISSION" : "",
                              a.transmissionMap
                                  ? "#define USE_TRANSMISSIONMAP"
                                  : "",
                              a.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                              a.sheenColorMap
                                  ? "#define USE_SHEENCOLORMAP"
                                  : "",
                              a.sheenRoughnessMap
                                  ? "#define USE_SHEENROUGHNESSMAP"
                                  : "",
                              a.vertexTangents ? "#define USE_TANGENT" : "",
                              a.vertexColors ? "#define USE_COLOR" : "",
                              a.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                              a.vertexUvs ? "#define USE_UV" : "",
                              a.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                              a.flatShading ? "#define FLAT_SHADED" : "",
                              a.skinning ? "#define USE_SKINNING" : "",
                              a.morphTargets ? "#define USE_MORPHTARGETS" : "",
                              a.morphNormals && !1 === a.flatShading
                                  ? "#define USE_MORPHNORMALS"
                                  : "",
                              a.morphColors && a.isWebGL2
                                  ? "#define USE_MORPHCOLORS"
                                  : "",
                              a.morphTargetsCount > 0 && a.isWebGL2
                                  ? "#define MORPHTARGETS_TEXTURE"
                                  : "",
                              a.morphTargetsCount > 0 && a.isWebGL2
                                  ? "#define MORPHTARGETS_TEXTURE_STRIDE " +
                                    a.morphTextureStride
                                  : "",
                              a.morphTargetsCount > 0 && a.isWebGL2
                                  ? "#define MORPHTARGETS_COUNT " +
                                    a.morphTargetsCount
                                  : "",
                              a.doubleSided ? "#define DOUBLE_SIDED" : "",
                              a.flipSided ? "#define FLIP_SIDED" : "",
                              a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                              a.shadowMapEnabled ? "#define " + u : "",
                              a.sizeAttenuation
                                  ? "#define USE_SIZEATTENUATION"
                                  : "",
                              a.logarithmicDepthBuffer
                                  ? "#define USE_LOGDEPTHBUF"
                                  : "",
                              a.logarithmicDepthBuffer &&
                              a.rendererExtensionFragDepth
                                  ? "#define USE_LOGDEPTHBUF_EXT"
                                  : "",
                              "uniform mat4 modelMatrix;",
                              "uniform mat4 modelViewMatrix;",
                              "uniform mat4 projectionMatrix;",
                              "uniform mat4 viewMatrix;",
                              "uniform mat3 normalMatrix;",
                              "uniform vec3 cameraPosition;",
                              "uniform bool isOrthographic;",
                              "#ifdef USE_INSTANCING",
                              "\tattribute mat4 instanceMatrix;",
                              "#endif",
                              "#ifdef USE_INSTANCING_COLOR",
                              "\tattribute vec3 instanceColor;",
                              "#endif",
                              "attribute vec3 position;",
                              "attribute vec3 normal;",
                              "attribute vec2 uv;",
                              "#ifdef USE_TANGENT",
                              "\tattribute vec4 tangent;",
                              "#endif",
                              "#if defined( USE_COLOR_ALPHA )",
                              "\tattribute vec4 color;",
                              "#elif defined( USE_COLOR )",
                              "\tattribute vec3 color;",
                              "#endif",
                              "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
                              "\tattribute vec3 morphTarget0;",
                              "\tattribute vec3 morphTarget1;",
                              "\tattribute vec3 morphTarget2;",
                              "\tattribute vec3 morphTarget3;",
                              "\t#ifdef USE_MORPHNORMALS",
                              "\t\tattribute vec3 morphNormal0;",
                              "\t\tattribute vec3 morphNormal1;",
                              "\t\tattribute vec3 morphNormal2;",
                              "\t\tattribute vec3 morphNormal3;",
                              "\t#else",
                              "\t\tattribute vec3 morphTarget4;",
                              "\t\tattribute vec3 morphTarget5;",
                              "\t\tattribute vec3 morphTarget6;",
                              "\t\tattribute vec3 morphTarget7;",
                              "\t#endif",
                              "#endif",
                              "#ifdef USE_SKINNING",
                              "\tattribute vec4 skinIndex;",
                              "\tattribute vec4 skinWeight;",
                              "#endif",
                              "\n",
                          ]
                              .filter(Mr)
                              .join("\n")),
                          (y = [
                              g,
                              Lr(a),
                              "#define SHADER_NAME " + a.shaderName,
                              v,
                              a.useFog && a.fog ? "#define USE_FOG" : "",
                              a.useFog && a.fogExp2 ? "#define FOG_EXP2" : "",
                              a.map ? "#define USE_MAP" : "",
                              a.matcap ? "#define USE_MATCAP" : "",
                              a.envMap ? "#define USE_ENVMAP" : "",
                              a.envMap ? "#define " + d : "",
                              a.envMap ? "#define " + p : "",
                              a.envMap ? "#define " + f : "",
                              m
                                  ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth
                                  : "",
                              m
                                  ? "#define CUBEUV_TEXEL_HEIGHT " +
                                    m.texelHeight
                                  : "",
                              m
                                  ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0"
                                  : "",
                              a.lightMap ? "#define USE_LIGHTMAP" : "",
                              a.aoMap ? "#define USE_AOMAP" : "",
                              a.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                              a.bumpMap ? "#define USE_BUMPMAP" : "",
                              a.normalMap ? "#define USE_NORMALMAP" : "",
                              a.normalMap && a.objectSpaceNormalMap
                                  ? "#define OBJECTSPACE_NORMALMAP"
                                  : "",
                              a.normalMap && a.tangentSpaceNormalMap
                                  ? "#define TANGENTSPACE_NORMALMAP"
                                  : "",
                              a.clearcoat ? "#define USE_CLEARCOAT" : "",
                              a.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                              a.clearcoatRoughnessMap
                                  ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                                  : "",
                              a.clearcoatNormalMap
                                  ? "#define USE_CLEARCOAT_NORMALMAP"
                                  : "",
                              a.iridescence ? "#define USE_IRIDESCENCE" : "",
                              a.iridescenceMap
                                  ? "#define USE_IRIDESCENCEMAP"
                                  : "",
                              a.iridescenceThicknessMap
                                  ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                                  : "",
                              a.specularMap ? "#define USE_SPECULARMAP" : "",
                              a.specularIntensityMap
                                  ? "#define USE_SPECULARINTENSITYMAP"
                                  : "",
                              a.specularColorMap
                                  ? "#define USE_SPECULARCOLORMAP"
                                  : "",
                              a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                              a.metalnessMap ? "#define USE_METALNESSMAP" : "",
                              a.alphaMap ? "#define USE_ALPHAMAP" : "",
                              a.alphaTest ? "#define USE_ALPHATEST" : "",
                              a.sheen ? "#define USE_SHEEN" : "",
                              a.sheenColorMap
                                  ? "#define USE_SHEENCOLORMAP"
                                  : "",
                              a.sheenRoughnessMap
                                  ? "#define USE_SHEENROUGHNESSMAP"
                                  : "",
                              a.transmission ? "#define USE_TRANSMISSION" : "",
                              a.transmissionMap
                                  ? "#define USE_TRANSMISSIONMAP"
                                  : "",
                              a.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                              a.decodeVideoTexture
                                  ? "#define DECODE_VIDEO_TEXTURE"
                                  : "",
                              a.vertexTangents ? "#define USE_TANGENT" : "",
                              a.vertexColors || a.instancingColor
                                  ? "#define USE_COLOR"
                                  : "",
                              a.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                              a.vertexUvs ? "#define USE_UV" : "",
                              a.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                              a.gradientMap ? "#define USE_GRADIENTMAP" : "",
                              a.flatShading ? "#define FLAT_SHADED" : "",
                              a.doubleSided ? "#define DOUBLE_SIDED" : "",
                              a.flipSided ? "#define FLIP_SIDED" : "",
                              a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                              a.shadowMapEnabled ? "#define " + u : "",
                              a.premultipliedAlpha
                                  ? "#define PREMULTIPLIED_ALPHA"
                                  : "",
                              a.physicallyCorrectLights
                                  ? "#define PHYSICALLY_CORRECT_LIGHTS"
                                  : "",
                              a.logarithmicDepthBuffer
                                  ? "#define USE_LOGDEPTHBUF"
                                  : "",
                              a.logarithmicDepthBuffer &&
                              a.rendererExtensionFragDepth
                                  ? "#define USE_LOGDEPTHBUF_EXT"
                                  : "",
                              "uniform mat4 viewMatrix;",
                              "uniform vec3 cameraPosition;",
                              "uniform bool isOrthographic;",
                              0 !== a.toneMapping ? "#define TONE_MAPPING" : "",
                              0 !== a.toneMapping
                                  ? Pn.tonemapping_pars_fragment
                                  : "",
                              0 !== a.toneMapping
                                  ? Sr("toneMapping", a.toneMapping)
                                  : "",
                              a.dithering ? "#define DITHERING" : "",
                              a.opaque ? "#define OPAQUE" : "",
                              Pn.encodings_pars_fragment,
                              yr("linearToOutputTexel", a.outputEncoding),
                              a.useDepthPacking
                                  ? "#define DEPTH_PACKING " + a.depthPacking
                                  : "",
                              "\n",
                          ]
                              .filter(Mr)
                              .join("\n"))),
                        (c = Tr(c)),
                        (c = Ar(c, a)),
                        (c = _r(c, a)),
                        (h = Tr(h)),
                        (h = Ar(h, a)),
                        (h = _r(h, a)),
                        (c = kr(c)),
                        (h = kr(h)),
                        a.isWebGL2 &&
                            !0 !== a.isRawShaderMaterial &&
                            ((S = "#version 300 es\n"),
                            (b =
                                [
                                    "precision mediump sampler2DArray;",
                                    "#define attribute in",
                                    "#define varying out",
                                    "#define texture2D texture",
                                ].join("\n") +
                                "\n" +
                                b),
                            (y =
                                [
                                    "#define varying in",
                                    a.glslVersion === P
                                        ? ""
                                        : "layout(location = 0) out highp vec4 pc_fragColor;",
                                    a.glslVersion === P
                                        ? ""
                                        : "#define gl_FragColor pc_fragColor",
                                    "#define gl_FragDepthEXT gl_FragDepth",
                                    "#define texture2D texture",
                                    "#define textureCube texture",
                                    "#define texture2DProj textureProj",
                                    "#define texture2DLodEXT textureLod",
                                    "#define texture2DProjLodEXT textureProjLod",
                                    "#define textureCubeLodEXT textureLod",
                                    "#define texture2DGradEXT textureGrad",
                                    "#define texture2DProjGradEXT textureProjGrad",
                                    "#define textureCubeGradEXT textureGrad",
                                ].join("\n") +
                                "\n" +
                                y));
                    const M = S + y + h,
                        A = vr(o, 35633, S + b + c),
                        _ = vr(o, 35632, M);
                    if (
                        (o.attachShader(x, A),
                        o.attachShader(x, _),
                        void 0 !== a.index0AttributeName
                            ? o.bindAttribLocation(x, 0, a.index0AttributeName)
                            : !0 === a.morphTargets &&
                              o.bindAttribLocation(x, 0, "position"),
                        o.linkProgram(x),
                        t.debug.checkShaderErrors)
                    ) {
                        const t = o.getProgramInfoLog(x).trim(),
                            e = o.getShaderInfoLog(A).trim(),
                            n = o.getShaderInfoLog(_).trim();
                        let i = !0,
                            r = !0;
                        if (!1 === o.getProgramParameter(x, 35714)) {
                            i = !1;
                            const e = br(o, A, "vertex"),
                                n = br(o, _, "fragment");
                            console.error(
                                "THREE.WebGLProgram: Shader Error " +
                                    o.getError() +
                                    " - VALIDATE_STATUS " +
                                    o.getProgramParameter(x, 35715) +
                                    "\n\nProgram Info Log: " +
                                    t +
                                    "\n" +
                                    e +
                                    "\n" +
                                    n,
                            );
                        } else
                            "" !== t
                                ? console.warn(
                                      "THREE.WebGLProgram: Program Info Log:",
                                      t,
                                  )
                                : ("" !== e && "" !== n) || (r = !1);
                        r &&
                            (this.diagnostics = {
                                runnable: i,
                                programLog: t,
                                vertexShader: { log: e, prefix: b },
                                fragmentShader: { log: n, prefix: y },
                            });
                    }
                    let w, T;
                    return (
                        o.deleteShader(A),
                        o.deleteShader(_),
                        (this.getUniforms = function () {
                            return void 0 === w && (w = new gr(o, x)), w;
                        }),
                        (this.getAttributes = function () {
                            return (
                                void 0 === T &&
                                    (T = (function (t, e) {
                                        const n = {},
                                            i = t.getProgramParameter(e, 35721);
                                        for (let r = 0; r < i; r++) {
                                            const i = t.getActiveAttrib(e, r),
                                                a = i.name;
                                            let s = 1;
                                            35674 === i.type && (s = 2),
                                                35675 === i.type && (s = 3),
                                                35676 === i.type && (s = 4),
                                                (n[a] = {
                                                    type: i.type,
                                                    location:
                                                        t.getAttribLocation(
                                                            e,
                                                            a,
                                                        ),
                                                    locationSize: s,
                                                });
                                        }
                                        return n;
                                    })(o, x)),
                                T
                            );
                        }),
                        (this.destroy = function () {
                            s.releaseStatesOfProgram(this),
                                o.deleteProgram(x),
                                (this.program = void 0);
                        }),
                        (this.name = a.shaderName),
                        (this.id = xr++),
                        (this.cacheKey = e),
                        (this.usedTimes = 1),
                        (this.program = x),
                        (this.vertexShader = A),
                        (this.fragmentShader = _),
                        this
                    );
                }
                let Or = 0;
                class Dr {
                    constructor() {
                        (this.shaderCache = new Map()),
                            (this.materialCache = new Map());
                    }
                    update(t) {
                        const e = t.vertexShader,
                            n = t.fragmentShader,
                            i = this._getShaderStage(e),
                            r = this._getShaderStage(n),
                            a = this._getShaderCacheForMaterial(t);
                        return (
                            !1 === a.has(i) && (a.add(i), i.usedTimes++),
                            !1 === a.has(r) && (a.add(r), r.usedTimes++),
                            this
                        );
                    }
                    remove(t) {
                        const e = this.materialCache.get(t);
                        for (const t of e)
                            t.usedTimes--,
                                0 === t.usedTimes &&
                                    this.shaderCache.delete(t.code);
                        return this.materialCache.delete(t), this;
                    }
                    getVertexShaderID(t) {
                        return this._getShaderStage(t.vertexShader).id;
                    }
                    getFragmentShaderID(t) {
                        return this._getShaderStage(t.fragmentShader).id;
                    }
                    dispose() {
                        this.shaderCache.clear(), this.materialCache.clear();
                    }
                    _getShaderCacheForMaterial(t) {
                        const e = this.materialCache;
                        let n = e.get(t);
                        return (
                            void 0 === n && ((n = new Set()), e.set(t, n)), n
                        );
                    }
                    _getShaderStage(t) {
                        const e = this.shaderCache;
                        let n = e.get(t);
                        return (
                            void 0 === n && ((n = new Pr(t)), e.set(t, n)), n
                        );
                    }
                }
                class Pr {
                    constructor(t) {
                        (this.id = Or++), (this.code = t), (this.usedTimes = 0);
                    }
                }
                function Ur(t, e, n, i, a, s, o) {
                    const l = new le(),
                        c = new Dr(),
                        h = [],
                        u = a.isWebGL2,
                        d = a.logarithmicDepthBuffer,
                        p = a.vertexTextures;
                    let f = a.precision;
                    const m = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite",
                    };
                    return {
                        getParameters: function (s, l, h, g, v) {
                            const x = g.fog,
                                b = v.geometry,
                                y = s.isMeshStandardMaterial
                                    ? g.environment
                                    : null,
                                S = (s.isMeshStandardMaterial ? n : e).get(
                                    s.envMap || y,
                                ),
                                M =
                                    S && S.mapping === r
                                        ? S.image.height
                                        : null,
                                A = m[s.type];
                            null !== s.precision &&
                                ((f = a.getMaxPrecision(s.precision)),
                                f !== s.precision &&
                                    console.warn(
                                        "THREE.WebGLProgram.getParameters:",
                                        s.precision,
                                        "not supported, using",
                                        f,
                                        "instead.",
                                    ));
                            const _ =
                                    b.morphAttributes.position ||
                                    b.morphAttributes.normal ||
                                    b.morphAttributes.color,
                                w = void 0 !== _ ? _.length : 0;
                            let T,
                                E,
                                R,
                                k,
                                I = 0;
                            if (
                                (void 0 !== b.morphAttributes.position &&
                                    (I = 1),
                                void 0 !== b.morphAttributes.normal && (I = 2),
                                void 0 !== b.morphAttributes.color && (I = 3),
                                A)
                            ) {
                                const t = Vn[A];
                                (T = t.vertexShader), (E = t.fragmentShader);
                            } else
                                (T = s.vertexShader),
                                    (E = s.fragmentShader),
                                    c.update(s),
                                    (R = c.getVertexShaderID(s)),
                                    (k = c.getFragmentShaderID(s));
                            const O = t.getRenderTarget(),
                                D = s.alphaTest > 0,
                                P = s.clearcoat > 0,
                                U = s.iridescence > 0;
                            return {
                                isWebGL2: u,
                                shaderID: A,
                                shaderName: s.type,
                                vertexShader: T,
                                fragmentShader: E,
                                defines: s.defines,
                                customVertexShaderID: R,
                                customFragmentShaderID: k,
                                isRawShaderMaterial:
                                    !0 === s.isRawShaderMaterial,
                                glslVersion: s.glslVersion,
                                precision: f,
                                instancing: !0 === v.isInstancedMesh,
                                instancingColor:
                                    !0 === v.isInstancedMesh &&
                                    null !== v.instanceColor,
                                supportsVertexTextures: p,
                                outputEncoding:
                                    null === O
                                        ? t.outputEncoding
                                        : !0 === O.isXRRenderTarget
                                        ? O.texture.encoding
                                        : C,
                                map: !!s.map,
                                matcap: !!s.matcap,
                                envMap: !!S,
                                envMapMode: S && S.mapping,
                                envMapCubeUVHeight: M,
                                lightMap: !!s.lightMap,
                                aoMap: !!s.aoMap,
                                emissiveMap: !!s.emissiveMap,
                                bumpMap: !!s.bumpMap,
                                normalMap: !!s.normalMap,
                                objectSpaceNormalMap: 1 === s.normalMapType,
                                tangentSpaceNormalMap: 0 === s.normalMapType,
                                decodeVideoTexture:
                                    !!s.map &&
                                    !0 === s.map.isVideoTexture &&
                                    s.map.encoding === L,
                                clearcoat: P,
                                clearcoatMap: P && !!s.clearcoatMap,
                                clearcoatRoughnessMap:
                                    P && !!s.clearcoatRoughnessMap,
                                clearcoatNormalMap: P && !!s.clearcoatNormalMap,
                                iridescence: U,
                                iridescenceMap: U && !!s.iridescenceMap,
                                iridescenceThicknessMap:
                                    U && !!s.iridescenceThicknessMap,
                                displacementMap: !!s.displacementMap,
                                roughnessMap: !!s.roughnessMap,
                                metalnessMap: !!s.metalnessMap,
                                specularMap: !!s.specularMap,
                                specularIntensityMap: !!s.specularIntensityMap,
                                specularColorMap: !!s.specularColorMap,
                                opaque:
                                    !1 === s.transparent && 1 === s.blending,
                                alphaMap: !!s.alphaMap,
                                alphaTest: D,
                                gradientMap: !!s.gradientMap,
                                sheen: s.sheen > 0,
                                sheenColorMap: !!s.sheenColorMap,
                                sheenRoughnessMap: !!s.sheenRoughnessMap,
                                transmission: s.transmission > 0,
                                transmissionMap: !!s.transmissionMap,
                                thicknessMap: !!s.thicknessMap,
                                combine: s.combine,
                                vertexTangents:
                                    !!s.normalMap && !!b.attributes.tangent,
                                vertexColors: s.vertexColors,
                                vertexAlphas:
                                    !0 === s.vertexColors &&
                                    !!b.attributes.color &&
                                    4 === b.attributes.color.itemSize,
                                vertexUvs: !!(
                                    s.map ||
                                    s.bumpMap ||
                                    s.normalMap ||
                                    s.specularMap ||
                                    s.alphaMap ||
                                    s.emissiveMap ||
                                    s.roughnessMap ||
                                    s.metalnessMap ||
                                    s.clearcoatMap ||
                                    s.clearcoatRoughnessMap ||
                                    s.clearcoatNormalMap ||
                                    s.iridescenceMap ||
                                    s.iridescenceThicknessMap ||
                                    s.displacementMap ||
                                    s.transmissionMap ||
                                    s.thicknessMap ||
                                    s.specularIntensityMap ||
                                    s.specularColorMap ||
                                    s.sheenColorMap ||
                                    s.sheenRoughnessMap
                                ),
                                uvsVertexOnly: !(
                                    s.map ||
                                    s.bumpMap ||
                                    s.normalMap ||
                                    s.specularMap ||
                                    s.alphaMap ||
                                    s.emissiveMap ||
                                    s.roughnessMap ||
                                    s.metalnessMap ||
                                    s.clearcoatNormalMap ||
                                    s.iridescenceMap ||
                                    s.iridescenceThicknessMap ||
                                    s.transmission > 0 ||
                                    s.transmissionMap ||
                                    s.thicknessMap ||
                                    s.specularIntensityMap ||
                                    s.specularColorMap ||
                                    s.sheen > 0 ||
                                    s.sheenColorMap ||
                                    s.sheenRoughnessMap ||
                                    !s.displacementMap
                                ),
                                fog: !!x,
                                useFog: !0 === s.fog,
                                fogExp2: x && x.isFogExp2,
                                flatShading: !!s.flatShading,
                                sizeAttenuation: s.sizeAttenuation,
                                logarithmicDepthBuffer: d,
                                skinning: !0 === v.isSkinnedMesh,
                                morphTargets:
                                    void 0 !== b.morphAttributes.position,
                                morphNormals:
                                    void 0 !== b.morphAttributes.normal,
                                morphColors: void 0 !== b.morphAttributes.color,
                                morphTargetsCount: w,
                                morphTextureStride: I,
                                numDirLights: l.directional.length,
                                numPointLights: l.point.length,
                                numSpotLights: l.spot.length,
                                numSpotLightMaps: l.spotLightMap.length,
                                numRectAreaLights: l.rectArea.length,
                                numHemiLights: l.hemi.length,
                                numDirLightShadows:
                                    l.directionalShadowMap.length,
                                numPointLightShadows: l.pointShadowMap.length,
                                numSpotLightShadows: l.spotShadowMap.length,
                                numSpotLightShadowsWithMaps:
                                    l.numSpotLightShadowsWithMaps,
                                numClippingPlanes: o.numPlanes,
                                numClipIntersection: o.numIntersection,
                                dithering: s.dithering,
                                shadowMapEnabled:
                                    t.shadowMap.enabled && h.length > 0,
                                shadowMapType: t.shadowMap.type,
                                toneMapping: s.toneMapped ? t.toneMapping : 0,
                                physicallyCorrectLights:
                                    t.physicallyCorrectLights,
                                premultipliedAlpha: s.premultipliedAlpha,
                                doubleSided: 2 === s.side,
                                flipSided: 1 === s.side,
                                useDepthPacking: !!s.depthPacking,
                                depthPacking: s.depthPacking || 0,
                                index0AttributeName: s.index0AttributeName,
                                extensionDerivatives:
                                    s.extensions && s.extensions.derivatives,
                                extensionFragDepth:
                                    s.extensions && s.extensions.fragDepth,
                                extensionDrawBuffers:
                                    s.extensions && s.extensions.drawBuffers,
                                extensionShaderTextureLOD:
                                    s.extensions &&
                                    s.extensions.shaderTextureLOD,
                                rendererExtensionFragDepth:
                                    u || i.has("EXT_frag_depth"),
                                rendererExtensionDrawBuffers:
                                    u || i.has("WEBGL_draw_buffers"),
                                rendererExtensionShaderTextureLod:
                                    u || i.has("EXT_shader_texture_lod"),
                                customProgramCacheKey:
                                    s.customProgramCacheKey(),
                            };
                        },
                        getProgramCacheKey: function (e) {
                            const n = [];
                            if (
                                (e.shaderID
                                    ? n.push(e.shaderID)
                                    : (n.push(e.customVertexShaderID),
                                      n.push(e.customFragmentShaderID)),
                                void 0 !== e.defines)
                            )
                                for (const t in e.defines)
                                    n.push(t), n.push(e.defines[t]);
                            return (
                                !1 === e.isRawShaderMaterial &&
                                    ((function (t, e) {
                                        t.push(e.precision),
                                            t.push(e.outputEncoding),
                                            t.push(e.envMapMode),
                                            t.push(e.envMapCubeUVHeight),
                                            t.push(e.combine),
                                            t.push(e.vertexUvs),
                                            t.push(e.fogExp2),
                                            t.push(e.sizeAttenuation),
                                            t.push(e.morphTargetsCount),
                                            t.push(e.morphAttributeCount),
                                            t.push(e.numDirLights),
                                            t.push(e.numPointLights),
                                            t.push(e.numSpotLights),
                                            t.push(e.numSpotLightMaps),
                                            t.push(e.numHemiLights),
                                            t.push(e.numRectAreaLights),
                                            t.push(e.numDirLightShadows),
                                            t.push(e.numPointLightShadows),
                                            t.push(e.numSpotLightShadows),
                                            t.push(
                                                e.numSpotLightShadowsWithMaps,
                                            ),
                                            t.push(e.shadowMapType),
                                            t.push(e.toneMapping),
                                            t.push(e.numClippingPlanes),
                                            t.push(e.numClipIntersection),
                                            t.push(e.depthPacking);
                                    })(n, e),
                                    (function (t, e) {
                                        l.disableAll(),
                                            e.isWebGL2 && l.enable(0),
                                            e.supportsVertexTextures &&
                                                l.enable(1),
                                            e.instancing && l.enable(2),
                                            e.instancingColor && l.enable(3),
                                            e.map && l.enable(4),
                                            e.matcap && l.enable(5),
                                            e.envMap && l.enable(6),
                                            e.lightMap && l.enable(7),
                                            e.aoMap && l.enable(8),
                                            e.emissiveMap && l.enable(9),
                                            e.bumpMap && l.enable(10),
                                            e.normalMap && l.enable(11),
                                            e.objectSpaceNormalMap &&
                                                l.enable(12),
                                            e.tangentSpaceNormalMap &&
                                                l.enable(13),
                                            e.clearcoat && l.enable(14),
                                            e.clearcoatMap && l.enable(15),
                                            e.clearcoatRoughnessMap &&
                                                l.enable(16),
                                            e.clearcoatNormalMap &&
                                                l.enable(17),
                                            e.iridescence && l.enable(18),
                                            e.iridescenceMap && l.enable(19),
                                            e.iridescenceThicknessMap &&
                                                l.enable(20),
                                            e.displacementMap && l.enable(21),
                                            e.specularMap && l.enable(22),
                                            e.roughnessMap && l.enable(23),
                                            e.metalnessMap && l.enable(24),
                                            e.gradientMap && l.enable(25),
                                            e.alphaMap && l.enable(26),
                                            e.alphaTest && l.enable(27),
                                            e.vertexColors && l.enable(28),
                                            e.vertexAlphas && l.enable(29),
                                            e.vertexUvs && l.enable(30),
                                            e.vertexTangents && l.enable(31),
                                            e.uvsVertexOnly && l.enable(32),
                                            t.push(l.mask),
                                            l.disableAll(),
                                            e.fog && l.enable(0),
                                            e.useFog && l.enable(1),
                                            e.flatShading && l.enable(2),
                                            e.logarithmicDepthBuffer &&
                                                l.enable(3),
                                            e.skinning && l.enable(4),
                                            e.morphTargets && l.enable(5),
                                            e.morphNormals && l.enable(6),
                                            e.morphColors && l.enable(7),
                                            e.premultipliedAlpha && l.enable(8),
                                            e.shadowMapEnabled && l.enable(9),
                                            e.physicallyCorrectLights &&
                                                l.enable(10),
                                            e.doubleSided && l.enable(11),
                                            e.flipSided && l.enable(12),
                                            e.useDepthPacking && l.enable(13),
                                            e.dithering && l.enable(14),
                                            e.specularIntensityMap &&
                                                l.enable(15),
                                            e.specularColorMap && l.enable(16),
                                            e.transmission && l.enable(17),
                                            e.transmissionMap && l.enable(18),
                                            e.thicknessMap && l.enable(19),
                                            e.sheen && l.enable(20),
                                            e.sheenColorMap && l.enable(21),
                                            e.sheenRoughnessMap && l.enable(22),
                                            e.decodeVideoTexture &&
                                                l.enable(23),
                                            e.opaque && l.enable(24),
                                            t.push(l.mask);
                                    })(n, e),
                                    n.push(t.outputEncoding)),
                                n.push(e.customProgramCacheKey),
                                n.join()
                            );
                        },
                        getUniforms: function (t) {
                            const e = m[t.type];
                            let n;
                            if (e) {
                                const t = Vn[e];
                                n = vn.clone(t.uniforms);
                            } else n = t.uniforms;
                            return n;
                        },
                        acquireProgram: function (e, n) {
                            let i;
                            for (let t = 0, e = h.length; t < e; t++) {
                                const e = h[t];
                                if (e.cacheKey === n) {
                                    (i = e), ++i.usedTimes;
                                    break;
                                }
                            }
                            return (
                                void 0 === i &&
                                    ((i = new Ir(t, n, e, s)), h.push(i)),
                                i
                            );
                        },
                        releaseProgram: function (t) {
                            if (0 == --t.usedTimes) {
                                const e = h.indexOf(t);
                                (h[e] = h[h.length - 1]), h.pop(), t.destroy();
                            }
                        },
                        releaseShaderCache: function (t) {
                            c.remove(t);
                        },
                        programs: h,
                        dispose: function () {
                            c.dispose();
                        },
                    };
                }
                function Vr() {
                    let t = new WeakMap();
                    return {
                        get: function (e) {
                            let n = t.get(e);
                            return void 0 === n && ((n = {}), t.set(e, n)), n;
                        },
                        remove: function (e) {
                            t.delete(e);
                        },
                        update: function (e, n, i) {
                            t.get(e)[n] = i;
                        },
                        dispose: function () {
                            t = new WeakMap();
                        },
                    };
                }
                function Nr(t, e) {
                    return t.groupOrder !== e.groupOrder
                        ? t.groupOrder - e.groupOrder
                        : t.renderOrder !== e.renderOrder
                        ? t.renderOrder - e.renderOrder
                        : t.material.id !== e.material.id
                        ? t.material.id - e.material.id
                        : t.z !== e.z
                        ? t.z - e.z
                        : t.id - e.id;
                }
                function Gr(t, e) {
                    return t.groupOrder !== e.groupOrder
                        ? t.groupOrder - e.groupOrder
                        : t.renderOrder !== e.renderOrder
                        ? t.renderOrder - e.renderOrder
                        : t.z !== e.z
                        ? e.z - t.z
                        : t.id - e.id;
                }
                function jr() {
                    const t = [];
                    let e = 0;
                    const n = [],
                        i = [],
                        r = [];
                    function a(n, i, r, a, s, o) {
                        let l = t[e];
                        return (
                            void 0 === l
                                ? ((l = {
                                      id: n.id,
                                      object: n,
                                      geometry: i,
                                      material: r,
                                      groupOrder: a,
                                      renderOrder: n.renderOrder,
                                      z: s,
                                      group: o,
                                  }),
                                  (t[e] = l))
                                : ((l.id = n.id),
                                  (l.object = n),
                                  (l.geometry = i),
                                  (l.material = r),
                                  (l.groupOrder = a),
                                  (l.renderOrder = n.renderOrder),
                                  (l.z = s),
                                  (l.group = o)),
                            e++,
                            l
                        );
                    }
                    return {
                        opaque: n,
                        transmissive: i,
                        transparent: r,
                        init: function () {
                            (e = 0),
                                (n.length = 0),
                                (i.length = 0),
                                (r.length = 0);
                        },
                        push: function (t, e, s, o, l, c) {
                            const h = a(t, e, s, o, l, c);
                            s.transmission > 0
                                ? i.push(h)
                                : !0 === s.transparent
                                ? r.push(h)
                                : n.push(h);
                        },
                        unshift: function (t, e, s, o, l, c) {
                            const h = a(t, e, s, o, l, c);
                            s.transmission > 0
                                ? i.unshift(h)
                                : !0 === s.transparent
                                ? r.unshift(h)
                                : n.unshift(h);
                        },
                        finish: function () {
                            for (let n = e, i = t.length; n < i; n++) {
                                const e = t[n];
                                if (null === e.id) break;
                                (e.id = null),
                                    (e.object = null),
                                    (e.geometry = null),
                                    (e.material = null),
                                    (e.group = null);
                            }
                        },
                        sort: function (t, e) {
                            n.length > 1 && n.sort(t || Nr),
                                i.length > 1 && i.sort(e || Gr),
                                r.length > 1 && r.sort(e || Gr);
                        },
                    };
                }
                function Hr() {
                    let t = new WeakMap();
                    return {
                        get: function (e, n) {
                            const i = t.get(e);
                            let r;
                            return (
                                void 0 === i
                                    ? ((r = new jr()), t.set(e, [r]))
                                    : n >= i.length
                                    ? ((r = new jr()), i.push(r))
                                    : (r = i[n]),
                                r
                            );
                        },
                        dispose: function () {
                            t = new WeakMap();
                        },
                    };
                }
                function Fr() {
                    const t = {};
                    return {
                        get: function (e) {
                            if (void 0 !== t[e.id]) return t[e.id];
                            let n;
                            switch (e.type) {
                                case "DirectionalLight":
                                    n = {
                                        direction: new St(),
                                        color: new ct(),
                                    };
                                    break;
                                case "SpotLight":
                                    n = {
                                        position: new St(),
                                        direction: new St(),
                                        color: new ct(),
                                        distance: 0,
                                        coneCos: 0,
                                        penumbraCos: 0,
                                        decay: 0,
                                    };
                                    break;
                                case "PointLight":
                                    n = {
                                        position: new St(),
                                        color: new ct(),
                                        distance: 0,
                                        decay: 0,
                                    };
                                    break;
                                case "HemisphereLight":
                                    n = {
                                        direction: new St(),
                                        skyColor: new ct(),
                                        groundColor: new ct(),
                                    };
                                    break;
                                case "RectAreaLight":
                                    n = {
                                        color: new ct(),
                                        position: new St(),
                                        halfWidth: new St(),
                                        halfHeight: new St(),
                                    };
                            }
                            return (t[e.id] = n), n;
                        },
                    };
                }
                let Br = 0;
                function zr(t, e) {
                    return (
                        (e.castShadow ? 2 : 0) -
                        (t.castShadow ? 2 : 0) +
                        (e.map ? 1 : 0) -
                        (t.map ? 1 : 0)
                    );
                }
                function Wr(t, e) {
                    const n = new Fr(),
                        i = (function () {
                            const t = {};
                            return {
                                get: function (e) {
                                    if (void 0 !== t[e.id]) return t[e.id];
                                    let n;
                                    switch (e.type) {
                                        case "DirectionalLight":
                                        case "SpotLight":
                                            n = {
                                                shadowBias: 0,
                                                shadowNormalBias: 0,
                                                shadowRadius: 1,
                                                shadowMapSize: new K(),
                                            };
                                            break;
                                        case "PointLight":
                                            n = {
                                                shadowBias: 0,
                                                shadowNormalBias: 0,
                                                shadowRadius: 1,
                                                shadowMapSize: new K(),
                                                shadowCameraNear: 1,
                                                shadowCameraFar: 1e3,
                                            };
                                    }
                                    return (t[e.id] = n), n;
                                },
                            };
                        })(),
                        r = {
                            version: 0,
                            hash: {
                                directionalLength: -1,
                                pointLength: -1,
                                spotLength: -1,
                                rectAreaLength: -1,
                                hemiLength: -1,
                                numDirectionalShadows: -1,
                                numPointShadows: -1,
                                numSpotShadows: -1,
                                numSpotMaps: -1,
                            },
                            ambient: [0, 0, 0],
                            probe: [],
                            directional: [],
                            directionalShadow: [],
                            directionalShadowMap: [],
                            directionalShadowMatrix: [],
                            spot: [],
                            spotLightMap: [],
                            spotShadow: [],
                            spotShadowMap: [],
                            spotLightMatrix: [],
                            rectArea: [],
                            rectAreaLTC1: null,
                            rectAreaLTC2: null,
                            point: [],
                            pointShadow: [],
                            pointShadowMap: [],
                            pointShadowMatrix: [],
                            hemi: [],
                            numSpotLightShadowsWithMaps: 0,
                        };
                    for (let t = 0; t < 9; t++) r.probe.push(new St());
                    const a = new St(),
                        s = new Xt(),
                        o = new Xt();
                    return {
                        setup: function (a, s) {
                            let o = 0,
                                l = 0,
                                c = 0;
                            for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                            let h = 0,
                                u = 0,
                                d = 0,
                                p = 0,
                                f = 0,
                                m = 0,
                                g = 0,
                                v = 0,
                                x = 0,
                                b = 0;
                            a.sort(zr);
                            const y = !0 !== s ? Math.PI : 1;
                            for (let t = 0, e = a.length; t < e; t++) {
                                const e = a[t],
                                    s = e.color,
                                    S = e.intensity,
                                    M = e.distance,
                                    A =
                                        e.shadow && e.shadow.map
                                            ? e.shadow.map.texture
                                            : null;
                                if (e.isAmbientLight)
                                    (o += s.r * S * y),
                                        (l += s.g * S * y),
                                        (c += s.b * S * y);
                                else if (e.isLightProbe)
                                    for (let t = 0; t < 9; t++)
                                        r.probe[t].addScaledVector(
                                            e.sh.coefficients[t],
                                            S,
                                        );
                                else if (e.isDirectionalLight) {
                                    const t = n.get(e);
                                    if (
                                        (t.color
                                            .copy(e.color)
                                            .multiplyScalar(e.intensity * y),
                                        e.castShadow)
                                    ) {
                                        const t = e.shadow,
                                            n = i.get(e);
                                        (n.shadowBias = t.bias),
                                            (n.shadowNormalBias = t.normalBias),
                                            (n.shadowRadius = t.radius),
                                            (n.shadowMapSize = t.mapSize),
                                            (r.directionalShadow[h] = n),
                                            (r.directionalShadowMap[h] = A),
                                            (r.directionalShadowMatrix[h] =
                                                e.shadow.matrix),
                                            m++;
                                    }
                                    (r.directional[h] = t), h++;
                                } else if (e.isSpotLight) {
                                    const t = n.get(e);
                                    t.position.setFromMatrixPosition(
                                        e.matrixWorld,
                                    ),
                                        t.color.copy(s).multiplyScalar(S * y),
                                        (t.distance = M),
                                        (t.coneCos = Math.cos(e.angle)),
                                        (t.penumbraCos = Math.cos(
                                            e.angle * (1 - e.penumbra),
                                        )),
                                        (t.decay = e.decay),
                                        (r.spot[d] = t);
                                    const a = e.shadow;
                                    if (
                                        (e.map &&
                                            ((r.spotLightMap[x] = e.map),
                                            x++,
                                            a.updateMatrices(e),
                                            e.castShadow && b++),
                                        (r.spotLightMatrix[d] = a.matrix),
                                        e.castShadow)
                                    ) {
                                        const t = i.get(e);
                                        (t.shadowBias = a.bias),
                                            (t.shadowNormalBias = a.normalBias),
                                            (t.shadowRadius = a.radius),
                                            (t.shadowMapSize = a.mapSize),
                                            (r.spotShadow[d] = t),
                                            (r.spotShadowMap[d] = A),
                                            v++;
                                    }
                                    d++;
                                } else if (e.isRectAreaLight) {
                                    const t = n.get(e);
                                    t.color.copy(s).multiplyScalar(S),
                                        t.halfWidth.set(0.5 * e.width, 0, 0),
                                        t.halfHeight.set(0, 0.5 * e.height, 0),
                                        (r.rectArea[p] = t),
                                        p++;
                                } else if (e.isPointLight) {
                                    const t = n.get(e);
                                    if (
                                        (t.color
                                            .copy(e.color)
                                            .multiplyScalar(e.intensity * y),
                                        (t.distance = e.distance),
                                        (t.decay = e.decay),
                                        e.castShadow)
                                    ) {
                                        const t = e.shadow,
                                            n = i.get(e);
                                        (n.shadowBias = t.bias),
                                            (n.shadowNormalBias = t.normalBias),
                                            (n.shadowRadius = t.radius),
                                            (n.shadowMapSize = t.mapSize),
                                            (n.shadowCameraNear =
                                                t.camera.near),
                                            (n.shadowCameraFar = t.camera.far),
                                            (r.pointShadow[u] = n),
                                            (r.pointShadowMap[u] = A),
                                            (r.pointShadowMatrix[u] =
                                                e.shadow.matrix),
                                            g++;
                                    }
                                    (r.point[u] = t), u++;
                                } else if (e.isHemisphereLight) {
                                    const t = n.get(e);
                                    t.skyColor
                                        .copy(e.color)
                                        .multiplyScalar(S * y),
                                        t.groundColor
                                            .copy(e.groundColor)
                                            .multiplyScalar(S * y),
                                        (r.hemi[f] = t),
                                        f++;
                                }
                            }
                            p > 0 &&
                                (e.isWebGL2 ||
                                !0 === t.has("OES_texture_float_linear")
                                    ? ((r.rectAreaLTC1 = Un.LTC_FLOAT_1),
                                      (r.rectAreaLTC2 = Un.LTC_FLOAT_2))
                                    : !0 ===
                                      t.has("OES_texture_half_float_linear")
                                    ? ((r.rectAreaLTC1 = Un.LTC_HALF_1),
                                      (r.rectAreaLTC2 = Un.LTC_HALF_2))
                                    : console.error(
                                          "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.",
                                      )),
                                (r.ambient[0] = o),
                                (r.ambient[1] = l),
                                (r.ambient[2] = c);
                            const S = r.hash;
                            (S.directionalLength === h &&
                                S.pointLength === u &&
                                S.spotLength === d &&
                                S.rectAreaLength === p &&
                                S.hemiLength === f &&
                                S.numDirectionalShadows === m &&
                                S.numPointShadows === g &&
                                S.numSpotShadows === v &&
                                S.numSpotMaps === x) ||
                                ((r.directional.length = h),
                                (r.spot.length = d),
                                (r.rectArea.length = p),
                                (r.point.length = u),
                                (r.hemi.length = f),
                                (r.directionalShadow.length = m),
                                (r.directionalShadowMap.length = m),
                                (r.pointShadow.length = g),
                                (r.pointShadowMap.length = g),
                                (r.spotShadow.length = v),
                                (r.spotShadowMap.length = v),
                                (r.directionalShadowMatrix.length = m),
                                (r.pointShadowMatrix.length = g),
                                (r.spotLightMatrix.length = v + x - b),
                                (r.spotLightMap.length = x),
                                (r.numSpotLightShadowsWithMaps = b),
                                (S.directionalLength = h),
                                (S.pointLength = u),
                                (S.spotLength = d),
                                (S.rectAreaLength = p),
                                (S.hemiLength = f),
                                (S.numDirectionalShadows = m),
                                (S.numPointShadows = g),
                                (S.numSpotShadows = v),
                                (S.numSpotMaps = x),
                                (r.version = Br++));
                        },
                        setupView: function (t, e) {
                            let n = 0,
                                i = 0,
                                l = 0,
                                c = 0,
                                h = 0;
                            const u = e.matrixWorldInverse;
                            for (let e = 0, d = t.length; e < d; e++) {
                                const d = t[e];
                                if (d.isDirectionalLight) {
                                    const t = r.directional[n];
                                    t.direction.setFromMatrixPosition(
                                        d.matrixWorld,
                                    ),
                                        a.setFromMatrixPosition(
                                            d.target.matrixWorld,
                                        ),
                                        t.direction.sub(a),
                                        t.direction.transformDirection(u),
                                        n++;
                                } else if (d.isSpotLight) {
                                    const t = r.spot[l];
                                    t.position.setFromMatrixPosition(
                                        d.matrixWorld,
                                    ),
                                        t.position.applyMatrix4(u),
                                        t.direction.setFromMatrixPosition(
                                            d.matrixWorld,
                                        ),
                                        a.setFromMatrixPosition(
                                            d.target.matrixWorld,
                                        ),
                                        t.direction.sub(a),
                                        t.direction.transformDirection(u),
                                        l++;
                                } else if (d.isRectAreaLight) {
                                    const t = r.rectArea[c];
                                    t.position.setFromMatrixPosition(
                                        d.matrixWorld,
                                    ),
                                        t.position.applyMatrix4(u),
                                        o.identity(),
                                        s.copy(d.matrixWorld),
                                        s.premultiply(u),
                                        o.extractRotation(s),
                                        t.halfWidth.set(0.5 * d.width, 0, 0),
                                        t.halfHeight.set(0, 0.5 * d.height, 0),
                                        t.halfWidth.applyMatrix4(o),
                                        t.halfHeight.applyMatrix4(o),
                                        c++;
                                } else if (d.isPointLight) {
                                    const t = r.point[i];
                                    t.position.setFromMatrixPosition(
                                        d.matrixWorld,
                                    ),
                                        t.position.applyMatrix4(u),
                                        i++;
                                } else if (d.isHemisphereLight) {
                                    const t = r.hemi[h];
                                    t.direction.setFromMatrixPosition(
                                        d.matrixWorld,
                                    ),
                                        t.direction.transformDirection(u),
                                        h++;
                                }
                            }
                        },
                        state: r,
                    };
                }
                function qr(t, e) {
                    const n = new Wr(t, e),
                        i = [],
                        r = [];
                    return {
                        init: function () {
                            (i.length = 0), (r.length = 0);
                        },
                        state: { lightsArray: i, shadowsArray: r, lights: n },
                        setupLights: function (t) {
                            n.setup(i, t);
                        },
                        setupLightsView: function (t) {
                            n.setupView(i, t);
                        },
                        pushLight: function (t) {
                            i.push(t);
                        },
                        pushShadow: function (t) {
                            r.push(t);
                        },
                    };
                }
                function Yr(t, e) {
                    let n = new WeakMap();
                    return {
                        get: function (i, r = 0) {
                            const a = n.get(i);
                            let s;
                            return (
                                void 0 === a
                                    ? ((s = new qr(t, e)), n.set(i, [s]))
                                    : r >= a.length
                                    ? ((s = new qr(t, e)), a.push(s))
                                    : (s = a[r]),
                                s
                            );
                        },
                        dispose: function () {
                            n = new WeakMap();
                        },
                    };
                }
                class Kr extends Pe {
                    constructor(t) {
                        super(),
                            (this.isMeshDepthMaterial = !0),
                            (this.type = "MeshDepthMaterial"),
                            (this.depthPacking = 3200),
                            (this.map = null),
                            (this.alphaMap = null),
                            (this.displacementMap = null),
                            (this.displacementScale = 1),
                            (this.displacementBias = 0),
                            (this.wireframe = !1),
                            (this.wireframeLinewidth = 1),
                            this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            (this.depthPacking = t.depthPacking),
                            (this.map = t.map),
                            (this.alphaMap = t.alphaMap),
                            (this.displacementMap = t.displacementMap),
                            (this.displacementScale = t.displacementScale),
                            (this.displacementBias = t.displacementBias),
                            (this.wireframe = t.wireframe),
                            (this.wireframeLinewidth = t.wireframeLinewidth),
                            this
                        );
                    }
                }
                class Jr extends Pe {
                    constructor(t) {
                        super(),
                            (this.isMeshDistanceMaterial = !0),
                            (this.type = "MeshDistanceMaterial"),
                            (this.referencePosition = new St()),
                            (this.nearDistance = 1),
                            (this.farDistance = 1e3),
                            (this.map = null),
                            (this.alphaMap = null),
                            (this.displacementMap = null),
                            (this.displacementScale = 1),
                            (this.displacementBias = 0),
                            this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            this.referencePosition.copy(t.referencePosition),
                            (this.nearDistance = t.nearDistance),
                            (this.farDistance = t.farDistance),
                            (this.map = t.map),
                            (this.alphaMap = t.alphaMap),
                            (this.displacementMap = t.displacementMap),
                            (this.displacementScale = t.displacementScale),
                            (this.displacementBias = t.displacementBias),
                            this
                        );
                    }
                }
                function Zr(t, e, n) {
                    let i = new Ln();
                    const r = new K(),
                        a = new K(),
                        s = new gt(),
                        o = new Kr({ depthPacking: 3201 }),
                        c = new Jr(),
                        h = {},
                        u = n.maxTextureSize,
                        d = { 0: 1, 1: 0, 2: 2 },
                        p = new xn({
                            defines: { VSM_SAMPLES: 8 },
                            uniforms: {
                                shadow_pass: { value: null },
                                resolution: { value: new K() },
                                radius: { value: 4 },
                            },
                            vertexShader:
                                "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                            fragmentShader:
                                "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
                        }),
                        f = p.clone();
                    f.defines.HORIZONTAL_PASS = 1;
                    const m = new Ze();
                    m.setAttribute(
                        "position",
                        new Ge(
                            new Float32Array([
                                -1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5,
                            ]),
                            3,
                        ),
                    );
                    const g = new un(m, p),
                        v = this;
                    function x(n, i) {
                        const a = e.update(g);
                        p.defines.VSM_SAMPLES !== n.blurSamples &&
                            ((p.defines.VSM_SAMPLES = n.blurSamples),
                            (f.defines.VSM_SAMPLES = n.blurSamples),
                            (p.needsUpdate = !0),
                            (f.needsUpdate = !0)),
                            null === n.mapPass &&
                                (n.mapPass = new vt(r.x, r.y)),
                            (p.uniforms.shadow_pass.value = n.map.texture),
                            (p.uniforms.resolution.value = n.mapSize),
                            (p.uniforms.radius.value = n.radius),
                            t.setRenderTarget(n.mapPass),
                            t.clear(),
                            t.renderBufferDirect(i, null, a, p, g, null),
                            (f.uniforms.shadow_pass.value = n.mapPass.texture),
                            (f.uniforms.resolution.value = n.mapSize),
                            (f.uniforms.radius.value = n.radius),
                            t.setRenderTarget(n.map),
                            t.clear(),
                            t.renderBufferDirect(i, null, a, f, g, null);
                    }
                    function b(e, n, i, r, a, s) {
                        let l = null;
                        const u =
                            !0 === i.isPointLight
                                ? e.customDistanceMaterial
                                : e.customDepthMaterial;
                        if (void 0 !== u) l = u;
                        else if (
                            ((l = !0 === i.isPointLight ? c : o),
                            (t.localClippingEnabled &&
                                !0 === n.clipShadows &&
                                Array.isArray(n.clippingPlanes) &&
                                0 !== n.clippingPlanes.length) ||
                                (n.displacementMap &&
                                    0 !== n.displacementScale) ||
                                (n.alphaMap && n.alphaTest > 0) ||
                                (n.map && n.alphaTest > 0))
                        ) {
                            const t = l.uuid,
                                e = n.uuid;
                            let i = h[t];
                            void 0 === i && ((i = {}), (h[t] = i));
                            let r = i[e];
                            void 0 === r && ((r = l.clone()), (i[e] = r)),
                                (l = r);
                        }
                        return (
                            (l.visible = n.visible),
                            (l.wireframe = n.wireframe),
                            (l.side =
                                3 === s
                                    ? null !== n.shadowSide
                                        ? n.shadowSide
                                        : n.side
                                    : null !== n.shadowSide
                                    ? n.shadowSide
                                    : d[n.side]),
                            (l.alphaMap = n.alphaMap),
                            (l.alphaTest = n.alphaTest),
                            (l.map = n.map),
                            (l.clipShadows = n.clipShadows),
                            (l.clippingPlanes = n.clippingPlanes),
                            (l.clipIntersection = n.clipIntersection),
                            (l.displacementMap = n.displacementMap),
                            (l.displacementScale = n.displacementScale),
                            (l.displacementBias = n.displacementBias),
                            (l.wireframeLinewidth = n.wireframeLinewidth),
                            (l.linewidth = n.linewidth),
                            !0 === i.isPointLight &&
                                !0 === l.isMeshDistanceMaterial &&
                                (l.referencePosition.setFromMatrixPosition(
                                    i.matrixWorld,
                                ),
                                (l.nearDistance = r),
                                (l.farDistance = a)),
                            l
                        );
                    }
                    function y(n, r, a, s, o) {
                        if (!1 === n.visible) return;
                        if (
                            n.layers.test(r.layers) &&
                            (n.isMesh || n.isLine || n.isPoints) &&
                            (n.castShadow || (n.receiveShadow && 3 === o)) &&
                            (!n.frustumCulled || i.intersectsObject(n))
                        ) {
                            n.modelViewMatrix.multiplyMatrices(
                                a.matrixWorldInverse,
                                n.matrixWorld,
                            );
                            const i = e.update(n),
                                r = n.material;
                            if (Array.isArray(r)) {
                                const e = i.groups;
                                for (let l = 0, c = e.length; l < c; l++) {
                                    const c = e[l],
                                        h = r[c.materialIndex];
                                    if (h && h.visible) {
                                        const e = b(n, h, s, a.near, a.far, o);
                                        t.renderBufferDirect(
                                            a,
                                            null,
                                            i,
                                            e,
                                            n,
                                            c,
                                        );
                                    }
                                }
                            } else if (r.visible) {
                                const e = b(n, r, s, a.near, a.far, o);
                                t.renderBufferDirect(a, null, i, e, n, null);
                            }
                        }
                        const l = n.children;
                        for (let t = 0, e = l.length; t < e; t++)
                            y(l[t], r, a, s, o);
                    }
                    (this.enabled = !1),
                        (this.autoUpdate = !0),
                        (this.needsUpdate = !1),
                        (this.type = 1),
                        (this.render = function (e, n, o) {
                            if (!1 === v.enabled) return;
                            if (!1 === v.autoUpdate && !1 === v.needsUpdate)
                                return;
                            if (0 === e.length) return;
                            const c = t.getRenderTarget(),
                                h = t.getActiveCubeFace(),
                                d = t.getActiveMipmapLevel(),
                                p = t.state;
                            p.setBlending(0),
                                p.buffers.color.setClear(1, 1, 1, 1),
                                p.buffers.depth.setTest(!0),
                                p.setScissorTest(!1);
                            for (let c = 0, h = e.length; c < h; c++) {
                                const h = e[c],
                                    d = h.shadow;
                                if (void 0 === d) {
                                    console.warn(
                                        "THREE.WebGLShadowMap:",
                                        h,
                                        "has no shadow.",
                                    );
                                    continue;
                                }
                                if (!1 === d.autoUpdate && !1 === d.needsUpdate)
                                    continue;
                                r.copy(d.mapSize);
                                const f = d.getFrameExtents();
                                if (
                                    (r.multiply(f),
                                    a.copy(d.mapSize),
                                    (r.x > u || r.y > u) &&
                                        (r.x > u &&
                                            ((a.x = Math.floor(u / f.x)),
                                            (r.x = a.x * f.x),
                                            (d.mapSize.x = a.x)),
                                        r.y > u &&
                                            ((a.y = Math.floor(u / f.y)),
                                            (r.y = a.y * f.y),
                                            (d.mapSize.y = a.y))),
                                    null === d.map)
                                ) {
                                    const t =
                                        3 !== this.type
                                            ? { minFilter: l, magFilter: l }
                                            : {};
                                    (d.map = new vt(r.x, r.y, t)),
                                        (d.map.texture.name =
                                            h.name + ".shadowMap"),
                                        d.camera.updateProjectionMatrix();
                                }
                                t.setRenderTarget(d.map), t.clear();
                                const m = d.getViewportCount();
                                for (let t = 0; t < m; t++) {
                                    const e = d.getViewport(t);
                                    s.set(
                                        a.x * e.x,
                                        a.y * e.y,
                                        a.x * e.z,
                                        a.y * e.w,
                                    ),
                                        p.viewport(s),
                                        d.updateMatrices(h, t),
                                        (i = d.getFrustum()),
                                        y(n, o, d.camera, h, this.type);
                                }
                                !0 !== d.isPointLightShadow &&
                                    3 === this.type &&
                                    x(d, o),
                                    (d.needsUpdate = !1);
                            }
                            (v.needsUpdate = !1), t.setRenderTarget(c, h, d);
                        });
                }
                function Xr(t, n, i) {
                    const r = i.isWebGL2,
                        a = new (function () {
                            let e = !1;
                            const n = new gt();
                            let i = null;
                            const r = new gt(0, 0, 0, 0);
                            return {
                                setMask: function (n) {
                                    i === n ||
                                        e ||
                                        (t.colorMask(n, n, n, n), (i = n));
                                },
                                setLocked: function (t) {
                                    e = t;
                                },
                                setClear: function (e, i, a, s, o) {
                                    !0 === o && ((e *= s), (i *= s), (a *= s)),
                                        n.set(e, i, a, s),
                                        !1 === r.equals(n) &&
                                            (t.clearColor(e, i, a, s),
                                            r.copy(n));
                                },
                                reset: function () {
                                    (e = !1), (i = null), r.set(-1, 0, 0, 0);
                                },
                            };
                        })(),
                        s = new (function () {
                            let e = !1,
                                n = null,
                                i = null,
                                r = null;
                            return {
                                setTest: function (t) {
                                    t ? H(2929) : F(2929);
                                },
                                setMask: function (i) {
                                    n === i || e || (t.depthMask(i), (n = i));
                                },
                                setFunc: function (e) {
                                    if (i !== e) {
                                        switch (e) {
                                            case 0:
                                                t.depthFunc(512);
                                                break;
                                            case 1:
                                                t.depthFunc(519);
                                                break;
                                            case 2:
                                                t.depthFunc(513);
                                                break;
                                            case 3:
                                            default:
                                                t.depthFunc(515);
                                                break;
                                            case 4:
                                                t.depthFunc(514);
                                                break;
                                            case 5:
                                                t.depthFunc(518);
                                                break;
                                            case 6:
                                                t.depthFunc(516);
                                                break;
                                            case 7:
                                                t.depthFunc(517);
                                        }
                                        i = e;
                                    }
                                },
                                setLocked: function (t) {
                                    e = t;
                                },
                                setClear: function (e) {
                                    r !== e && (t.clearDepth(e), (r = e));
                                },
                                reset: function () {
                                    (e = !1),
                                        (n = null),
                                        (i = null),
                                        (r = null);
                                },
                            };
                        })(),
                        o = new (function () {
                            let e = !1,
                                n = null,
                                i = null,
                                r = null,
                                a = null,
                                s = null,
                                o = null,
                                l = null,
                                c = null;
                            return {
                                setTest: function (t) {
                                    e || (t ? H(2960) : F(2960));
                                },
                                setMask: function (i) {
                                    n === i || e || (t.stencilMask(i), (n = i));
                                },
                                setFunc: function (e, n, s) {
                                    (i === e && r === n && a === s) ||
                                        (t.stencilFunc(e, n, s),
                                        (i = e),
                                        (r = n),
                                        (a = s));
                                },
                                setOp: function (e, n, i) {
                                    (s === e && o === n && l === i) ||
                                        (t.stencilOp(e, n, i),
                                        (s = e),
                                        (o = n),
                                        (l = i));
                                },
                                setLocked: function (t) {
                                    e = t;
                                },
                                setClear: function (e) {
                                    c !== e && (t.clearStencil(e), (c = e));
                                },
                                reset: function () {
                                    (e = !1),
                                        (n = null),
                                        (i = null),
                                        (r = null),
                                        (a = null),
                                        (s = null),
                                        (o = null),
                                        (l = null),
                                        (c = null);
                                },
                            };
                        })(),
                        l = new WeakMap(),
                        c = new WeakMap();
                    let h = {},
                        u = {},
                        d = new WeakMap(),
                        p = [],
                        f = null,
                        m = !1,
                        g = null,
                        v = null,
                        x = null,
                        b = null,
                        y = null,
                        S = null,
                        M = null,
                        A = !1,
                        _ = null,
                        w = null,
                        T = null,
                        E = null,
                        R = null;
                    const k = t.getParameter(35661);
                    let C = !1,
                        L = 0;
                    const I = t.getParameter(7938);
                    -1 !== I.indexOf("WebGL")
                        ? ((L = parseFloat(/^WebGL (\d)/.exec(I)[1])),
                          (C = L >= 1))
                        : -1 !== I.indexOf("OpenGL ES") &&
                          ((L = parseFloat(/^OpenGL ES (\d)/.exec(I)[1])),
                          (C = L >= 2));
                    let O = null,
                        D = {};
                    const P = t.getParameter(3088),
                        U = t.getParameter(2978),
                        V = new gt().fromArray(P),
                        N = new gt().fromArray(U);
                    function G(e, n, i) {
                        const r = new Uint8Array(4),
                            a = t.createTexture();
                        t.bindTexture(e, a),
                            t.texParameteri(e, 10241, 9728),
                            t.texParameteri(e, 10240, 9728);
                        for (let e = 0; e < i; e++)
                            t.texImage2D(
                                n + e,
                                0,
                                6408,
                                1,
                                1,
                                0,
                                6408,
                                5121,
                                r,
                            );
                        return a;
                    }
                    const j = {};
                    function H(e) {
                        !0 !== h[e] && (t.enable(e), (h[e] = !0));
                    }
                    function F(e) {
                        !1 !== h[e] && (t.disable(e), (h[e] = !1));
                    }
                    (j[3553] = G(3553, 3553, 1)),
                        (j[34067] = G(34067, 34069, 6)),
                        a.setClear(0, 0, 0, 1),
                        s.setClear(1),
                        o.setClear(0),
                        H(2929),
                        s.setFunc(3),
                        q(!1),
                        Y(1),
                        H(2884),
                        W(0);
                    const B = { [e]: 32774, 101: 32778, 102: 32779 };
                    if (r) (B[103] = 32775), (B[104] = 32776);
                    else {
                        const t = n.get("EXT_blend_minmax");
                        null !== t &&
                            ((B[103] = t.MIN_EXT), (B[104] = t.MAX_EXT));
                    }
                    const z = {
                        200: 0,
                        201: 1,
                        202: 768,
                        204: 770,
                        210: 776,
                        208: 774,
                        206: 772,
                        203: 769,
                        205: 771,
                        209: 775,
                        207: 773,
                    };
                    function W(n, i, r, a, s, o, l, c) {
                        if (0 !== n) {
                            if ((!1 === m && (H(3042), (m = !0)), 5 === n))
                                (s = s || i),
                                    (o = o || r),
                                    (l = l || a),
                                    (i === v && s === y) ||
                                        (t.blendEquationSeparate(B[i], B[s]),
                                        (v = i),
                                        (y = s)),
                                    (r === x &&
                                        a === b &&
                                        o === S &&
                                        l === M) ||
                                        (t.blendFuncSeparate(
                                            z[r],
                                            z[a],
                                            z[o],
                                            z[l],
                                        ),
                                        (x = r),
                                        (b = a),
                                        (S = o),
                                        (M = l)),
                                    (g = n),
                                    (A = !1);
                            else if (n !== g || c !== A) {
                                if (
                                    ((v === e && y === e) ||
                                        (t.blendEquation(32774),
                                        (v = e),
                                        (y = e)),
                                    c)
                                )
                                    switch (n) {
                                        case 1:
                                            t.blendFuncSeparate(1, 771, 1, 771);
                                            break;
                                        case 2:
                                            t.blendFunc(1, 1);
                                            break;
                                        case 3:
                                            t.blendFuncSeparate(0, 769, 0, 1);
                                            break;
                                        case 4:
                                            t.blendFuncSeparate(0, 768, 0, 770);
                                            break;
                                        default:
                                            console.error(
                                                "THREE.WebGLState: Invalid blending: ",
                                                n,
                                            );
                                    }
                                else
                                    switch (n) {
                                        case 1:
                                            t.blendFuncSeparate(
                                                770,
                                                771,
                                                1,
                                                771,
                                            );
                                            break;
                                        case 2:
                                            t.blendFunc(770, 1);
                                            break;
                                        case 3:
                                            t.blendFuncSeparate(0, 769, 0, 1);
                                            break;
                                        case 4:
                                            t.blendFunc(0, 768);
                                            break;
                                        default:
                                            console.error(
                                                "THREE.WebGLState: Invalid blending: ",
                                                n,
                                            );
                                    }
                                (x = null),
                                    (b = null),
                                    (S = null),
                                    (M = null),
                                    (g = n),
                                    (A = c);
                            }
                        } else !0 === m && (F(3042), (m = !1));
                    }
                    function q(e) {
                        _ !== e &&
                            (e ? t.frontFace(2304) : t.frontFace(2305),
                            (_ = e));
                    }
                    function Y(e) {
                        0 !== e
                            ? (H(2884),
                              e !== w &&
                                  (1 === e
                                      ? t.cullFace(1029)
                                      : 2 === e
                                      ? t.cullFace(1028)
                                      : t.cullFace(1032)))
                            : F(2884),
                            (w = e);
                    }
                    function K(e, n, i) {
                        e
                            ? (H(32823),
                              (E === n && R === i) ||
                                  (t.polygonOffset(n, i), (E = n), (R = i)))
                            : F(32823);
                    }
                    return {
                        buffers: { color: a, depth: s, stencil: o },
                        enable: H,
                        disable: F,
                        bindFramebuffer: function (e, n) {
                            return (
                                u[e] !== n &&
                                (t.bindFramebuffer(e, n),
                                (u[e] = n),
                                r &&
                                    (36009 === e && (u[36160] = n),
                                    36160 === e && (u[36009] = n)),
                                !0)
                            );
                        },
                        drawBuffers: function (e, r) {
                            let a = p,
                                s = !1;
                            if (e)
                                if (
                                    ((a = d.get(r)),
                                    void 0 === a && ((a = []), d.set(r, a)),
                                    e.isWebGLMultipleRenderTargets)
                                ) {
                                    const t = e.texture;
                                    if (
                                        a.length !== t.length ||
                                        36064 !== a[0]
                                    ) {
                                        for (
                                            let e = 0, n = t.length;
                                            e < n;
                                            e++
                                        )
                                            a[e] = 36064 + e;
                                        (a.length = t.length), (s = !0);
                                    }
                                } else
                                    36064 !== a[0] &&
                                        ((a[0] = 36064), (s = !0));
                            else 1029 !== a[0] && ((a[0] = 1029), (s = !0));
                            s &&
                                (i.isWebGL2
                                    ? t.drawBuffers(a)
                                    : n
                                          .get("WEBGL_draw_buffers")
                                          .drawBuffersWEBGL(a));
                        },
                        useProgram: function (e) {
                            return f !== e && (t.useProgram(e), (f = e), !0);
                        },
                        setBlending: W,
                        setMaterial: function (t, e) {
                            2 === t.side ? F(2884) : H(2884);
                            let n = 1 === t.side;
                            e && (n = !n),
                                q(n),
                                1 === t.blending && !1 === t.transparent
                                    ? W(0)
                                    : W(
                                          t.blending,
                                          t.blendEquation,
                                          t.blendSrc,
                                          t.blendDst,
                                          t.blendEquationAlpha,
                                          t.blendSrcAlpha,
                                          t.blendDstAlpha,
                                          t.premultipliedAlpha,
                                      ),
                                s.setFunc(t.depthFunc),
                                s.setTest(t.depthTest),
                                s.setMask(t.depthWrite),
                                a.setMask(t.colorWrite);
                            const i = t.stencilWrite;
                            o.setTest(i),
                                i &&
                                    (o.setMask(t.stencilWriteMask),
                                    o.setFunc(
                                        t.stencilFunc,
                                        t.stencilRef,
                                        t.stencilFuncMask,
                                    ),
                                    o.setOp(
                                        t.stencilFail,
                                        t.stencilZFail,
                                        t.stencilZPass,
                                    )),
                                K(
                                    t.polygonOffset,
                                    t.polygonOffsetFactor,
                                    t.polygonOffsetUnits,
                                ),
                                !0 === t.alphaToCoverage ? H(32926) : F(32926);
                        },
                        setFlipSided: q,
                        setCullFace: Y,
                        setLineWidth: function (e) {
                            e !== T && (C && t.lineWidth(e), (T = e));
                        },
                        setPolygonOffset: K,
                        setScissorTest: function (t) {
                            t ? H(3089) : F(3089);
                        },
                        activeTexture: function (e) {
                            void 0 === e && (e = 33984 + k - 1),
                                O !== e && (t.activeTexture(e), (O = e));
                        },
                        bindTexture: function (e, n, i) {
                            void 0 === i &&
                                (i = null === O ? 33984 + k - 1 : O);
                            let r = D[i];
                            void 0 === r &&
                                ((r = { type: void 0, texture: void 0 }),
                                (D[i] = r)),
                                (r.type === e && r.texture === n) ||
                                    (O !== i && (t.activeTexture(i), (O = i)),
                                    t.bindTexture(e, n || j[e]),
                                    (r.type = e),
                                    (r.texture = n));
                        },
                        unbindTexture: function () {
                            const e = D[O];
                            void 0 !== e &&
                                void 0 !== e.type &&
                                (t.bindTexture(e.type, null),
                                (e.type = void 0),
                                (e.texture = void 0));
                        },
                        compressedTexImage2D: function () {
                            try {
                                t.compressedTexImage2D.apply(t, arguments);
                            } catch (t) {
                                console.error("THREE.WebGLState:", t);
                            }
                        },
                        compressedTexImage3D: function () {
                            try {
                                t.compressedTexImage3D.apply(t, arguments);
                            } catch (t) {
                                console.error("THREE.WebGLState:", t);
                            }
                        },
                        texImage2D: function () {
                            try {
                                t.texImage2D.apply(t, arguments);
                            } catch (t) {
                                console.error("THREE.WebGLState:", t);
                            }
                        },
                        texImage3D: function () {
                            try {
                                t.texImage3D.apply(t, arguments);
                            } catch (t) {
                                console.error("THREE.WebGLState:", t);
                            }
                        },
                        updateUBOMapping: function (e, n) {
                            let i = c.get(n);
                            void 0 === i && ((i = new WeakMap()), c.set(n, i));
                            let r = i.get(e);
                            void 0 === r &&
                                ((r = t.getUniformBlockIndex(n, e.name)),
                                i.set(e, r));
                        },
                        uniformBlockBinding: function (e, n) {
                            const i = c.get(n).get(e);
                            l.get(n) !== i &&
                                (t.uniformBlockBinding(
                                    n,
                                    i,
                                    e.__bindingPointIndex,
                                ),
                                l.set(n, i));
                        },
                        texStorage2D: function () {
                            try {
                                t.texStorage2D.apply(t, arguments);
                            } catch (t) {
                                console.error("THREE.WebGLState:", t);
                            }
                        },
                        texStorage3D: function () {
                            try {
                                t.texStorage3D.apply(t, arguments);
                            } catch (t) {
                                console.error("THREE.WebGLState:", t);
                            }
                        },
                        texSubImage2D: function () {
                            try {
                                t.texSubImage2D.apply(t, arguments);
                            } catch (t) {
                                console.error("THREE.WebGLState:", t);
                            }
                        },
                        texSubImage3D: function () {
                            try {
                                t.texSubImage3D.apply(t, arguments);
                            } catch (t) {
                                console.error("THREE.WebGLState:", t);
                            }
                        },
                        compressedTexSubImage2D: function () {
                            try {
                                t.compressedTexSubImage2D.apply(t, arguments);
                            } catch (t) {
                                console.error("THREE.WebGLState:", t);
                            }
                        },
                        compressedTexSubImage3D: function () {
                            try {
                                t.compressedTexSubImage3D.apply(t, arguments);
                            } catch (t) {
                                console.error("THREE.WebGLState:", t);
                            }
                        },
                        scissor: function (e) {
                            !1 === V.equals(e) &&
                                (t.scissor(e.x, e.y, e.z, e.w), V.copy(e));
                        },
                        viewport: function (e) {
                            !1 === N.equals(e) &&
                                (t.viewport(e.x, e.y, e.z, e.w), N.copy(e));
                        },
                        reset: function () {
                            t.disable(3042),
                                t.disable(2884),
                                t.disable(2929),
                                t.disable(32823),
                                t.disable(3089),
                                t.disable(2960),
                                t.disable(32926),
                                t.blendEquation(32774),
                                t.blendFunc(1, 0),
                                t.blendFuncSeparate(1, 0, 1, 0),
                                t.colorMask(!0, !0, !0, !0),
                                t.clearColor(0, 0, 0, 0),
                                t.depthMask(!0),
                                t.depthFunc(513),
                                t.clearDepth(1),
                                t.stencilMask(4294967295),
                                t.stencilFunc(519, 0, 4294967295),
                                t.stencilOp(7680, 7680, 7680),
                                t.clearStencil(0),
                                t.cullFace(1029),
                                t.frontFace(2305),
                                t.polygonOffset(0, 0),
                                t.activeTexture(33984),
                                t.bindFramebuffer(36160, null),
                                !0 === r &&
                                    (t.bindFramebuffer(36009, null),
                                    t.bindFramebuffer(36008, null)),
                                t.useProgram(null),
                                t.lineWidth(1),
                                t.scissor(
                                    0,
                                    0,
                                    t.canvas.width,
                                    t.canvas.height,
                                ),
                                t.viewport(
                                    0,
                                    0,
                                    t.canvas.width,
                                    t.canvas.height,
                                ),
                                (h = {}),
                                (O = null),
                                (D = {}),
                                (u = {}),
                                (d = new WeakMap()),
                                (p = []),
                                (f = null),
                                (m = !1),
                                (g = null),
                                (v = null),
                                (x = null),
                                (b = null),
                                (y = null),
                                (S = null),
                                (M = null),
                                (A = !1),
                                (_ = null),
                                (w = null),
                                (T = null),
                                (E = null),
                                (R = null),
                                V.set(0, 0, t.canvas.width, t.canvas.height),
                                N.set(0, 0, t.canvas.width, t.canvas.height),
                                a.reset(),
                                s.reset(),
                                o.reset();
                        },
                    };
                }
                function Qr(t, e, n, i, r, y, S) {
                    const M = r.isWebGL2,
                        A = r.maxTextures,
                        _ = r.maxCubemapSize,
                        w = r.maxTextureSize,
                        T = r.maxSamples,
                        E = e.has("WEBGL_multisampled_render_to_texture")
                            ? e.get("WEBGL_multisampled_render_to_texture")
                            : null,
                        R =
                            "undefined" != typeof navigator &&
                            /OculusBrowser/g.test(navigator.userAgent),
                        k = new WeakMap();
                    let I;
                    const O = new WeakMap();
                    let D = !1;
                    try {
                        D =
                            "undefined" != typeof OffscreenCanvas &&
                            null !== new OffscreenCanvas(1, 1).getContext("2d");
                    } catch (t) {}
                    function P(t, e) {
                        return D ? new OffscreenCanvas(t, e) : Q("canvas");
                    }
                    function V(t, e, n, i) {
                        let r = 1;
                        if (
                            ((t.width > i || t.height > i) &&
                                (r = i / Math.max(t.width, t.height)),
                            r < 1 || !0 === e)
                        ) {
                            if (
                                ("undefined" != typeof HTMLImageElement &&
                                    t instanceof HTMLImageElement) ||
                                ("undefined" != typeof HTMLCanvasElement &&
                                    t instanceof HTMLCanvasElement) ||
                                ("undefined" != typeof ImageBitmap &&
                                    t instanceof ImageBitmap)
                            ) {
                                const i = e ? W : Math.floor,
                                    a = i(r * t.width),
                                    s = i(r * t.height);
                                void 0 === I && (I = P(a, s));
                                const o = n ? P(a, s) : I;
                                return (
                                    (o.width = a),
                                    (o.height = s),
                                    o.getContext("2d").drawImage(t, 0, 0, a, s),
                                    console.warn(
                                        "THREE.WebGLRenderer: Texture has been resized from (" +
                                            t.width +
                                            "x" +
                                            t.height +
                                            ") to (" +
                                            a +
                                            "x" +
                                            s +
                                            ").",
                                    ),
                                    o
                                );
                            }
                            return (
                                "data" in t &&
                                    console.warn(
                                        "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                                            t.width +
                                            "x" +
                                            t.height +
                                            ").",
                                    ),
                                t
                            );
                        }
                        return t;
                    }
                    function N(t) {
                        return z(t.width) && z(t.height);
                    }
                    function G(t, e) {
                        return (
                            t.generateMipmaps &&
                            e &&
                            t.minFilter !== l &&
                            t.minFilter !== h
                        );
                    }
                    function j(e) {
                        t.generateMipmap(e);
                    }
                    function H(n, i, r, a, s = !1) {
                        if (!1 === M) return i;
                        if (null !== n) {
                            if (void 0 !== t[n]) return t[n];
                            console.warn(
                                "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                                    n +
                                    "'",
                            );
                        }
                        let o = i;
                        return (
                            6403 === i &&
                                (5126 === r && (o = 33326),
                                5131 === r && (o = 33325),
                                5121 === r && (o = 33321)),
                            33319 === i &&
                                (5126 === r && (o = 33328),
                                5131 === r && (o = 33327),
                                5121 === r && (o = 33323)),
                            6408 === i &&
                                (5126 === r && (o = 34836),
                                5131 === r && (o = 34842),
                                5121 === r &&
                                    (o = a === L && !1 === s ? 35907 : 32856),
                                32819 === r && (o = 32854),
                                32820 === r && (o = 32855)),
                            (33325 !== o &&
                                33326 !== o &&
                                33327 !== o &&
                                33328 !== o &&
                                34842 !== o &&
                                34836 !== o) ||
                                e.get("EXT_color_buffer_float"),
                            o
                        );
                    }
                    function F(t, e, n) {
                        return !0 === G(t, n) ||
                            (t.isFramebufferTexture &&
                                t.minFilter !== l &&
                                t.minFilter !== h)
                            ? Math.log2(Math.max(e.width, e.height)) + 1
                            : void 0 !== t.mipmaps && t.mipmaps.length > 0
                            ? t.mipmaps.length
                            : t.isCompressedTexture && Array.isArray(t.image)
                            ? e.mipmaps.length
                            : 1;
                    }
                    function B(t) {
                        return t === l || 1004 === t || t === c ? 9728 : 9729;
                    }
                    function q(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", q),
                            (function (t) {
                                const e = i.get(t);
                                if (void 0 === e.__webglInit) return;
                                const n = t.source,
                                    r = O.get(n);
                                if (r) {
                                    const i = r[e.__cacheKey];
                                    i.usedTimes--,
                                        0 === i.usedTimes && K(t),
                                        0 === Object.keys(r).length &&
                                            O.delete(n);
                                }
                                i.remove(t);
                            })(e),
                            e.isVideoTexture && k.delete(e);
                    }
                    function Y(e) {
                        const n = e.target;
                        n.removeEventListener("dispose", Y),
                            (function (e) {
                                const n = e.texture,
                                    r = i.get(e),
                                    a = i.get(n);
                                if (
                                    (void 0 !== a.__webglTexture &&
                                        (t.deleteTexture(a.__webglTexture),
                                        S.memory.textures--),
                                    e.depthTexture && e.depthTexture.dispose(),
                                    e.isWebGLCubeRenderTarget)
                                )
                                    for (let e = 0; e < 6; e++)
                                        t.deleteFramebuffer(
                                            r.__webglFramebuffer[e],
                                        ),
                                            r.__webglDepthbuffer &&
                                                t.deleteRenderbuffer(
                                                    r.__webglDepthbuffer[e],
                                                );
                                else {
                                    if (
                                        (t.deleteFramebuffer(
                                            r.__webglFramebuffer,
                                        ),
                                        r.__webglDepthbuffer &&
                                            t.deleteRenderbuffer(
                                                r.__webglDepthbuffer,
                                            ),
                                        r.__webglMultisampledFramebuffer &&
                                            t.deleteFramebuffer(
                                                r.__webglMultisampledFramebuffer,
                                            ),
                                        r.__webglColorRenderbuffer)
                                    )
                                        for (
                                            let e = 0;
                                            e <
                                            r.__webglColorRenderbuffer.length;
                                            e++
                                        )
                                            r.__webglColorRenderbuffer[e] &&
                                                t.deleteRenderbuffer(
                                                    r.__webglColorRenderbuffer[
                                                        e
                                                    ],
                                                );
                                    r.__webglDepthRenderbuffer &&
                                        t.deleteRenderbuffer(
                                            r.__webglDepthRenderbuffer,
                                        );
                                }
                                if (e.isWebGLMultipleRenderTargets)
                                    for (let e = 0, r = n.length; e < r; e++) {
                                        const r = i.get(n[e]);
                                        r.__webglTexture &&
                                            (t.deleteTexture(r.__webglTexture),
                                            S.memory.textures--),
                                            i.remove(n[e]);
                                    }
                                i.remove(n), i.remove(e);
                            })(n);
                    }
                    function K(e) {
                        const n = i.get(e);
                        t.deleteTexture(n.__webglTexture);
                        const r = e.source;
                        delete O.get(r)[n.__cacheKey], S.memory.textures--;
                    }
                    let J = 0;
                    function Z(t, e) {
                        const r = i.get(t);
                        if (
                            (t.isVideoTexture &&
                                (function (t) {
                                    const e = S.render.frame;
                                    k.get(t) !== e && (k.set(t, e), t.update());
                                })(t),
                            !1 === t.isRenderTargetTexture &&
                                t.version > 0 &&
                                r.__version !== t.version)
                        ) {
                            const n = t.image;
                            if (null === n)
                                console.warn(
                                    "THREE.WebGLRenderer: Texture marked for update but no image data found.",
                                );
                            else {
                                if (!1 !== n.complete) return void nt(r, t, e);
                                console.warn(
                                    "THREE.WebGLRenderer: Texture marked for update but image is incomplete",
                                );
                            }
                        }
                        n.bindTexture(3553, r.__webglTexture, 33984 + e);
                    }
                    const X = { [a]: 10497, [s]: 33071, [o]: 33648 },
                        $ = {
                            [l]: 9728,
                            1004: 9984,
                            [c]: 9986,
                            [h]: 9729,
                            1007: 9985,
                            [u]: 9987,
                        };
                    function tt(n, a, o) {
                        if (
                            (o
                                ? (t.texParameteri(n, 10242, X[a.wrapS]),
                                  t.texParameteri(n, 10243, X[a.wrapT]),
                                  (32879 !== n && 35866 !== n) ||
                                      t.texParameteri(n, 32882, X[a.wrapR]),
                                  t.texParameteri(n, 10240, $[a.magFilter]),
                                  t.texParameteri(n, 10241, $[a.minFilter]))
                                : (t.texParameteri(n, 10242, 33071),
                                  t.texParameteri(n, 10243, 33071),
                                  (32879 !== n && 35866 !== n) ||
                                      t.texParameteri(n, 32882, 33071),
                                  (a.wrapS === s && a.wrapT === s) ||
                                      console.warn(
                                          "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.",
                                      ),
                                  t.texParameteri(n, 10240, B(a.magFilter)),
                                  t.texParameteri(n, 10241, B(a.minFilter)),
                                  a.minFilter !== l &&
                                      a.minFilter !== h &&
                                      console.warn(
                                          "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.",
                                      )),
                            !0 === e.has("EXT_texture_filter_anisotropic"))
                        ) {
                            const s = e.get("EXT_texture_filter_anisotropic");
                            if (a.magFilter === l) return;
                            if (a.minFilter !== c && a.minFilter !== u) return;
                            if (
                                a.type === f &&
                                !1 === e.has("OES_texture_float_linear")
                            )
                                return;
                            if (
                                !1 === M &&
                                a.type === m &&
                                !1 === e.has("OES_texture_half_float_linear")
                            )
                                return;
                            (a.anisotropy > 1 ||
                                i.get(a).__currentAnisotropy) &&
                                (t.texParameterf(
                                    n,
                                    s.TEXTURE_MAX_ANISOTROPY_EXT,
                                    Math.min(
                                        a.anisotropy,
                                        r.getMaxAnisotropy(),
                                    ),
                                ),
                                (i.get(a).__currentAnisotropy = a.anisotropy));
                        }
                    }
                    function et(e, n) {
                        let i = !1;
                        void 0 === e.__webglInit &&
                            ((e.__webglInit = !0),
                            n.addEventListener("dispose", q));
                        const r = n.source;
                        let a = O.get(r);
                        void 0 === a && ((a = {}), O.set(r, a));
                        const s = (function (t) {
                            const e = [];
                            return (
                                e.push(t.wrapS),
                                e.push(t.wrapT),
                                e.push(t.wrapR || 0),
                                e.push(t.magFilter),
                                e.push(t.minFilter),
                                e.push(t.anisotropy),
                                e.push(t.internalFormat),
                                e.push(t.format),
                                e.push(t.type),
                                e.push(t.generateMipmaps),
                                e.push(t.premultiplyAlpha),
                                e.push(t.flipY),
                                e.push(t.unpackAlignment),
                                e.push(t.encoding),
                                e.join()
                            );
                        })(n);
                        if (s !== e.__cacheKey) {
                            void 0 === a[s] &&
                                ((a[s] = {
                                    texture: t.createTexture(),
                                    usedTimes: 0,
                                }),
                                S.memory.textures++,
                                (i = !0)),
                                a[s].usedTimes++;
                            const r = a[e.__cacheKey];
                            void 0 !== r &&
                                (a[e.__cacheKey].usedTimes--,
                                0 === r.usedTimes && K(n)),
                                (e.__cacheKey = s),
                                (e.__webglTexture = a[s].texture);
                        }
                        return i;
                    }
                    function nt(e, r, a) {
                        let o = 3553;
                        (r.isDataArrayTexture || r.isCompressedArrayTexture) &&
                            (o = 35866),
                            r.isData3DTexture && (o = 32879);
                        const c = et(e, r),
                            u = r.source;
                        n.bindTexture(o, e.__webglTexture, 33984 + a);
                        const d = i.get(u);
                        if (u.version !== d.__version || !0 === c) {
                            n.activeTexture(33984 + a),
                                t.pixelStorei(37440, r.flipY),
                                t.pixelStorei(37441, r.premultiplyAlpha),
                                t.pixelStorei(3317, r.unpackAlignment),
                                t.pixelStorei(37443, 0);
                            const e =
                                (function (t) {
                                    return (
                                        !M &&
                                        (t.wrapS !== s ||
                                            t.wrapT !== s ||
                                            (t.minFilter !== l &&
                                                t.minFilter !== h))
                                    );
                                })(r) && !1 === N(r.image);
                            let i = V(r.image, e, !1, w);
                            i = lt(r, i);
                            const m = N(i) || M,
                                S = y.convert(r.format, r.encoding);
                            let A,
                                _ = y.convert(r.type),
                                T = H(
                                    r.internalFormat,
                                    S,
                                    _,
                                    r.encoding,
                                    r.isVideoTexture,
                                );
                            tt(o, r, m);
                            const E = r.mipmaps,
                                R = M && !0 !== r.isVideoTexture,
                                k = void 0 === d.__version || !0 === c,
                                C = F(r, i, m);
                            if (r.isDepthTexture)
                                (T = 6402),
                                    M
                                        ? (T =
                                              r.type === f
                                                  ? 36012
                                                  : r.type === p
                                                  ? 33190
                                                  : r.type === g
                                                  ? 35056
                                                  : 33189)
                                        : r.type === f &&
                                          console.error(
                                              "WebGLRenderer: Floating point depth texture requires WebGL2.",
                                          ),
                                    r.format === x &&
                                        6402 === T &&
                                        1012 !== r.type &&
                                        r.type !== p &&
                                        (console.warn(
                                            "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.",
                                        ),
                                        (r.type = p),
                                        (_ = y.convert(r.type))),
                                    r.format === b &&
                                        6402 === T &&
                                        ((T = 34041),
                                        r.type !== g &&
                                            (console.warn(
                                                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.",
                                            ),
                                            (r.type = g),
                                            (_ = y.convert(r.type)))),
                                    k &&
                                        (R
                                            ? n.texStorage2D(
                                                  3553,
                                                  1,
                                                  T,
                                                  i.width,
                                                  i.height,
                                              )
                                            : n.texImage2D(
                                                  3553,
                                                  0,
                                                  T,
                                                  i.width,
                                                  i.height,
                                                  0,
                                                  S,
                                                  _,
                                                  null,
                                              ));
                            else if (r.isDataTexture)
                                if (E.length > 0 && m) {
                                    R &&
                                        k &&
                                        n.texStorage2D(
                                            3553,
                                            C,
                                            T,
                                            E[0].width,
                                            E[0].height,
                                        );
                                    for (let t = 0, e = E.length; t < e; t++)
                                        (A = E[t]),
                                            R
                                                ? n.texSubImage2D(
                                                      3553,
                                                      t,
                                                      0,
                                                      0,
                                                      A.width,
                                                      A.height,
                                                      S,
                                                      _,
                                                      A.data,
                                                  )
                                                : n.texImage2D(
                                                      3553,
                                                      t,
                                                      T,
                                                      A.width,
                                                      A.height,
                                                      0,
                                                      S,
                                                      _,
                                                      A.data,
                                                  );
                                    r.generateMipmaps = !1;
                                } else
                                    R
                                        ? (k &&
                                              n.texStorage2D(
                                                  3553,
                                                  C,
                                                  T,
                                                  i.width,
                                                  i.height,
                                              ),
                                          n.texSubImage2D(
                                              3553,
                                              0,
                                              0,
                                              0,
                                              i.width,
                                              i.height,
                                              S,
                                              _,
                                              i.data,
                                          ))
                                        : n.texImage2D(
                                              3553,
                                              0,
                                              T,
                                              i.width,
                                              i.height,
                                              0,
                                              S,
                                              _,
                                              i.data,
                                          );
                            else if (r.isCompressedTexture)
                                if (r.isCompressedArrayTexture) {
                                    R &&
                                        k &&
                                        n.texStorage3D(
                                            35866,
                                            C,
                                            T,
                                            E[0].width,
                                            E[0].height,
                                            i.depth,
                                        );
                                    for (let t = 0, e = E.length; t < e; t++)
                                        (A = E[t]),
                                            r.format !== v
                                                ? null !== S
                                                    ? R
                                                        ? n.compressedTexSubImage3D(
                                                              35866,
                                                              t,
                                                              0,
                                                              0,
                                                              0,
                                                              A.width,
                                                              A.height,
                                                              i.depth,
                                                              S,
                                                              A.data,
                                                              0,
                                                              0,
                                                          )
                                                        : n.compressedTexImage3D(
                                                              35866,
                                                              t,
                                                              T,
                                                              A.width,
                                                              A.height,
                                                              i.depth,
                                                              0,
                                                              A.data,
                                                              0,
                                                              0,
                                                          )
                                                    : console.warn(
                                                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                                                      )
                                                : R
                                                ? n.texSubImage3D(
                                                      35866,
                                                      t,
                                                      0,
                                                      0,
                                                      0,
                                                      A.width,
                                                      A.height,
                                                      i.depth,
                                                      S,
                                                      _,
                                                      A.data,
                                                  )
                                                : n.texImage3D(
                                                      35866,
                                                      t,
                                                      T,
                                                      A.width,
                                                      A.height,
                                                      i.depth,
                                                      0,
                                                      S,
                                                      _,
                                                      A.data,
                                                  );
                                } else {
                                    R &&
                                        k &&
                                        n.texStorage2D(
                                            3553,
                                            C,
                                            T,
                                            E[0].width,
                                            E[0].height,
                                        );
                                    for (let t = 0, e = E.length; t < e; t++)
                                        (A = E[t]),
                                            r.format !== v
                                                ? null !== S
                                                    ? R
                                                        ? n.compressedTexSubImage2D(
                                                              3553,
                                                              t,
                                                              0,
                                                              0,
                                                              A.width,
                                                              A.height,
                                                              S,
                                                              A.data,
                                                          )
                                                        : n.compressedTexImage2D(
                                                              3553,
                                                              t,
                                                              T,
                                                              A.width,
                                                              A.height,
                                                              0,
                                                              A.data,
                                                          )
                                                    : console.warn(
                                                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                                                      )
                                                : R
                                                ? n.texSubImage2D(
                                                      3553,
                                                      t,
                                                      0,
                                                      0,
                                                      A.width,
                                                      A.height,
                                                      S,
                                                      _,
                                                      A.data,
                                                  )
                                                : n.texImage2D(
                                                      3553,
                                                      t,
                                                      T,
                                                      A.width,
                                                      A.height,
                                                      0,
                                                      S,
                                                      _,
                                                      A.data,
                                                  );
                                }
                            else if (r.isDataArrayTexture)
                                R
                                    ? (k &&
                                          n.texStorage3D(
                                              35866,
                                              C,
                                              T,
                                              i.width,
                                              i.height,
                                              i.depth,
                                          ),
                                      n.texSubImage3D(
                                          35866,
                                          0,
                                          0,
                                          0,
                                          0,
                                          i.width,
                                          i.height,
                                          i.depth,
                                          S,
                                          _,
                                          i.data,
                                      ))
                                    : n.texImage3D(
                                          35866,
                                          0,
                                          T,
                                          i.width,
                                          i.height,
                                          i.depth,
                                          0,
                                          S,
                                          _,
                                          i.data,
                                      );
                            else if (r.isData3DTexture)
                                R
                                    ? (k &&
                                          n.texStorage3D(
                                              32879,
                                              C,
                                              T,
                                              i.width,
                                              i.height,
                                              i.depth,
                                          ),
                                      n.texSubImage3D(
                                          32879,
                                          0,
                                          0,
                                          0,
                                          0,
                                          i.width,
                                          i.height,
                                          i.depth,
                                          S,
                                          _,
                                          i.data,
                                      ))
                                    : n.texImage3D(
                                          32879,
                                          0,
                                          T,
                                          i.width,
                                          i.height,
                                          i.depth,
                                          0,
                                          S,
                                          _,
                                          i.data,
                                      );
                            else if (r.isFramebufferTexture) {
                                if (k)
                                    if (R)
                                        n.texStorage2D(
                                            3553,
                                            C,
                                            T,
                                            i.width,
                                            i.height,
                                        );
                                    else {
                                        let t = i.width,
                                            e = i.height;
                                        for (let i = 0; i < C; i++)
                                            n.texImage2D(
                                                3553,
                                                i,
                                                T,
                                                t,
                                                e,
                                                0,
                                                S,
                                                _,
                                                null,
                                            ),
                                                (t >>= 1),
                                                (e >>= 1);
                                    }
                            } else if (E.length > 0 && m) {
                                R &&
                                    k &&
                                    n.texStorage2D(
                                        3553,
                                        C,
                                        T,
                                        E[0].width,
                                        E[0].height,
                                    );
                                for (let t = 0, e = E.length; t < e; t++)
                                    (A = E[t]),
                                        R
                                            ? n.texSubImage2D(
                                                  3553,
                                                  t,
                                                  0,
                                                  0,
                                                  S,
                                                  _,
                                                  A,
                                              )
                                            : n.texImage2D(3553, t, T, S, _, A);
                                r.generateMipmaps = !1;
                            } else
                                R
                                    ? (k &&
                                          n.texStorage2D(
                                              3553,
                                              C,
                                              T,
                                              i.width,
                                              i.height,
                                          ),
                                      n.texSubImage2D(3553, 0, 0, 0, S, _, i))
                                    : n.texImage2D(3553, 0, T, S, _, i);
                            G(r, m) && j(o),
                                (d.__version = u.version),
                                r.onUpdate && r.onUpdate(r);
                        }
                        e.__version = r.version;
                    }
                    function it(e, r, a, s, o) {
                        const l = y.convert(a.format, a.encoding),
                            c = y.convert(a.type),
                            h = H(a.internalFormat, l, c, a.encoding);
                        i.get(r).__hasExternalTextures ||
                            (32879 === o || 35866 === o
                                ? n.texImage3D(
                                      o,
                                      0,
                                      h,
                                      r.width,
                                      r.height,
                                      r.depth,
                                      0,
                                      l,
                                      c,
                                      null,
                                  )
                                : n.texImage2D(
                                      o,
                                      0,
                                      h,
                                      r.width,
                                      r.height,
                                      0,
                                      l,
                                      c,
                                      null,
                                  )),
                            n.bindFramebuffer(36160, e),
                            ot(r)
                                ? E.framebufferTexture2DMultisampleEXT(
                                      36160,
                                      s,
                                      o,
                                      i.get(a).__webglTexture,
                                      0,
                                      st(r),
                                  )
                                : (3553 === o || (o >= 34069 && o <= 34074)) &&
                                  t.framebufferTexture2D(
                                      36160,
                                      s,
                                      o,
                                      i.get(a).__webglTexture,
                                      0,
                                  ),
                            n.bindFramebuffer(36160, null);
                    }
                    function rt(e, n, i) {
                        if (
                            (t.bindRenderbuffer(36161, e),
                            n.depthBuffer && !n.stencilBuffer)
                        ) {
                            let r = 33189;
                            if (i || ot(n)) {
                                const e = n.depthTexture;
                                e &&
                                    e.isDepthTexture &&
                                    (e.type === f
                                        ? (r = 36012)
                                        : e.type === p && (r = 33190));
                                const i = st(n);
                                ot(n)
                                    ? E.renderbufferStorageMultisampleEXT(
                                          36161,
                                          i,
                                          r,
                                          n.width,
                                          n.height,
                                      )
                                    : t.renderbufferStorageMultisample(
                                          36161,
                                          i,
                                          r,
                                          n.width,
                                          n.height,
                                      );
                            } else
                                t.renderbufferStorage(
                                    36161,
                                    r,
                                    n.width,
                                    n.height,
                                );
                            t.framebufferRenderbuffer(36160, 36096, 36161, e);
                        } else if (n.depthBuffer && n.stencilBuffer) {
                            const r = st(n);
                            i && !1 === ot(n)
                                ? t.renderbufferStorageMultisample(
                                      36161,
                                      r,
                                      35056,
                                      n.width,
                                      n.height,
                                  )
                                : ot(n)
                                ? E.renderbufferStorageMultisampleEXT(
                                      36161,
                                      r,
                                      35056,
                                      n.width,
                                      n.height,
                                  )
                                : t.renderbufferStorage(
                                      36161,
                                      34041,
                                      n.width,
                                      n.height,
                                  ),
                                t.framebufferRenderbuffer(
                                    36160,
                                    33306,
                                    36161,
                                    e,
                                );
                        } else {
                            const e =
                                !0 === n.isWebGLMultipleRenderTargets
                                    ? n.texture
                                    : [n.texture];
                            for (let r = 0; r < e.length; r++) {
                                const a = e[r],
                                    s = y.convert(a.format, a.encoding),
                                    o = y.convert(a.type),
                                    l = H(a.internalFormat, s, o, a.encoding),
                                    c = st(n);
                                i && !1 === ot(n)
                                    ? t.renderbufferStorageMultisample(
                                          36161,
                                          c,
                                          l,
                                          n.width,
                                          n.height,
                                      )
                                    : ot(n)
                                    ? E.renderbufferStorageMultisampleEXT(
                                          36161,
                                          c,
                                          l,
                                          n.width,
                                          n.height,
                                      )
                                    : t.renderbufferStorage(
                                          36161,
                                          l,
                                          n.width,
                                          n.height,
                                      );
                            }
                        }
                        t.bindRenderbuffer(36161, null);
                    }
                    function at(e) {
                        const r = i.get(e),
                            a = !0 === e.isWebGLCubeRenderTarget;
                        if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                            if (a)
                                throw new Error(
                                    "target.depthTexture not supported in Cube render targets",
                                );
                            !(function (e, r) {
                                if (r && r.isWebGLCubeRenderTarget)
                                    throw new Error(
                                        "Depth Texture with cube render targets is not supported",
                                    );
                                if (
                                    (n.bindFramebuffer(36160, e),
                                    !r.depthTexture ||
                                        !r.depthTexture.isDepthTexture)
                                )
                                    throw new Error(
                                        "renderTarget.depthTexture must be an instance of THREE.DepthTexture",
                                    );
                                (i.get(r.depthTexture).__webglTexture &&
                                    r.depthTexture.image.width === r.width &&
                                    r.depthTexture.image.height === r.height) ||
                                    ((r.depthTexture.image.width = r.width),
                                    (r.depthTexture.image.height = r.height),
                                    (r.depthTexture.needsUpdate = !0)),
                                    Z(r.depthTexture, 0);
                                const a = i.get(r.depthTexture).__webglTexture,
                                    s = st(r);
                                if (r.depthTexture.format === x)
                                    ot(r)
                                        ? E.framebufferTexture2DMultisampleEXT(
                                              36160,
                                              36096,
                                              3553,
                                              a,
                                              0,
                                              s,
                                          )
                                        : t.framebufferTexture2D(
                                              36160,
                                              36096,
                                              3553,
                                              a,
                                              0,
                                          );
                                else {
                                    if (r.depthTexture.format !== b)
                                        throw new Error(
                                            "Unknown depthTexture format",
                                        );
                                    ot(r)
                                        ? E.framebufferTexture2DMultisampleEXT(
                                              36160,
                                              33306,
                                              3553,
                                              a,
                                              0,
                                              s,
                                          )
                                        : t.framebufferTexture2D(
                                              36160,
                                              33306,
                                              3553,
                                              a,
                                              0,
                                          );
                                }
                            })(r.__webglFramebuffer, e);
                        } else if (a) {
                            r.__webglDepthbuffer = [];
                            for (let i = 0; i < 6; i++)
                                n.bindFramebuffer(
                                    36160,
                                    r.__webglFramebuffer[i],
                                ),
                                    (r.__webglDepthbuffer[i] =
                                        t.createRenderbuffer()),
                                    rt(r.__webglDepthbuffer[i], e, !1);
                        } else
                            n.bindFramebuffer(36160, r.__webglFramebuffer),
                                (r.__webglDepthbuffer = t.createRenderbuffer()),
                                rt(r.__webglDepthbuffer, e, !1);
                        n.bindFramebuffer(36160, null);
                    }
                    function st(t) {
                        return Math.min(T, t.samples);
                    }
                    function ot(t) {
                        const n = i.get(t);
                        return (
                            M &&
                            t.samples > 0 &&
                            !0 ===
                                e.has("WEBGL_multisampled_render_to_texture") &&
                            !1 !== n.__useRenderToTexture
                        );
                    }
                    function lt(t, n) {
                        const i = t.encoding,
                            r = t.format,
                            a = t.type;
                        return (
                            !0 === t.isCompressedTexture ||
                                !0 === t.isVideoTexture ||
                                t.format === U ||
                                (i !== C &&
                                    (i === L
                                        ? !1 === M
                                            ? !0 === e.has("EXT_sRGB") &&
                                              r === v
                                                ? ((t.format = U),
                                                  (t.minFilter = h),
                                                  (t.generateMipmaps = !1))
                                                : (n = ut.sRGBToLinear(n))
                                            : (r === v && a === d) ||
                                              console.warn(
                                                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.",
                                              )
                                        : console.error(
                                              "THREE.WebGLTextures: Unsupported texture encoding:",
                                              i,
                                          ))),
                            n
                        );
                    }
                    (this.allocateTextureUnit = function () {
                        const t = J;
                        return (
                            t >= A &&
                                console.warn(
                                    "THREE.WebGLTextures: Trying to use " +
                                        t +
                                        " texture units while this GPU supports only " +
                                        A,
                                ),
                            (J += 1),
                            t
                        );
                    }),
                        (this.resetTextureUnits = function () {
                            J = 0;
                        }),
                        (this.setTexture2D = Z),
                        (this.setTexture2DArray = function (t, e) {
                            const r = i.get(t);
                            t.version > 0 && r.__version !== t.version
                                ? nt(r, t, e)
                                : n.bindTexture(
                                      35866,
                                      r.__webglTexture,
                                      33984 + e,
                                  );
                        }),
                        (this.setTexture3D = function (t, e) {
                            const r = i.get(t);
                            t.version > 0 && r.__version !== t.version
                                ? nt(r, t, e)
                                : n.bindTexture(
                                      32879,
                                      r.__webglTexture,
                                      33984 + e,
                                  );
                        }),
                        (this.setTextureCube = function (e, r) {
                            const a = i.get(e);
                            e.version > 0 && a.__version !== e.version
                                ? (function (e, r, a) {
                                      if (6 !== r.image.length) return;
                                      const s = et(e, r),
                                          o = r.source;
                                      n.bindTexture(
                                          34067,
                                          e.__webglTexture,
                                          33984 + a,
                                      );
                                      const l = i.get(o);
                                      if (
                                          o.version !== l.__version ||
                                          !0 === s
                                      ) {
                                          n.activeTexture(33984 + a),
                                              t.pixelStorei(37440, r.flipY),
                                              t.pixelStorei(
                                                  37441,
                                                  r.premultiplyAlpha,
                                              ),
                                              t.pixelStorei(
                                                  3317,
                                                  r.unpackAlignment,
                                              ),
                                              t.pixelStorei(37443, 0);
                                          const e =
                                                  r.isCompressedTexture ||
                                                  r.image[0]
                                                      .isCompressedTexture,
                                              i =
                                                  r.image[0] &&
                                                  r.image[0].isDataTexture,
                                              c = [];
                                          for (let t = 0; t < 6; t++)
                                              (c[t] =
                                                  e || i
                                                      ? i
                                                          ? r.image[t].image
                                                          : r.image[t]
                                                      : V(
                                                            r.image[t],
                                                            !1,
                                                            !0,
                                                            _,
                                                        )),
                                                  (c[t] = lt(r, c[t]));
                                          const h = c[0],
                                              u = N(h) || M,
                                              d = y.convert(
                                                  r.format,
                                                  r.encoding,
                                              ),
                                              p = y.convert(r.type),
                                              f = H(
                                                  r.internalFormat,
                                                  d,
                                                  p,
                                                  r.encoding,
                                              ),
                                              m = M && !0 !== r.isVideoTexture,
                                              g =
                                                  void 0 === l.__version ||
                                                  !0 === s;
                                          let x,
                                              b = F(r, h, u);
                                          if ((tt(34067, r, u), e)) {
                                              m &&
                                                  g &&
                                                  n.texStorage2D(
                                                      34067,
                                                      b,
                                                      f,
                                                      h.width,
                                                      h.height,
                                                  );
                                              for (let t = 0; t < 6; t++) {
                                                  x = c[t].mipmaps;
                                                  for (
                                                      let e = 0;
                                                      e < x.length;
                                                      e++
                                                  ) {
                                                      const i = x[e];
                                                      r.format !== v
                                                          ? null !== d
                                                              ? m
                                                                  ? n.compressedTexSubImage2D(
                                                                        34069 +
                                                                            t,
                                                                        e,
                                                                        0,
                                                                        0,
                                                                        i.width,
                                                                        i.height,
                                                                        d,
                                                                        i.data,
                                                                    )
                                                                  : n.compressedTexImage2D(
                                                                        34069 +
                                                                            t,
                                                                        e,
                                                                        f,
                                                                        i.width,
                                                                        i.height,
                                                                        0,
                                                                        i.data,
                                                                    )
                                                              : console.warn(
                                                                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()",
                                                                )
                                                          : m
                                                          ? n.texSubImage2D(
                                                                34069 + t,
                                                                e,
                                                                0,
                                                                0,
                                                                i.width,
                                                                i.height,
                                                                d,
                                                                p,
                                                                i.data,
                                                            )
                                                          : n.texImage2D(
                                                                34069 + t,
                                                                e,
                                                                f,
                                                                i.width,
                                                                i.height,
                                                                0,
                                                                d,
                                                                p,
                                                                i.data,
                                                            );
                                                  }
                                              }
                                          } else {
                                              (x = r.mipmaps),
                                                  m &&
                                                      g &&
                                                      (x.length > 0 && b++,
                                                      n.texStorage2D(
                                                          34067,
                                                          b,
                                                          f,
                                                          c[0].width,
                                                          c[0].height,
                                                      ));
                                              for (let t = 0; t < 6; t++)
                                                  if (i) {
                                                      m
                                                          ? n.texSubImage2D(
                                                                34069 + t,
                                                                0,
                                                                0,
                                                                0,
                                                                c[t].width,
                                                                c[t].height,
                                                                d,
                                                                p,
                                                                c[t].data,
                                                            )
                                                          : n.texImage2D(
                                                                34069 + t,
                                                                0,
                                                                f,
                                                                c[t].width,
                                                                c[t].height,
                                                                0,
                                                                d,
                                                                p,
                                                                c[t].data,
                                                            );
                                                      for (
                                                          let e = 0;
                                                          e < x.length;
                                                          e++
                                                      ) {
                                                          const i =
                                                              x[e].image[t]
                                                                  .image;
                                                          m
                                                              ? n.texSubImage2D(
                                                                    34069 + t,
                                                                    e + 1,
                                                                    0,
                                                                    0,
                                                                    i.width,
                                                                    i.height,
                                                                    d,
                                                                    p,
                                                                    i.data,
                                                                )
                                                              : n.texImage2D(
                                                                    34069 + t,
                                                                    e + 1,
                                                                    f,
                                                                    i.width,
                                                                    i.height,
                                                                    0,
                                                                    d,
                                                                    p,
                                                                    i.data,
                                                                );
                                                      }
                                                  } else {
                                                      m
                                                          ? n.texSubImage2D(
                                                                34069 + t,
                                                                0,
                                                                0,
                                                                0,
                                                                d,
                                                                p,
                                                                c[t],
                                                            )
                                                          : n.texImage2D(
                                                                34069 + t,
                                                                0,
                                                                f,
                                                                d,
                                                                p,
                                                                c[t],
                                                            );
                                                      for (
                                                          let e = 0;
                                                          e < x.length;
                                                          e++
                                                      ) {
                                                          const i = x[e];
                                                          m
                                                              ? n.texSubImage2D(
                                                                    34069 + t,
                                                                    e + 1,
                                                                    0,
                                                                    0,
                                                                    d,
                                                                    p,
                                                                    i.image[t],
                                                                )
                                                              : n.texImage2D(
                                                                    34069 + t,
                                                                    e + 1,
                                                                    f,
                                                                    d,
                                                                    p,
                                                                    i.image[t],
                                                                );
                                                      }
                                                  }
                                          }
                                          G(r, u) && j(34067),
                                              (l.__version = o.version),
                                              r.onUpdate && r.onUpdate(r);
                                      }
                                      e.__version = r.version;
                                  })(a, e, r)
                                : n.bindTexture(
                                      34067,
                                      a.__webglTexture,
                                      33984 + r,
                                  );
                        }),
                        (this.rebindTextures = function (t, e, n) {
                            const r = i.get(t);
                            void 0 !== e &&
                                it(
                                    r.__webglFramebuffer,
                                    t,
                                    t.texture,
                                    36064,
                                    3553,
                                ),
                                void 0 !== n && at(t);
                        }),
                        (this.setupRenderTarget = function (e) {
                            const a = e.texture,
                                s = i.get(e),
                                o = i.get(a);
                            e.addEventListener("dispose", Y),
                                !0 !== e.isWebGLMultipleRenderTargets &&
                                    (void 0 === o.__webglTexture &&
                                        (o.__webglTexture = t.createTexture()),
                                    (o.__version = a.version),
                                    S.memory.textures++);
                            const l = !0 === e.isWebGLCubeRenderTarget,
                                c = !0 === e.isWebGLMultipleRenderTargets,
                                h = N(e) || M;
                            if (l) {
                                s.__webglFramebuffer = [];
                                for (let e = 0; e < 6; e++)
                                    s.__webglFramebuffer[e] =
                                        t.createFramebuffer();
                            } else {
                                if (
                                    ((s.__webglFramebuffer =
                                        t.createFramebuffer()),
                                    c)
                                )
                                    if (r.drawBuffers) {
                                        const n = e.texture;
                                        for (
                                            let e = 0, r = n.length;
                                            e < r;
                                            e++
                                        ) {
                                            const r = i.get(n[e]);
                                            void 0 === r.__webglTexture &&
                                                ((r.__webglTexture =
                                                    t.createTexture()),
                                                S.memory.textures++);
                                        }
                                    } else
                                        console.warn(
                                            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.",
                                        );
                                if (M && e.samples > 0 && !1 === ot(e)) {
                                    const i = c ? a : [a];
                                    (s.__webglMultisampledFramebuffer =
                                        t.createFramebuffer()),
                                        (s.__webglColorRenderbuffer = []),
                                        n.bindFramebuffer(
                                            36160,
                                            s.__webglMultisampledFramebuffer,
                                        );
                                    for (let n = 0; n < i.length; n++) {
                                        const r = i[n];
                                        (s.__webglColorRenderbuffer[n] =
                                            t.createRenderbuffer()),
                                            t.bindRenderbuffer(
                                                36161,
                                                s.__webglColorRenderbuffer[n],
                                            );
                                        const a = y.convert(
                                                r.format,
                                                r.encoding,
                                            ),
                                            o = y.convert(r.type),
                                            l = H(
                                                r.internalFormat,
                                                a,
                                                o,
                                                r.encoding,
                                                !0 === e.isXRRenderTarget,
                                            ),
                                            c = st(e);
                                        t.renderbufferStorageMultisample(
                                            36161,
                                            c,
                                            l,
                                            e.width,
                                            e.height,
                                        ),
                                            t.framebufferRenderbuffer(
                                                36160,
                                                36064 + n,
                                                36161,
                                                s.__webglColorRenderbuffer[n],
                                            );
                                    }
                                    t.bindRenderbuffer(36161, null),
                                        e.depthBuffer &&
                                            ((s.__webglDepthRenderbuffer =
                                                t.createRenderbuffer()),
                                            rt(
                                                s.__webglDepthRenderbuffer,
                                                e,
                                                !0,
                                            )),
                                        n.bindFramebuffer(36160, null);
                                }
                            }
                            if (l) {
                                n.bindTexture(34067, o.__webglTexture),
                                    tt(34067, a, h);
                                for (let t = 0; t < 6; t++)
                                    it(
                                        s.__webglFramebuffer[t],
                                        e,
                                        a,
                                        36064,
                                        34069 + t,
                                    );
                                G(a, h) && j(34067), n.unbindTexture();
                            } else if (c) {
                                const t = e.texture;
                                for (let r = 0, a = t.length; r < a; r++) {
                                    const a = t[r],
                                        o = i.get(a);
                                    n.bindTexture(3553, o.__webglTexture),
                                        tt(3553, a, h),
                                        it(
                                            s.__webglFramebuffer,
                                            e,
                                            a,
                                            36064 + r,
                                            3553,
                                        ),
                                        G(a, h) && j(3553);
                                }
                                n.unbindTexture();
                            } else {
                                let t = 3553;
                                (e.isWebGL3DRenderTarget ||
                                    e.isWebGLArrayRenderTarget) &&
                                    (M
                                        ? (t = e.isWebGL3DRenderTarget
                                              ? 32879
                                              : 35866)
                                        : console.error(
                                              "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.",
                                          )),
                                    n.bindTexture(t, o.__webglTexture),
                                    tt(t, a, h),
                                    it(s.__webglFramebuffer, e, a, 36064, t),
                                    G(a, h) && j(t),
                                    n.unbindTexture();
                            }
                            e.depthBuffer && at(e);
                        }),
                        (this.updateRenderTargetMipmap = function (t) {
                            const e = N(t) || M,
                                r =
                                    !0 === t.isWebGLMultipleRenderTargets
                                        ? t.texture
                                        : [t.texture];
                            for (let a = 0, s = r.length; a < s; a++) {
                                const s = r[a];
                                if (G(s, e)) {
                                    const e = t.isWebGLCubeRenderTarget
                                            ? 34067
                                            : 3553,
                                        r = i.get(s).__webglTexture;
                                    n.bindTexture(e, r),
                                        j(e),
                                        n.unbindTexture();
                                }
                            }
                        }),
                        (this.updateMultisampleRenderTarget = function (e) {
                            if (M && e.samples > 0 && !1 === ot(e)) {
                                const r = e.isWebGLMultipleRenderTargets
                                        ? e.texture
                                        : [e.texture],
                                    a = e.width,
                                    s = e.height;
                                let o = 16384;
                                const l = [],
                                    c = e.stencilBuffer ? 33306 : 36096,
                                    h = i.get(e),
                                    u = !0 === e.isWebGLMultipleRenderTargets;
                                if (u)
                                    for (let e = 0; e < r.length; e++)
                                        n.bindFramebuffer(
                                            36160,
                                            h.__webglMultisampledFramebuffer,
                                        ),
                                            t.framebufferRenderbuffer(
                                                36160,
                                                36064 + e,
                                                36161,
                                                null,
                                            ),
                                            n.bindFramebuffer(
                                                36160,
                                                h.__webglFramebuffer,
                                            ),
                                            t.framebufferTexture2D(
                                                36009,
                                                36064 + e,
                                                3553,
                                                null,
                                                0,
                                            );
                                n.bindFramebuffer(
                                    36008,
                                    h.__webglMultisampledFramebuffer,
                                ),
                                    n.bindFramebuffer(
                                        36009,
                                        h.__webglFramebuffer,
                                    );
                                for (let n = 0; n < r.length; n++) {
                                    l.push(36064 + n),
                                        e.depthBuffer && l.push(c);
                                    const d =
                                        void 0 !== h.__ignoreDepthValues &&
                                        h.__ignoreDepthValues;
                                    if (
                                        (!1 === d &&
                                            (e.depthBuffer && (o |= 256),
                                            e.stencilBuffer && (o |= 1024)),
                                        u &&
                                            t.framebufferRenderbuffer(
                                                36008,
                                                36064,
                                                36161,
                                                h.__webglColorRenderbuffer[n],
                                            ),
                                        !0 === d &&
                                            (t.invalidateFramebuffer(36008, [
                                                c,
                                            ]),
                                            t.invalidateFramebuffer(36009, [
                                                c,
                                            ])),
                                        u)
                                    ) {
                                        const e = i.get(r[n]).__webglTexture;
                                        t.framebufferTexture2D(
                                            36009,
                                            36064,
                                            3553,
                                            e,
                                            0,
                                        );
                                    }
                                    t.blitFramebuffer(
                                        0,
                                        0,
                                        a,
                                        s,
                                        0,
                                        0,
                                        a,
                                        s,
                                        o,
                                        9728,
                                    ),
                                        R && t.invalidateFramebuffer(36008, l);
                                }
                                if (
                                    (n.bindFramebuffer(36008, null),
                                    n.bindFramebuffer(36009, null),
                                    u)
                                )
                                    for (let e = 0; e < r.length; e++) {
                                        n.bindFramebuffer(
                                            36160,
                                            h.__webglMultisampledFramebuffer,
                                        ),
                                            t.framebufferRenderbuffer(
                                                36160,
                                                36064 + e,
                                                36161,
                                                h.__webglColorRenderbuffer[e],
                                            );
                                        const a = i.get(r[e]).__webglTexture;
                                        n.bindFramebuffer(
                                            36160,
                                            h.__webglFramebuffer,
                                        ),
                                            t.framebufferTexture2D(
                                                36009,
                                                36064 + e,
                                                3553,
                                                a,
                                                0,
                                            );
                                    }
                                n.bindFramebuffer(
                                    36009,
                                    h.__webglMultisampledFramebuffer,
                                );
                            }
                        }),
                        (this.setupDepthRenderbuffer = at),
                        (this.setupFrameBufferTexture = it),
                        (this.useMultisampledRTT = ot);
                }
                function $r(t, e, n) {
                    const i = n.isWebGL2;
                    return {
                        convert: function (n, r = null) {
                            let a;
                            if (n === d) return 5121;
                            if (1017 === n) return 32819;
                            if (1018 === n) return 32820;
                            if (1010 === n) return 5120;
                            if (1011 === n) return 5122;
                            if (1012 === n) return 5123;
                            if (1013 === n) return 5124;
                            if (n === p) return 5125;
                            if (n === f) return 5126;
                            if (n === m)
                                return i
                                    ? 5131
                                    : ((a = e.get("OES_texture_half_float")),
                                      null !== a ? a.HALF_FLOAT_OES : null);
                            if (1021 === n) return 6406;
                            if (n === v) return 6408;
                            if (1024 === n) return 6409;
                            if (1025 === n) return 6410;
                            if (n === x) return 6402;
                            if (n === b) return 34041;
                            if (1022 === n)
                                return (
                                    console.warn(
                                        "THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228",
                                    ),
                                    6408
                                );
                            if (n === U)
                                return (
                                    (a = e.get("EXT_sRGB")),
                                    null !== a ? a.SRGB_ALPHA_EXT : null
                                );
                            if (1028 === n) return 6403;
                            if (1029 === n) return 36244;
                            if (1030 === n) return 33319;
                            if (1031 === n) return 33320;
                            if (1033 === n) return 36249;
                            if (n === y || n === S || n === M || n === A)
                                if (r === L) {
                                    if (
                                        ((a = e.get(
                                            "WEBGL_compressed_texture_s3tc_srgb",
                                        )),
                                        null === a)
                                    )
                                        return null;
                                    if (n === y)
                                        return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                    if (n === S)
                                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                    if (n === M)
                                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                    if (n === A)
                                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                                } else {
                                    if (
                                        ((a = e.get(
                                            "WEBGL_compressed_texture_s3tc",
                                        )),
                                        null === a)
                                    )
                                        return null;
                                    if (n === y)
                                        return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                    if (n === S)
                                        return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                    if (n === M)
                                        return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                    if (n === A)
                                        return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                                }
                            if (
                                35840 === n ||
                                35841 === n ||
                                35842 === n ||
                                35843 === n
                            ) {
                                if (
                                    ((a = e.get(
                                        "WEBGL_compressed_texture_pvrtc",
                                    )),
                                    null === a)
                                )
                                    return null;
                                if (35840 === n)
                                    return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                if (35841 === n)
                                    return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                if (35842 === n)
                                    return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                if (35843 === n)
                                    return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                            }
                            if (36196 === n)
                                return (
                                    (a = e.get(
                                        "WEBGL_compressed_texture_etc1",
                                    )),
                                    null !== a
                                        ? a.COMPRESSED_RGB_ETC1_WEBGL
                                        : null
                                );
                            if (37492 === n || 37496 === n) {
                                if (
                                    ((a = e.get(
                                        "WEBGL_compressed_texture_etc",
                                    )),
                                    null === a)
                                )
                                    return null;
                                if (37492 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB8_ETC2
                                        : a.COMPRESSED_RGB8_ETC2;
                                if (37496 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                                        : a.COMPRESSED_RGBA8_ETC2_EAC;
                            }
                            if (
                                37808 === n ||
                                37809 === n ||
                                37810 === n ||
                                37811 === n ||
                                37812 === n ||
                                37813 === n ||
                                37814 === n ||
                                37815 === n ||
                                37816 === n ||
                                37817 === n ||
                                37818 === n ||
                                37819 === n ||
                                37820 === n ||
                                37821 === n
                            ) {
                                if (
                                    ((a = e.get(
                                        "WEBGL_compressed_texture_astc",
                                    )),
                                    null === a)
                                )
                                    return null;
                                if (37808 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                                        : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                                if (37809 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                                        : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                                if (37810 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                                        : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                                if (37811 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                                        : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                                if (37812 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                                        : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                                if (37813 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                                        : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                                if (37814 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                                        : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                                if (37815 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                                        : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                                if (37816 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                                        : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                                if (37817 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                                        : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                                if (37818 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                                        : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                                if (37819 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                                        : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                                if (37820 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                                        : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                                if (37821 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                                        : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
                            }
                            if (36492 === n) {
                                if (
                                    ((a = e.get(
                                        "EXT_texture_compression_bptc",
                                    )),
                                    null === a)
                                )
                                    return null;
                                if (36492 === n)
                                    return r === L
                                        ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                                        : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                            }
                            return n === g
                                ? i
                                    ? 34042
                                    : ((a = e.get("WEBGL_depth_texture")),
                                      null !== a
                                          ? a.UNSIGNED_INT_24_8_WEBGL
                                          : null)
                                : void 0 !== t[n]
                                ? t[n]
                                : null;
                        },
                    };
                }
                class ta extends yn {
                    constructor(t = []) {
                        super(), (this.isArrayCamera = !0), (this.cameras = t);
                    }
                }
                class ea extends Me {
                    constructor() {
                        super(), (this.isGroup = !0), (this.type = "Group");
                    }
                }
                const na = { type: "move" };
                class ia {
                    constructor() {
                        (this._targetRay = null),
                            (this._grip = null),
                            (this._hand = null);
                    }
                    getHandSpace() {
                        return (
                            null === this._hand &&
                                ((this._hand = new ea()),
                                (this._hand.matrixAutoUpdate = !1),
                                (this._hand.visible = !1),
                                (this._hand.joints = {}),
                                (this._hand.inputState = { pinching: !1 })),
                            this._hand
                        );
                    }
                    getTargetRaySpace() {
                        return (
                            null === this._targetRay &&
                                ((this._targetRay = new ea()),
                                (this._targetRay.matrixAutoUpdate = !1),
                                (this._targetRay.visible = !1),
                                (this._targetRay.hasLinearVelocity = !1),
                                (this._targetRay.linearVelocity = new St()),
                                (this._targetRay.hasAngularVelocity = !1),
                                (this._targetRay.angularVelocity = new St())),
                            this._targetRay
                        );
                    }
                    getGripSpace() {
                        return (
                            null === this._grip &&
                                ((this._grip = new ea()),
                                (this._grip.matrixAutoUpdate = !1),
                                (this._grip.visible = !1),
                                (this._grip.hasLinearVelocity = !1),
                                (this._grip.linearVelocity = new St()),
                                (this._grip.hasAngularVelocity = !1),
                                (this._grip.angularVelocity = new St())),
                            this._grip
                        );
                    }
                    dispatchEvent(t) {
                        return (
                            null !== this._targetRay &&
                                this._targetRay.dispatchEvent(t),
                            null !== this._grip && this._grip.dispatchEvent(t),
                            null !== this._hand && this._hand.dispatchEvent(t),
                            this
                        );
                    }
                    connect(t) {
                        if (t && t.hand) {
                            const e = this._hand;
                            if (e)
                                for (const n of t.hand.values())
                                    this._getHandJoint(e, n);
                        }
                        return (
                            this.dispatchEvent({ type: "connected", data: t }),
                            this
                        );
                    }
                    disconnect(t) {
                        return (
                            this.dispatchEvent({
                                type: "disconnected",
                                data: t,
                            }),
                            null !== this._targetRay &&
                                (this._targetRay.visible = !1),
                            null !== this._grip && (this._grip.visible = !1),
                            null !== this._hand && (this._hand.visible = !1),
                            this
                        );
                    }
                    update(t, e, n) {
                        let i = null,
                            r = null,
                            a = null;
                        const s = this._targetRay,
                            o = this._grip,
                            l = this._hand;
                        if (
                            t &&
                            "visible-blurred" !== e.session.visibilityState
                        ) {
                            if (l && t.hand) {
                                a = !0;
                                for (const i of t.hand.values()) {
                                    const t = e.getJointPose(i, n),
                                        r = this._getHandJoint(l, i);
                                    null !== t &&
                                        (r.matrix.fromArray(t.transform.matrix),
                                        r.matrix.decompose(
                                            r.position,
                                            r.rotation,
                                            r.scale,
                                        ),
                                        (r.jointRadius = t.radius)),
                                        (r.visible = null !== t);
                                }
                                const i = l.joints["index-finger-tip"],
                                    r = l.joints["thumb-tip"],
                                    s = i.position.distanceTo(r.position),
                                    o = 0.02,
                                    c = 0.005;
                                l.inputState.pinching && s > o + c
                                    ? ((l.inputState.pinching = !1),
                                      this.dispatchEvent({
                                          type: "pinchend",
                                          handedness: t.handedness,
                                          target: this,
                                      }))
                                    : !l.inputState.pinching &&
                                      s <= o - c &&
                                      ((l.inputState.pinching = !0),
                                      this.dispatchEvent({
                                          type: "pinchstart",
                                          handedness: t.handedness,
                                          target: this,
                                      }));
                            } else
                                null !== o &&
                                    t.gripSpace &&
                                    ((r = e.getPose(t.gripSpace, n)),
                                    null !== r &&
                                        (o.matrix.fromArray(r.transform.matrix),
                                        o.matrix.decompose(
                                            o.position,
                                            o.rotation,
                                            o.scale,
                                        ),
                                        r.linearVelocity
                                            ? ((o.hasLinearVelocity = !0),
                                              o.linearVelocity.copy(
                                                  r.linearVelocity,
                                              ))
                                            : (o.hasLinearVelocity = !1),
                                        r.angularVelocity
                                            ? ((o.hasAngularVelocity = !0),
                                              o.angularVelocity.copy(
                                                  r.angularVelocity,
                                              ))
                                            : (o.hasAngularVelocity = !1)));
                            null !== s &&
                                ((i = e.getPose(t.targetRaySpace, n)),
                                null === i && null !== r && (i = r),
                                null !== i &&
                                    (s.matrix.fromArray(i.transform.matrix),
                                    s.matrix.decompose(
                                        s.position,
                                        s.rotation,
                                        s.scale,
                                    ),
                                    i.linearVelocity
                                        ? ((s.hasLinearVelocity = !0),
                                          s.linearVelocity.copy(
                                              i.linearVelocity,
                                          ))
                                        : (s.hasLinearVelocity = !1),
                                    i.angularVelocity
                                        ? ((s.hasAngularVelocity = !0),
                                          s.angularVelocity.copy(
                                              i.angularVelocity,
                                          ))
                                        : (s.hasAngularVelocity = !1),
                                    this.dispatchEvent(na)));
                        }
                        return (
                            null !== s && (s.visible = null !== i),
                            null !== o && (o.visible = null !== r),
                            null !== l && (l.visible = null !== a),
                            this
                        );
                    }
                    _getHandJoint(t, e) {
                        if (void 0 === t.joints[e.jointName]) {
                            const n = new ea();
                            (n.matrixAutoUpdate = !1),
                                (n.visible = !1),
                                (t.joints[e.jointName] = n),
                                t.add(n);
                        }
                        return t.joints[e.jointName];
                    }
                }
                class ra extends mt {
                    constructor(t, e, n, i, r, a, s, o, c, h) {
                        if ((h = void 0 !== h ? h : x) !== x && h !== b)
                            throw new Error(
                                "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat",
                            );
                        void 0 === n && h === x && (n = p),
                            void 0 === n && h === b && (n = g),
                            super(null, i, r, a, s, o, h, n, c),
                            (this.isDepthTexture = !0),
                            (this.image = { width: t, height: e }),
                            (this.magFilter = void 0 !== s ? s : l),
                            (this.minFilter = void 0 !== o ? o : l),
                            (this.flipY = !1),
                            (this.generateMipmaps = !1);
                    }
                }
                class aa extends V {
                    constructor(t, e) {
                        super();
                        const n = this;
                        let i = null,
                            r = 1,
                            a = null,
                            s = "local-floor",
                            o = null,
                            l = null,
                            c = null,
                            h = null,
                            u = null,
                            f = null;
                        const m = e.getContextAttributes();
                        let y = null,
                            S = null;
                        const M = [],
                            A = [],
                            _ = new Set(),
                            w = new Map(),
                            T = new yn();
                        T.layers.enable(1), (T.viewport = new gt());
                        const E = new yn();
                        E.layers.enable(2), (E.viewport = new gt());
                        const R = [T, E],
                            k = new ta();
                        k.layers.enable(1), k.layers.enable(2);
                        let C = null,
                            L = null;
                        function I(t) {
                            const e = A.indexOf(t.inputSource);
                            if (-1 === e) return;
                            const n = M[e];
                            void 0 !== n &&
                                n.dispatchEvent({
                                    type: t.type,
                                    data: t.inputSource,
                                });
                        }
                        function O() {
                            i.removeEventListener("select", I),
                                i.removeEventListener("selectstart", I),
                                i.removeEventListener("selectend", I),
                                i.removeEventListener("squeeze", I),
                                i.removeEventListener("squeezestart", I),
                                i.removeEventListener("squeezeend", I),
                                i.removeEventListener("end", O),
                                i.removeEventListener("inputsourceschange", D);
                            for (let t = 0; t < M.length; t++) {
                                const e = A[t];
                                null !== e &&
                                    ((A[t] = null), M[t].disconnect(e));
                            }
                            (C = null),
                                (L = null),
                                t.setRenderTarget(y),
                                (u = null),
                                (h = null),
                                (c = null),
                                (i = null),
                                (S = null),
                                G.stop(),
                                (n.isPresenting = !1),
                                n.dispatchEvent({ type: "sessionend" });
                        }
                        function D(t) {
                            for (let e = 0; e < t.removed.length; e++) {
                                const n = t.removed[e],
                                    i = A.indexOf(n);
                                i >= 0 && ((A[i] = null), M[i].disconnect(n));
                            }
                            for (let e = 0; e < t.added.length; e++) {
                                const n = t.added[e];
                                let i = A.indexOf(n);
                                if (-1 === i) {
                                    for (let t = 0; t < M.length; t++) {
                                        if (t >= A.length) {
                                            A.push(n), (i = t);
                                            break;
                                        }
                                        if (null === A[t]) {
                                            (A[t] = n), (i = t);
                                            break;
                                        }
                                    }
                                    if (-1 === i) break;
                                }
                                const r = M[i];
                                r && r.connect(n);
                            }
                        }
                        (this.cameraAutoUpdate = !0),
                            (this.enabled = !1),
                            (this.isPresenting = !1),
                            (this.getController = function (t) {
                                let e = M[t];
                                return (
                                    void 0 === e &&
                                        ((e = new ia()), (M[t] = e)),
                                    e.getTargetRaySpace()
                                );
                            }),
                            (this.getControllerGrip = function (t) {
                                let e = M[t];
                                return (
                                    void 0 === e &&
                                        ((e = new ia()), (M[t] = e)),
                                    e.getGripSpace()
                                );
                            }),
                            (this.getHand = function (t) {
                                let e = M[t];
                                return (
                                    void 0 === e &&
                                        ((e = new ia()), (M[t] = e)),
                                    e.getHandSpace()
                                );
                            }),
                            (this.setFramebufferScaleFactor = function (t) {
                                (r = t),
                                    !0 === n.isPresenting &&
                                        console.warn(
                                            "THREE.WebXRManager: Cannot change framebuffer scale while presenting.",
                                        );
                            }),
                            (this.setReferenceSpaceType = function (t) {
                                (s = t),
                                    !0 === n.isPresenting &&
                                        console.warn(
                                            "THREE.WebXRManager: Cannot change reference space type while presenting.",
                                        );
                            }),
                            (this.getReferenceSpace = function () {
                                return o || a;
                            }),
                            (this.setReferenceSpace = function (t) {
                                o = t;
                            }),
                            (this.getBaseLayer = function () {
                                return null !== h ? h : u;
                            }),
                            (this.getBinding = function () {
                                return c;
                            }),
                            (this.getFrame = function () {
                                return f;
                            }),
                            (this.getSession = function () {
                                return i;
                            }),
                            (this.setSession = async function (l) {
                                if (((i = l), null !== i)) {
                                    if (
                                        ((y = t.getRenderTarget()),
                                        i.addEventListener("select", I),
                                        i.addEventListener("selectstart", I),
                                        i.addEventListener("selectend", I),
                                        i.addEventListener("squeeze", I),
                                        i.addEventListener("squeezestart", I),
                                        i.addEventListener("squeezeend", I),
                                        i.addEventListener("end", O),
                                        i.addEventListener(
                                            "inputsourceschange",
                                            D,
                                        ),
                                        !0 !== m.xrCompatible &&
                                            (await e.makeXRCompatible()),
                                        void 0 === i.renderState.layers ||
                                            !1 === t.capabilities.isWebGL2)
                                    ) {
                                        const n = {
                                            antialias:
                                                void 0 !==
                                                    i.renderState.layers ||
                                                m.antialias,
                                            alpha: m.alpha,
                                            depth: m.depth,
                                            stencil: m.stencil,
                                            framebufferScaleFactor: r,
                                        };
                                        (u = new XRWebGLLayer(i, e, n)),
                                            i.updateRenderState({
                                                baseLayer: u,
                                            }),
                                            (S = new vt(
                                                u.framebufferWidth,
                                                u.framebufferHeight,
                                                {
                                                    format: v,
                                                    type: d,
                                                    encoding: t.outputEncoding,
                                                    stencilBuffer: m.stencil,
                                                },
                                            ));
                                    } else {
                                        let n = null,
                                            a = null,
                                            s = null;
                                        m.depth &&
                                            ((s = m.stencil ? 35056 : 33190),
                                            (n = m.stencil ? b : x),
                                            (a = m.stencil ? g : p));
                                        const o = {
                                            colorFormat: 32856,
                                            depthFormat: s,
                                            scaleFactor: r,
                                        };
                                        (c = new XRWebGLBinding(i, e)),
                                            (h = c.createProjectionLayer(o)),
                                            i.updateRenderState({
                                                layers: [h],
                                            }),
                                            (S = new vt(
                                                h.textureWidth,
                                                h.textureHeight,
                                                {
                                                    format: v,
                                                    type: d,
                                                    depthTexture: new ra(
                                                        h.textureWidth,
                                                        h.textureHeight,
                                                        a,
                                                        void 0,
                                                        void 0,
                                                        void 0,
                                                        void 0,
                                                        void 0,
                                                        void 0,
                                                        n,
                                                    ),
                                                    stencilBuffer: m.stencil,
                                                    encoding: t.outputEncoding,
                                                    samples: m.antialias
                                                        ? 4
                                                        : 0,
                                                },
                                            )),
                                            (t.properties.get(
                                                S,
                                            ).__ignoreDepthValues =
                                                h.ignoreDepthValues);
                                    }
                                    (S.isXRRenderTarget = !0),
                                        this.setFoveation(1),
                                        (o = null),
                                        (a = await i.requestReferenceSpace(s)),
                                        G.setContext(i),
                                        G.start(),
                                        (n.isPresenting = !0),
                                        n.dispatchEvent({
                                            type: "sessionstart",
                                        });
                                }
                            });
                        const P = new St(),
                            U = new St();
                        function V(t, e) {
                            null === e
                                ? t.matrixWorld.copy(t.matrix)
                                : t.matrixWorld.multiplyMatrices(
                                      e.matrixWorld,
                                      t.matrix,
                                  ),
                                t.matrixWorldInverse
                                    .copy(t.matrixWorld)
                                    .invert();
                        }
                        (this.updateCamera = function (t) {
                            if (null === i) return;
                            (k.near = E.near = T.near = t.near),
                                (k.far = E.far = T.far = t.far),
                                (C === k.near && L === k.far) ||
                                    (i.updateRenderState({
                                        depthNear: k.near,
                                        depthFar: k.far,
                                    }),
                                    (C = k.near),
                                    (L = k.far));
                            const e = t.parent,
                                n = k.cameras;
                            V(k, e);
                            for (let t = 0; t < n.length; t++) V(n[t], e);
                            k.matrixWorld.decompose(
                                k.position,
                                k.quaternion,
                                k.scale,
                            ),
                                t.matrix.copy(k.matrix),
                                t.matrix.decompose(
                                    t.position,
                                    t.quaternion,
                                    t.scale,
                                );
                            const r = t.children;
                            for (let t = 0, e = r.length; t < e; t++)
                                r[t].updateMatrixWorld(!0);
                            2 === n.length
                                ? (function (t, e, n) {
                                      P.setFromMatrixPosition(e.matrixWorld),
                                          U.setFromMatrixPosition(
                                              n.matrixWorld,
                                          );
                                      const i = P.distanceTo(U),
                                          r = e.projectionMatrix.elements,
                                          a = n.projectionMatrix.elements,
                                          s = r[14] / (r[10] - 1),
                                          o = r[14] / (r[10] + 1),
                                          l = (r[9] + 1) / r[5],
                                          c = (r[9] - 1) / r[5],
                                          h = (r[8] - 1) / r[0],
                                          u = (a[8] + 1) / a[0],
                                          d = s * h,
                                          p = s * u,
                                          f = i / (-h + u),
                                          m = f * -h;
                                      e.matrixWorld.decompose(
                                          t.position,
                                          t.quaternion,
                                          t.scale,
                                      ),
                                          t.translateX(m),
                                          t.translateZ(f),
                                          t.matrixWorld.compose(
                                              t.position,
                                              t.quaternion,
                                              t.scale,
                                          ),
                                          t.matrixWorldInverse
                                              .copy(t.matrixWorld)
                                              .invert();
                                      const g = s + f,
                                          v = o + f,
                                          x = d - m,
                                          b = p + (i - m),
                                          y = ((l * o) / v) * g,
                                          S = ((c * o) / v) * g;
                                      t.projectionMatrix.makePerspective(
                                          x,
                                          b,
                                          y,
                                          S,
                                          g,
                                          v,
                                      );
                                  })(k, T, E)
                                : k.projectionMatrix.copy(T.projectionMatrix);
                        }),
                            (this.getCamera = function () {
                                return k;
                            }),
                            (this.getFoveation = function () {
                                return null !== h
                                    ? h.fixedFoveation
                                    : null !== u
                                    ? u.fixedFoveation
                                    : void 0;
                            }),
                            (this.setFoveation = function (t) {
                                null !== h && (h.fixedFoveation = t),
                                    null !== u &&
                                        void 0 !== u.fixedFoveation &&
                                        (u.fixedFoveation = t);
                            }),
                            (this.getPlanes = function () {
                                return _;
                            });
                        let N = null;
                        const G = new In();
                        G.setAnimationLoop(function (e, i) {
                            if (
                                ((l = i.getViewerPose(o || a)),
                                (f = i),
                                null !== l)
                            ) {
                                const e = l.views;
                                null !== u &&
                                    (t.setRenderTargetFramebuffer(
                                        S,
                                        u.framebuffer,
                                    ),
                                    t.setRenderTarget(S));
                                let n = !1;
                                e.length !== k.cameras.length &&
                                    ((k.cameras.length = 0), (n = !0));
                                for (let i = 0; i < e.length; i++) {
                                    const r = e[i];
                                    let a = null;
                                    if (null !== u) a = u.getViewport(r);
                                    else {
                                        const e = c.getViewSubImage(h, r);
                                        (a = e.viewport),
                                            0 === i &&
                                                (t.setRenderTargetTextures(
                                                    S,
                                                    e.colorTexture,
                                                    h.ignoreDepthValues
                                                        ? void 0
                                                        : e.depthStencilTexture,
                                                ),
                                                t.setRenderTarget(S));
                                    }
                                    let s = R[i];
                                    void 0 === s &&
                                        ((s = new yn()),
                                        s.layers.enable(i),
                                        (s.viewport = new gt()),
                                        (R[i] = s)),
                                        s.matrix.fromArray(r.transform.matrix),
                                        s.projectionMatrix.fromArray(
                                            r.projectionMatrix,
                                        ),
                                        s.viewport.set(
                                            a.x,
                                            a.y,
                                            a.width,
                                            a.height,
                                        ),
                                        0 === i && k.matrix.copy(s.matrix),
                                        !0 === n && k.cameras.push(s);
                                }
                            }
                            for (let t = 0; t < M.length; t++) {
                                const e = A[t],
                                    n = M[t];
                                null !== e &&
                                    void 0 !== n &&
                                    n.update(e, i, o || a);
                            }
                            if ((N && N(e, i), i.detectedPlanes)) {
                                n.dispatchEvent({
                                    type: "planesdetected",
                                    data: i.detectedPlanes,
                                });
                                let t = null;
                                for (const e of _)
                                    i.detectedPlanes.has(e) ||
                                        (null === t && (t = []), t.push(e));
                                if (null !== t)
                                    for (const e of t)
                                        _.delete(e),
                                            w.delete(e),
                                            n.dispatchEvent({
                                                type: "planeremoved",
                                                data: e,
                                            });
                                for (const t of i.detectedPlanes)
                                    if (_.has(t)) {
                                        const e = w.get(t);
                                        t.lastChangedTime > e &&
                                            (w.set(t, t.lastChangedTime),
                                            n.dispatchEvent({
                                                type: "planechanged",
                                                data: t,
                                            }));
                                    } else
                                        _.add(t),
                                            w.set(t, i.lastChangedTime),
                                            n.dispatchEvent({
                                                type: "planeadded",
                                                data: t,
                                            });
                            }
                            f = null;
                        }),
                            (this.setAnimationLoop = function (t) {
                                N = t;
                            }),
                            (this.dispose = function () {});
                    }
                }
                function sa(t, e) {
                    function n(n, i) {
                        (n.opacity.value = i.opacity),
                            i.color && n.diffuse.value.copy(i.color),
                            i.emissive &&
                                n.emissive.value
                                    .copy(i.emissive)
                                    .multiplyScalar(i.emissiveIntensity),
                            i.map && (n.map.value = i.map),
                            i.alphaMap && (n.alphaMap.value = i.alphaMap),
                            i.bumpMap &&
                                ((n.bumpMap.value = i.bumpMap),
                                (n.bumpScale.value = i.bumpScale),
                                1 === i.side && (n.bumpScale.value *= -1)),
                            i.displacementMap &&
                                ((n.displacementMap.value = i.displacementMap),
                                (n.displacementScale.value =
                                    i.displacementScale),
                                (n.displacementBias.value =
                                    i.displacementBias)),
                            i.emissiveMap &&
                                (n.emissiveMap.value = i.emissiveMap),
                            i.normalMap &&
                                ((n.normalMap.value = i.normalMap),
                                n.normalScale.value.copy(i.normalScale),
                                1 === i.side && n.normalScale.value.negate()),
                            i.specularMap &&
                                (n.specularMap.value = i.specularMap),
                            i.alphaTest > 0 &&
                                (n.alphaTest.value = i.alphaTest);
                        const r = e.get(i).envMap;
                        if (
                            (r &&
                                ((n.envMap.value = r),
                                (n.flipEnvMap.value =
                                    r.isCubeTexture &&
                                    !1 === r.isRenderTargetTexture
                                        ? -1
                                        : 1),
                                (n.reflectivity.value = i.reflectivity),
                                (n.ior.value = i.ior),
                                (n.refractionRatio.value = i.refractionRatio)),
                            i.lightMap)
                        ) {
                            n.lightMap.value = i.lightMap;
                            const e =
                                !0 !== t.physicallyCorrectLights ? Math.PI : 1;
                            n.lightMapIntensity.value = i.lightMapIntensity * e;
                        }
                        let a, s;
                        i.aoMap &&
                            ((n.aoMap.value = i.aoMap),
                            (n.aoMapIntensity.value = i.aoMapIntensity)),
                            i.map
                                ? (a = i.map)
                                : i.specularMap
                                ? (a = i.specularMap)
                                : i.displacementMap
                                ? (a = i.displacementMap)
                                : i.normalMap
                                ? (a = i.normalMap)
                                : i.bumpMap
                                ? (a = i.bumpMap)
                                : i.roughnessMap
                                ? (a = i.roughnessMap)
                                : i.metalnessMap
                                ? (a = i.metalnessMap)
                                : i.alphaMap
                                ? (a = i.alphaMap)
                                : i.emissiveMap
                                ? (a = i.emissiveMap)
                                : i.clearcoatMap
                                ? (a = i.clearcoatMap)
                                : i.clearcoatNormalMap
                                ? (a = i.clearcoatNormalMap)
                                : i.clearcoatRoughnessMap
                                ? (a = i.clearcoatRoughnessMap)
                                : i.iridescenceMap
                                ? (a = i.iridescenceMap)
                                : i.iridescenceThicknessMap
                                ? (a = i.iridescenceThicknessMap)
                                : i.specularIntensityMap
                                ? (a = i.specularIntensityMap)
                                : i.specularColorMap
                                ? (a = i.specularColorMap)
                                : i.transmissionMap
                                ? (a = i.transmissionMap)
                                : i.thicknessMap
                                ? (a = i.thicknessMap)
                                : i.sheenColorMap
                                ? (a = i.sheenColorMap)
                                : i.sheenRoughnessMap &&
                                  (a = i.sheenRoughnessMap),
                            void 0 !== a &&
                                (a.isWebGLRenderTarget && (a = a.texture),
                                !0 === a.matrixAutoUpdate && a.updateMatrix(),
                                n.uvTransform.value.copy(a.matrix)),
                            i.aoMap
                                ? (s = i.aoMap)
                                : i.lightMap && (s = i.lightMap),
                            void 0 !== s &&
                                (s.isWebGLRenderTarget && (s = s.texture),
                                !0 === s.matrixAutoUpdate && s.updateMatrix(),
                                n.uv2Transform.value.copy(s.matrix));
                    }
                    return {
                        refreshFogUniforms: function (e, n) {
                            n.color.getRGB(e.fogColor.value, gn(t)),
                                n.isFog
                                    ? ((e.fogNear.value = n.near),
                                      (e.fogFar.value = n.far))
                                    : n.isFogExp2 &&
                                      (e.fogDensity.value = n.density);
                        },
                        refreshMaterialUniforms: function (t, i, r, a, s) {
                            i.isMeshBasicMaterial || i.isMeshLambertMaterial
                                ? n(t, i)
                                : i.isMeshToonMaterial
                                ? (n(t, i),
                                  (function (t, e) {
                                      e.gradientMap &&
                                          (t.gradientMap.value = e.gradientMap);
                                  })(t, i))
                                : i.isMeshPhongMaterial
                                ? (n(t, i),
                                  (function (t, e) {
                                      t.specular.value.copy(e.specular),
                                          (t.shininess.value = Math.max(
                                              e.shininess,
                                              1e-4,
                                          ));
                                  })(t, i))
                                : i.isMeshStandardMaterial
                                ? (n(t, i),
                                  (function (t, n) {
                                      (t.roughness.value = n.roughness),
                                          (t.metalness.value = n.metalness),
                                          n.roughnessMap &&
                                              (t.roughnessMap.value =
                                                  n.roughnessMap),
                                          n.metalnessMap &&
                                              (t.metalnessMap.value =
                                                  n.metalnessMap);
                                      e.get(n).envMap &&
                                          (t.envMapIntensity.value =
                                              n.envMapIntensity);
                                  })(t, i),
                                  i.isMeshPhysicalMaterial &&
                                      (function (t, e, n) {
                                          (t.ior.value = e.ior),
                                              e.sheen > 0 &&
                                                  (t.sheenColor.value
                                                      .copy(e.sheenColor)
                                                      .multiplyScalar(e.sheen),
                                                  (t.sheenRoughness.value =
                                                      e.sheenRoughness),
                                                  e.sheenColorMap &&
                                                      (t.sheenColorMap.value =
                                                          e.sheenColorMap),
                                                  e.sheenRoughnessMap &&
                                                      (t.sheenRoughnessMap.value =
                                                          e.sheenRoughnessMap)),
                                              e.clearcoat > 0 &&
                                                  ((t.clearcoat.value =
                                                      e.clearcoat),
                                                  (t.clearcoatRoughness.value =
                                                      e.clearcoatRoughness),
                                                  e.clearcoatMap &&
                                                      (t.clearcoatMap.value =
                                                          e.clearcoatMap),
                                                  e.clearcoatRoughnessMap &&
                                                      (t.clearcoatRoughnessMap.value =
                                                          e.clearcoatRoughnessMap),
                                                  e.clearcoatNormalMap &&
                                                      (t.clearcoatNormalScale.value.copy(
                                                          e.clearcoatNormalScale,
                                                      ),
                                                      (t.clearcoatNormalMap.value =
                                                          e.clearcoatNormalMap),
                                                      1 === e.side &&
                                                          t.clearcoatNormalScale.value.negate())),
                                              e.iridescence > 0 &&
                                                  ((t.iridescence.value =
                                                      e.iridescence),
                                                  (t.iridescenceIOR.value =
                                                      e.iridescenceIOR),
                                                  (t.iridescenceThicknessMinimum.value =
                                                      e.iridescenceThicknessRange[0]),
                                                  (t.iridescenceThicknessMaximum.value =
                                                      e.iridescenceThicknessRange[1]),
                                                  e.iridescenceMap &&
                                                      (t.iridescenceMap.value =
                                                          e.iridescenceMap),
                                                  e.iridescenceThicknessMap &&
                                                      (t.iridescenceThicknessMap.value =
                                                          e.iridescenceThicknessMap)),
                                              e.transmission > 0 &&
                                                  ((t.transmission.value =
                                                      e.transmission),
                                                  (t.transmissionSamplerMap.value =
                                                      n.texture),
                                                  t.transmissionSamplerSize.value.set(
                                                      n.width,
                                                      n.height,
                                                  ),
                                                  e.transmissionMap &&
                                                      (t.transmissionMap.value =
                                                          e.transmissionMap),
                                                  (t.thickness.value =
                                                      e.thickness),
                                                  e.thicknessMap &&
                                                      (t.thicknessMap.value =
                                                          e.thicknessMap),
                                                  (t.attenuationDistance.value =
                                                      e.attenuationDistance),
                                                  t.attenuationColor.value.copy(
                                                      e.attenuationColor,
                                                  )),
                                              (t.specularIntensity.value =
                                                  e.specularIntensity),
                                              t.specularColor.value.copy(
                                                  e.specularColor,
                                              ),
                                              e.specularIntensityMap &&
                                                  (t.specularIntensityMap.value =
                                                      e.specularIntensityMap),
                                              e.specularColorMap &&
                                                  (t.specularColorMap.value =
                                                      e.specularColorMap);
                                      })(t, i, s))
                                : i.isMeshMatcapMaterial
                                ? (n(t, i),
                                  (function (t, e) {
                                      e.matcap && (t.matcap.value = e.matcap);
                                  })(t, i))
                                : i.isMeshDepthMaterial
                                ? n(t, i)
                                : i.isMeshDistanceMaterial
                                ? (n(t, i),
                                  (function (t, e) {
                                      t.referencePosition.value.copy(
                                          e.referencePosition,
                                      ),
                                          (t.nearDistance.value =
                                              e.nearDistance),
                                          (t.farDistance.value = e.farDistance);
                                  })(t, i))
                                : i.isMeshNormalMaterial
                                ? n(t, i)
                                : i.isLineBasicMaterial
                                ? ((function (t, e) {
                                      t.diffuse.value.copy(e.color),
                                          (t.opacity.value = e.opacity);
                                  })(t, i),
                                  i.isLineDashedMaterial &&
                                      (function (t, e) {
                                          (t.dashSize.value = e.dashSize),
                                              (t.totalSize.value =
                                                  e.dashSize + e.gapSize),
                                              (t.scale.value = e.scale);
                                      })(t, i))
                                : i.isPointsMaterial
                                ? (function (t, e, n, i) {
                                      let r;
                                      t.diffuse.value.copy(e.color),
                                          (t.opacity.value = e.opacity),
                                          (t.size.value = e.size * n),
                                          (t.scale.value = 0.5 * i),
                                          e.map && (t.map.value = e.map),
                                          e.alphaMap &&
                                              (t.alphaMap.value = e.alphaMap),
                                          e.alphaTest > 0 &&
                                              (t.alphaTest.value = e.alphaTest),
                                          e.map
                                              ? (r = e.map)
                                              : e.alphaMap && (r = e.alphaMap),
                                          void 0 !== r &&
                                              (!0 === r.matrixAutoUpdate &&
                                                  r.updateMatrix(),
                                              t.uvTransform.value.copy(
                                                  r.matrix,
                                              ));
                                  })(t, i, r, a)
                                : i.isSpriteMaterial
                                ? (function (t, e) {
                                      let n;
                                      t.diffuse.value.copy(e.color),
                                          (t.opacity.value = e.opacity),
                                          (t.rotation.value = e.rotation),
                                          e.map && (t.map.value = e.map),
                                          e.alphaMap &&
                                              (t.alphaMap.value = e.alphaMap),
                                          e.alphaTest > 0 &&
                                              (t.alphaTest.value = e.alphaTest),
                                          e.map
                                              ? (n = e.map)
                                              : e.alphaMap && (n = e.alphaMap),
                                          void 0 !== n &&
                                              (!0 === n.matrixAutoUpdate &&
                                                  n.updateMatrix(),
                                              t.uvTransform.value.copy(
                                                  n.matrix,
                                              ));
                                  })(t, i)
                                : i.isShadowMaterial
                                ? (t.color.value.copy(i.color),
                                  (t.opacity.value = i.opacity))
                                : i.isShaderMaterial &&
                                  (i.uniformsNeedUpdate = !1);
                        },
                    };
                }
                function oa(t, e, n, i) {
                    let r = {},
                        a = {},
                        s = [];
                    const o = n.isWebGL2 ? t.getParameter(35375) : 0;
                    function l(t, e, n) {
                        const i = t.value;
                        if (void 0 === n[e]) {
                            if ("number" == typeof i) n[e] = i;
                            else {
                                const t = Array.isArray(i) ? i : [i],
                                    r = [];
                                for (let e = 0; e < t.length; e++)
                                    r.push(t[e].clone());
                                n[e] = r;
                            }
                            return !0;
                        }
                        if ("number" == typeof i) {
                            if (n[e] !== i) return (n[e] = i), !0;
                        } else {
                            const t = Array.isArray(n[e]) ? n[e] : [n[e]],
                                r = Array.isArray(i) ? i : [i];
                            for (let e = 0; e < t.length; e++) {
                                const n = t[e];
                                if (!1 === n.equals(r[e]))
                                    return n.copy(r[e]), !0;
                            }
                        }
                        return !1;
                    }
                    function c(t) {
                        const e = { boundary: 0, storage: 0 };
                        return (
                            "number" == typeof t
                                ? ((e.boundary = 4), (e.storage = 4))
                                : t.isVector2
                                ? ((e.boundary = 8), (e.storage = 8))
                                : t.isVector3 || t.isColor
                                ? ((e.boundary = 16), (e.storage = 12))
                                : t.isVector4
                                ? ((e.boundary = 16), (e.storage = 16))
                                : t.isMatrix3
                                ? ((e.boundary = 48), (e.storage = 48))
                                : t.isMatrix4
                                ? ((e.boundary = 64), (e.storage = 64))
                                : t.isTexture
                                ? console.warn(
                                      "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.",
                                  )
                                : console.warn(
                                      "THREE.WebGLRenderer: Unsupported uniform value type.",
                                      t,
                                  ),
                            e
                        );
                    }
                    function h(e) {
                        const n = e.target;
                        n.removeEventListener("dispose", h);
                        const i = s.indexOf(n.__bindingPointIndex);
                        s.splice(i, 1),
                            t.deleteBuffer(r[n.id]),
                            delete r[n.id],
                            delete a[n.id];
                    }
                    return {
                        bind: function (t, e) {
                            const n = e.program;
                            i.uniformBlockBinding(t, n);
                        },
                        update: function (n, u) {
                            let d = r[n.id];
                            void 0 === d &&
                                ((function (t) {
                                    const e = t.uniforms;
                                    let n = 0;
                                    let i = 0;
                                    for (let t = 0, r = e.length; t < r; t++) {
                                        const r = e[t],
                                            a = { boundary: 0, storage: 0 },
                                            s = Array.isArray(r.value)
                                                ? r.value
                                                : [r.value];
                                        for (
                                            let t = 0, e = s.length;
                                            t < e;
                                            t++
                                        ) {
                                            const e = c(s[t]);
                                            (a.boundary += e.boundary),
                                                (a.storage += e.storage);
                                        }
                                        (r.__data = new Float32Array(
                                            a.storage /
                                                Float32Array.BYTES_PER_ELEMENT,
                                        )),
                                            (r.__offset = n),
                                            t > 0 &&
                                                ((i = n % 16),
                                                0 !== i &&
                                                    16 - i - a.boundary < 0 &&
                                                    ((n += 16 - i),
                                                    (r.__offset = n))),
                                            (n += a.storage);
                                    }
                                    (i = n % 16),
                                        i > 0 && (n += 16 - i),
                                        (t.__size = n),
                                        (t.__cache = {});
                                })(n),
                                (d = (function (e) {
                                    const n = (function () {
                                        for (let t = 0; t < o; t++)
                                            if (-1 === s.indexOf(t))
                                                return s.push(t), t;
                                        return (
                                            console.error(
                                                "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.",
                                            ),
                                            0
                                        );
                                    })();
                                    e.__bindingPointIndex = n;
                                    const i = t.createBuffer(),
                                        r = e.__size,
                                        a = e.usage;
                                    return (
                                        t.bindBuffer(35345, i),
                                        t.bufferData(35345, r, a),
                                        t.bindBuffer(35345, null),
                                        t.bindBufferBase(35345, n, i),
                                        i
                                    );
                                })(n)),
                                (r[n.id] = d),
                                n.addEventListener("dispose", h));
                            const p = u.program;
                            i.updateUBOMapping(n, p);
                            const f = e.render.frame;
                            a[n.id] !== f &&
                                ((function (e) {
                                    const n = r[e.id],
                                        i = e.uniforms,
                                        a = e.__cache;
                                    t.bindBuffer(35345, n);
                                    for (let e = 0, n = i.length; e < n; e++) {
                                        const n = i[e];
                                        if (!0 === l(n, e, a)) {
                                            const e = n.__offset,
                                                i = Array.isArray(n.value)
                                                    ? n.value
                                                    : [n.value];
                                            let r = 0;
                                            for (let a = 0; a < i.length; a++) {
                                                const s = i[a],
                                                    o = c(s);
                                                "number" == typeof s
                                                    ? ((n.__data[0] = s),
                                                      t.bufferSubData(
                                                          35345,
                                                          e + r,
                                                          n.__data,
                                                      ))
                                                    : s.isMatrix3
                                                    ? ((n.__data[0] =
                                                          s.elements[0]),
                                                      (n.__data[1] =
                                                          s.elements[1]),
                                                      (n.__data[2] =
                                                          s.elements[2]),
                                                      (n.__data[3] =
                                                          s.elements[0]),
                                                      (n.__data[4] =
                                                          s.elements[3]),
                                                      (n.__data[5] =
                                                          s.elements[4]),
                                                      (n.__data[6] =
                                                          s.elements[5]),
                                                      (n.__data[7] =
                                                          s.elements[0]),
                                                      (n.__data[8] =
                                                          s.elements[6]),
                                                      (n.__data[9] =
                                                          s.elements[7]),
                                                      (n.__data[10] =
                                                          s.elements[8]),
                                                      (n.__data[11] =
                                                          s.elements[0]))
                                                    : (s.toArray(n.__data, r),
                                                      (r +=
                                                          o.storage /
                                                          Float32Array.BYTES_PER_ELEMENT));
                                            }
                                            t.bufferSubData(35345, e, n.__data);
                                        }
                                    }
                                    t.bindBuffer(35345, null);
                                })(n),
                                (a[n.id] = f));
                        },
                        dispose: function () {
                            for (const e in r) t.deleteBuffer(r[e]);
                            (s = []), (r = {}), (a = {});
                        },
                    };
                }
                function la(e = {}) {
                    this.isWebGLRenderer = !0;
                    const n =
                            void 0 !== e.canvas
                                ? e.canvas
                                : (function () {
                                      const t = Q("canvas");
                                      return (t.style.display = "block"), t;
                                  })(),
                        i = void 0 !== e.context ? e.context : null,
                        r = void 0 === e.depth || e.depth,
                        a = void 0 === e.stencil || e.stencil,
                        s = void 0 !== e.antialias && e.antialias,
                        o =
                            void 0 === e.premultipliedAlpha ||
                            e.premultipliedAlpha,
                        l =
                            void 0 !== e.preserveDrawingBuffer &&
                            e.preserveDrawingBuffer,
                        c =
                            void 0 !== e.powerPreference
                                ? e.powerPreference
                                : "default",
                        h =
                            void 0 !== e.failIfMajorPerformanceCaveat &&
                            e.failIfMajorPerformanceCaveat;
                    let p;
                    p =
                        null !== i
                            ? i.getContextAttributes().alpha
                            : void 0 !== e.alpha && e.alpha;
                    let g = null,
                        x = null;
                    const b = [],
                        y = [];
                    (this.domElement = n),
                        (this.debug = { checkShaderErrors: !0 }),
                        (this.autoClear = !0),
                        (this.autoClearColor = !0),
                        (this.autoClearDepth = !0),
                        (this.autoClearStencil = !0),
                        (this.sortObjects = !0),
                        (this.clippingPlanes = []),
                        (this.localClippingEnabled = !1),
                        (this.outputEncoding = C),
                        (this.physicallyCorrectLights = !1),
                        (this.toneMapping = 0),
                        (this.toneMappingExposure = 1);
                    const S = this;
                    let M = !1,
                        A = 0,
                        _ = 0,
                        w = null,
                        T = -1,
                        E = null;
                    const R = new gt(),
                        k = new gt();
                    let L = null,
                        I = n.width,
                        O = n.height,
                        D = 1,
                        P = null,
                        U = null;
                    const V = new gt(0, 0, I, O),
                        N = new gt(0, 0, I, O);
                    let G = !1;
                    const j = new Ln();
                    let H = !1,
                        F = !1,
                        B = null;
                    const z = new Xt(),
                        q = new K(),
                        Y = new St(),
                        J = {
                            background: null,
                            fog: null,
                            environment: null,
                            overrideMaterial: null,
                            isScene: !0,
                        };
                    function Z() {
                        return null === w ? D : 1;
                    }
                    let X,
                        $,
                        tt,
                        et,
                        nt,
                        it,
                        rt,
                        at,
                        st,
                        ot,
                        lt,
                        ct,
                        ht,
                        ut,
                        dt,
                        pt,
                        ft,
                        mt,
                        xt,
                        bt,
                        yt,
                        Mt,
                        At,
                        _t,
                        wt = i;
                    function Tt(t, e) {
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i],
                                a = n.getContext(r, e);
                            if (null !== a) return a;
                        }
                        return null;
                    }
                    try {
                        const e = {
                            alpha: !0,
                            depth: r,
                            stencil: a,
                            antialias: s,
                            premultipliedAlpha: o,
                            preserveDrawingBuffer: l,
                            powerPreference: c,
                            failIfMajorPerformanceCaveat: h,
                        };
                        if (
                            ("setAttribute" in n &&
                                n.setAttribute("data-engine", `three.js r${t}`),
                            n.addEventListener("webglcontextlost", kt, !1),
                            n.addEventListener("webglcontextrestored", Ct, !1),
                            n.addEventListener(
                                "webglcontextcreationerror",
                                Lt,
                                !1,
                            ),
                            null === wt)
                        ) {
                            const t = ["webgl2", "webgl", "experimental-webgl"];
                            if (
                                (!0 === S.isWebGL1Renderer && t.shift(),
                                (wt = Tt(t, e)),
                                null === wt)
                            )
                                throw Tt(t)
                                    ? new Error(
                                          "Error creating WebGL context with your selected attributes.",
                                      )
                                    : new Error(
                                          "Error creating WebGL context.",
                                      );
                        }
                        void 0 === wt.getShaderPrecisionFormat &&
                            (wt.getShaderPrecisionFormat = function () {
                                return {
                                    rangeMin: 1,
                                    rangeMax: 1,
                                    precision: 1,
                                };
                            });
                    } catch (t) {
                        throw (
                            (console.error("THREE.WebGLRenderer: " + t.message),
                            t)
                        );
                    }
                    function Et() {
                        (X = new ai(wt)),
                            ($ = new Fn(wt, X, e)),
                            X.init($),
                            (Mt = new $r(wt, X, $)),
                            (tt = new Xr(wt, X, $)),
                            (et = new li()),
                            (nt = new Vr()),
                            (it = new Qr(wt, X, tt, nt, $, Mt, et)),
                            (rt = new zn(S)),
                            (at = new ri(S)),
                            (st = new On(wt, $)),
                            (At = new jn(wt, X, st, $)),
                            (ot = new si(wt, st, et, At)),
                            (lt = new di(wt, ot, st, et)),
                            (xt = new ui(wt, $, it)),
                            (pt = new Bn(nt)),
                            (ct = new Ur(S, rt, at, X, $, At, pt)),
                            (ht = new sa(S, nt)),
                            (ut = new Hr()),
                            (dt = new Yr(X, $)),
                            (mt = new Gn(S, rt, at, tt, lt, p, o)),
                            (ft = new Zr(S, lt, $)),
                            (_t = new oa(wt, et, $, tt)),
                            (bt = new Hn(wt, X, et, $)),
                            (yt = new oi(wt, X, et, $)),
                            (et.programs = ct.programs),
                            (S.capabilities = $),
                            (S.extensions = X),
                            (S.properties = nt),
                            (S.renderLists = ut),
                            (S.shadowMap = ft),
                            (S.state = tt),
                            (S.info = et);
                    }
                    Et();
                    const Rt = new aa(S, wt);
                    function kt(t) {
                        t.preventDefault(),
                            console.log("THREE.WebGLRenderer: Context Lost."),
                            (M = !0);
                    }
                    function Ct() {
                        console.log("THREE.WebGLRenderer: Context Restored."),
                            (M = !1);
                        const t = et.autoReset,
                            e = ft.enabled,
                            n = ft.autoUpdate,
                            i = ft.needsUpdate,
                            r = ft.type;
                        Et(),
                            (et.autoReset = t),
                            (ft.enabled = e),
                            (ft.autoUpdate = n),
                            (ft.needsUpdate = i),
                            (ft.type = r);
                    }
                    function Lt(t) {
                        console.error(
                            "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
                            t.statusMessage,
                        );
                    }
                    function It(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", It),
                            (function (t) {
                                (function (t) {
                                    const e = nt.get(t).programs;
                                    void 0 !== e &&
                                        (e.forEach(function (t) {
                                            ct.releaseProgram(t);
                                        }),
                                        t.isShaderMaterial &&
                                            ct.releaseShaderCache(t));
                                })(t),
                                    nt.remove(t);
                            })(e);
                    }
                    (this.xr = Rt),
                        (this.getContext = function () {
                            return wt;
                        }),
                        (this.getContextAttributes = function () {
                            return wt.getContextAttributes();
                        }),
                        (this.forceContextLoss = function () {
                            const t = X.get("WEBGL_lose_context");
                            t && t.loseContext();
                        }),
                        (this.forceContextRestore = function () {
                            const t = X.get("WEBGL_lose_context");
                            t && t.restoreContext();
                        }),
                        (this.getPixelRatio = function () {
                            return D;
                        }),
                        (this.setPixelRatio = function (t) {
                            void 0 !== t && ((D = t), this.setSize(I, O, !1));
                        }),
                        (this.getSize = function (t) {
                            return t.set(I, O);
                        }),
                        (this.setSize = function (t, e, i) {
                            Rt.isPresenting
                                ? console.warn(
                                      "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
                                  )
                                : ((I = t),
                                  (O = e),
                                  (n.width = Math.floor(t * D)),
                                  (n.height = Math.floor(e * D)),
                                  !1 !== i &&
                                      ((n.style.width = t + "px"),
                                      (n.style.height = e + "px")),
                                  this.setViewport(0, 0, t, e));
                        }),
                        (this.getDrawingBufferSize = function (t) {
                            return t.set(I * D, O * D).floor();
                        }),
                        (this.setDrawingBufferSize = function (t, e, i) {
                            (I = t),
                                (O = e),
                                (D = i),
                                (n.width = Math.floor(t * i)),
                                (n.height = Math.floor(e * i)),
                                this.setViewport(0, 0, t, e);
                        }),
                        (this.getCurrentViewport = function (t) {
                            return t.copy(R);
                        }),
                        (this.getViewport = function (t) {
                            return t.copy(V);
                        }),
                        (this.setViewport = function (t, e, n, i) {
                            t.isVector4
                                ? V.set(t.x, t.y, t.z, t.w)
                                : V.set(t, e, n, i),
                                tt.viewport(
                                    R.copy(V).multiplyScalar(D).floor(),
                                );
                        }),
                        (this.getScissor = function (t) {
                            return t.copy(N);
                        }),
                        (this.setScissor = function (t, e, n, i) {
                            t.isVector4
                                ? N.set(t.x, t.y, t.z, t.w)
                                : N.set(t, e, n, i),
                                tt.scissor(k.copy(N).multiplyScalar(D).floor());
                        }),
                        (this.getScissorTest = function () {
                            return G;
                        }),
                        (this.setScissorTest = function (t) {
                            tt.setScissorTest((G = t));
                        }),
                        (this.setOpaqueSort = function (t) {
                            P = t;
                        }),
                        (this.setTransparentSort = function (t) {
                            U = t;
                        }),
                        (this.getClearColor = function (t) {
                            return t.copy(mt.getClearColor());
                        }),
                        (this.setClearColor = function () {
                            mt.setClearColor.apply(mt, arguments);
                        }),
                        (this.getClearAlpha = function () {
                            return mt.getClearAlpha();
                        }),
                        (this.setClearAlpha = function () {
                            mt.setClearAlpha.apply(mt, arguments);
                        }),
                        (this.clear = function (t = !0, e = !0, n = !0) {
                            let i = 0;
                            t && (i |= 16384),
                                e && (i |= 256),
                                n && (i |= 1024),
                                wt.clear(i);
                        }),
                        (this.clearColor = function () {
                            this.clear(!0, !1, !1);
                        }),
                        (this.clearDepth = function () {
                            this.clear(!1, !0, !1);
                        }),
                        (this.clearStencil = function () {
                            this.clear(!1, !1, !0);
                        }),
                        (this.dispose = function () {
                            n.removeEventListener("webglcontextlost", kt, !1),
                                n.removeEventListener(
                                    "webglcontextrestored",
                                    Ct,
                                    !1,
                                ),
                                n.removeEventListener(
                                    "webglcontextcreationerror",
                                    Lt,
                                    !1,
                                ),
                                ut.dispose(),
                                dt.dispose(),
                                nt.dispose(),
                                rt.dispose(),
                                at.dispose(),
                                lt.dispose(),
                                At.dispose(),
                                _t.dispose(),
                                ct.dispose(),
                                Rt.dispose(),
                                Rt.removeEventListener("sessionstart", Dt),
                                Rt.removeEventListener("sessionend", Pt),
                                B && (B.dispose(), (B = null)),
                                Ut.stop();
                        }),
                        (this.renderBufferDirect = function (t, e, n, i, r, a) {
                            null === e && (e = J);
                            const s =
                                    r.isMesh && r.matrixWorld.determinant() < 0,
                                o = (function (t, e, n, i, r) {
                                    !0 !== e.isScene && (e = J),
                                        it.resetTextureUnits();
                                    const a = e.fog,
                                        s = i.isMeshStandardMaterial
                                            ? e.environment
                                            : null,
                                        o =
                                            null === w
                                                ? S.outputEncoding
                                                : !0 === w.isXRRenderTarget
                                                ? w.texture.encoding
                                                : C,
                                        l = (
                                            i.isMeshStandardMaterial ? at : rt
                                        ).get(i.envMap || s),
                                        c =
                                            !0 === i.vertexColors &&
                                            !!n.attributes.color &&
                                            4 === n.attributes.color.itemSize,
                                        h =
                                            !!i.normalMap &&
                                            !!n.attributes.tangent,
                                        u = !!n.morphAttributes.position,
                                        d = !!n.morphAttributes.normal,
                                        p = !!n.morphAttributes.color,
                                        f = i.toneMapped ? S.toneMapping : 0,
                                        m =
                                            n.morphAttributes.position ||
                                            n.morphAttributes.normal ||
                                            n.morphAttributes.color,
                                        g = void 0 !== m ? m.length : 0,
                                        v = nt.get(i),
                                        b = x.state.lights;
                                    if (!0 === H && (!0 === F || t !== E)) {
                                        const e = t === E && i.id === T;
                                        pt.setState(i, t, e);
                                    }
                                    let y = !1;
                                    i.version === v.__version
                                        ? (v.needsLights &&
                                              v.lightsStateVersion !==
                                                  b.state.version) ||
                                          v.outputEncoding !== o ||
                                          (r.isInstancedMesh &&
                                              !1 === v.instancing)
                                            ? (y = !0)
                                            : r.isInstancedMesh ||
                                              !0 !== v.instancing
                                            ? r.isSkinnedMesh &&
                                              !1 === v.skinning
                                                ? (y = !0)
                                                : r.isSkinnedMesh ||
                                                  !0 !== v.skinning
                                                ? v.envMap !== l ||
                                                  (!0 === i.fog && v.fog !== a)
                                                    ? (y = !0)
                                                    : void 0 ===
                                                          v.numClippingPlanes ||
                                                      (v.numClippingPlanes ===
                                                          pt.numPlanes &&
                                                          v.numIntersection ===
                                                              pt.numIntersection)
                                                    ? (v.vertexAlphas !== c ||
                                                          v.vertexTangents !==
                                                              h ||
                                                          v.morphTargets !==
                                                              u ||
                                                          v.morphNormals !==
                                                              d ||
                                                          v.morphColors !== p ||
                                                          v.toneMapping !== f ||
                                                          (!0 === $.isWebGL2 &&
                                                              v.morphTargetsCount !==
                                                                  g)) &&
                                                      (y = !0)
                                                    : (y = !0)
                                                : (y = !0)
                                            : (y = !0)
                                        : ((y = !0), (v.__version = i.version));
                                    let M = v.currentProgram;
                                    !0 === y && (M = Ht(i, e, r));
                                    let A = !1,
                                        _ = !1,
                                        R = !1;
                                    const k = M.getUniforms(),
                                        L = v.uniforms;
                                    if (
                                        (tt.useProgram(M.program) &&
                                            ((A = !0), (_ = !0), (R = !0)),
                                        i.id !== T && ((T = i.id), (_ = !0)),
                                        A || E !== t)
                                    ) {
                                        if (
                                            (k.setValue(
                                                wt,
                                                "projectionMatrix",
                                                t.projectionMatrix,
                                            ),
                                            $.logarithmicDepthBuffer &&
                                                k.setValue(
                                                    wt,
                                                    "logDepthBufFC",
                                                    2 /
                                                        (Math.log(t.far + 1) /
                                                            Math.LN2),
                                                ),
                                            E !== t &&
                                                ((E = t), (_ = !0), (R = !0)),
                                            i.isShaderMaterial ||
                                                i.isMeshPhongMaterial ||
                                                i.isMeshToonMaterial ||
                                                i.isMeshStandardMaterial ||
                                                i.envMap)
                                        ) {
                                            const e = k.map.cameraPosition;
                                            void 0 !== e &&
                                                e.setValue(
                                                    wt,
                                                    Y.setFromMatrixPosition(
                                                        t.matrixWorld,
                                                    ),
                                                );
                                        }
                                        (i.isMeshPhongMaterial ||
                                            i.isMeshToonMaterial ||
                                            i.isMeshLambertMaterial ||
                                            i.isMeshBasicMaterial ||
                                            i.isMeshStandardMaterial ||
                                            i.isShaderMaterial) &&
                                            k.setValue(
                                                wt,
                                                "isOrthographic",
                                                !0 === t.isOrthographicCamera,
                                            ),
                                            (i.isMeshPhongMaterial ||
                                                i.isMeshToonMaterial ||
                                                i.isMeshLambertMaterial ||
                                                i.isMeshBasicMaterial ||
                                                i.isMeshStandardMaterial ||
                                                i.isShaderMaterial ||
                                                i.isShadowMaterial ||
                                                r.isSkinnedMesh) &&
                                                k.setValue(
                                                    wt,
                                                    "viewMatrix",
                                                    t.matrixWorldInverse,
                                                );
                                    }
                                    if (r.isSkinnedMesh) {
                                        k.setOptional(wt, r, "bindMatrix"),
                                            k.setOptional(
                                                wt,
                                                r,
                                                "bindMatrixInverse",
                                            );
                                        const t = r.skeleton;
                                        t &&
                                            ($.floatVertexTextures
                                                ? (null === t.boneTexture &&
                                                      t.computeBoneTexture(),
                                                  k.setValue(
                                                      wt,
                                                      "boneTexture",
                                                      t.boneTexture,
                                                      it,
                                                  ),
                                                  k.setValue(
                                                      wt,
                                                      "boneTextureSize",
                                                      t.boneTextureSize,
                                                  ))
                                                : console.warn(
                                                      "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.",
                                                  ));
                                    }
                                    const I = n.morphAttributes;
                                    var P, U;
                                    if (
                                        ((void 0 !== I.position ||
                                            void 0 !== I.normal ||
                                            (void 0 !== I.color &&
                                                !0 === $.isWebGL2)) &&
                                            xt.update(r, n, i, M),
                                        (_ ||
                                            v.receiveShadow !==
                                                r.receiveShadow) &&
                                            ((v.receiveShadow =
                                                r.receiveShadow),
                                            k.setValue(
                                                wt,
                                                "receiveShadow",
                                                r.receiveShadow,
                                            )),
                                        i.isMeshGouraudMaterial &&
                                            null !== i.envMap &&
                                            ((L.envMap.value = l),
                                            (L.flipEnvMap.value =
                                                l.isCubeTexture &&
                                                !1 === l.isRenderTargetTexture
                                                    ? -1
                                                    : 1)),
                                        _ &&
                                            (k.setValue(
                                                wt,
                                                "toneMappingExposure",
                                                S.toneMappingExposure,
                                            ),
                                            v.needsLights &&
                                                ((U = R),
                                                ((P =
                                                    L).ambientLightColor.needsUpdate =
                                                    U),
                                                (P.lightProbe.needsUpdate = U),
                                                (P.directionalLights.needsUpdate =
                                                    U),
                                                (P.directionalLightShadows.needsUpdate =
                                                    U),
                                                (P.pointLights.needsUpdate = U),
                                                (P.pointLightShadows.needsUpdate =
                                                    U),
                                                (P.spotLights.needsUpdate = U),
                                                (P.spotLightShadows.needsUpdate =
                                                    U),
                                                (P.rectAreaLights.needsUpdate =
                                                    U),
                                                (P.hemisphereLights.needsUpdate =
                                                    U)),
                                            a &&
                                                !0 === i.fog &&
                                                ht.refreshFogUniforms(L, a),
                                            ht.refreshMaterialUniforms(
                                                L,
                                                i,
                                                D,
                                                O,
                                                B,
                                            ),
                                            gr.upload(
                                                wt,
                                                v.uniformsList,
                                                L,
                                                it,
                                            )),
                                        i.isShaderMaterial &&
                                            !0 === i.uniformsNeedUpdate &&
                                            (gr.upload(
                                                wt,
                                                v.uniformsList,
                                                L,
                                                it,
                                            ),
                                            (i.uniformsNeedUpdate = !1)),
                                        i.isSpriteMaterial &&
                                            k.setValue(wt, "center", r.center),
                                        k.setValue(
                                            wt,
                                            "modelViewMatrix",
                                            r.modelViewMatrix,
                                        ),
                                        k.setValue(
                                            wt,
                                            "normalMatrix",
                                            r.normalMatrix,
                                        ),
                                        k.setValue(
                                            wt,
                                            "modelMatrix",
                                            r.matrixWorld,
                                        ),
                                        i.isShaderMaterial ||
                                            i.isRawShaderMaterial)
                                    ) {
                                        const t = i.uniformsGroups;
                                        for (
                                            let e = 0, n = t.length;
                                            e < n;
                                            e++
                                        )
                                            if ($.isWebGL2) {
                                                const n = t[e];
                                                _t.update(n, M), _t.bind(n, M);
                                            } else
                                                console.warn(
                                                    "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.",
                                                );
                                    }
                                    return M;
                                })(t, e, n, i, r);
                            tt.setMaterial(i, s);
                            let l = n.index,
                                c = 1;
                            !0 === i.wireframe &&
                                ((l = ot.getWireframeAttribute(n)), (c = 2));
                            const h = n.drawRange,
                                u = n.attributes.position;
                            let d = h.start * c,
                                p = (h.start + h.count) * c;
                            null !== a &&
                                ((d = Math.max(d, a.start * c)),
                                (p = Math.min(p, (a.start + a.count) * c))),
                                null !== l
                                    ? ((d = Math.max(d, 0)),
                                      (p = Math.min(p, l.count)))
                                    : null != u &&
                                      ((d = Math.max(d, 0)),
                                      (p = Math.min(p, u.count)));
                            const f = p - d;
                            if (f < 0 || f === 1 / 0) return;
                            let m;
                            At.setup(r, i, o, n, l);
                            let g = bt;
                            if (
                                (null !== l &&
                                    ((m = st.get(l)), (g = yt), g.setIndex(m)),
                                r.isMesh)
                            )
                                !0 === i.wireframe
                                    ? (tt.setLineWidth(
                                          i.wireframeLinewidth * Z(),
                                      ),
                                      g.setMode(1))
                                    : g.setMode(4);
                            else if (r.isLine) {
                                let t = i.linewidth;
                                void 0 === t && (t = 1),
                                    tt.setLineWidth(t * Z()),
                                    r.isLineSegments
                                        ? g.setMode(1)
                                        : r.isLineLoop
                                        ? g.setMode(2)
                                        : g.setMode(3);
                            } else
                                r.isPoints
                                    ? g.setMode(0)
                                    : r.isSprite && g.setMode(4);
                            if (r.isInstancedMesh)
                                g.renderInstances(d, f, r.count);
                            else if (n.isInstancedBufferGeometry) {
                                const t =
                                        void 0 !== n._maxInstanceCount
                                            ? n._maxInstanceCount
                                            : 1 / 0,
                                    e = Math.min(n.instanceCount, t);
                                g.renderInstances(d, f, e);
                            } else g.render(d, f);
                        }),
                        (this.compile = function (t, e) {
                            function n(t, e, n) {
                                !0 === t.transparent && 3 === t.side
                                    ? ((t.side = 1),
                                      (t.needsUpdate = !0),
                                      Ht(t, e, n),
                                      (t.side = 0),
                                      (t.needsUpdate = !0),
                                      Ht(t, e, n),
                                      (t.side = 3))
                                    : Ht(t, e, n);
                            }
                            (x = dt.get(t)),
                                x.init(),
                                y.push(x),
                                t.traverseVisible(function (t) {
                                    t.isLight &&
                                        t.layers.test(e.layers) &&
                                        (x.pushLight(t),
                                        t.castShadow && x.pushShadow(t));
                                }),
                                x.setupLights(S.physicallyCorrectLights),
                                t.traverse(function (e) {
                                    const i = e.material;
                                    if (i)
                                        if (Array.isArray(i))
                                            for (let r = 0; r < i.length; r++)
                                                n(i[r], t, e);
                                        else n(i, t, e);
                                }),
                                y.pop(),
                                (x = null);
                        });
                    let Ot = null;
                    function Dt() {
                        Ut.stop();
                    }
                    function Pt() {
                        Ut.start();
                    }
                    const Ut = new In();
                    function Vt(t, e, n, i) {
                        if (!1 === t.visible) return;
                        if (t.layers.test(e.layers))
                            if (t.isGroup) n = t.renderOrder;
                            else if (t.isLOD)
                                !0 === t.autoUpdate && t.update(e);
                            else if (t.isLight)
                                x.pushLight(t), t.castShadow && x.pushShadow(t);
                            else if (t.isSprite) {
                                if (!t.frustumCulled || j.intersectsSprite(t)) {
                                    i &&
                                        Y.setFromMatrixPosition(
                                            t.matrixWorld,
                                        ).applyMatrix4(z);
                                    const e = lt.update(t),
                                        r = t.material;
                                    r.visible && g.push(t, e, r, n, Y.z, null);
                                }
                            } else if (
                                (t.isMesh || t.isLine || t.isPoints) &&
                                (t.isSkinnedMesh &&
                                    t.skeleton.frame !== et.render.frame &&
                                    (t.skeleton.update(),
                                    (t.skeleton.frame = et.render.frame)),
                                !t.frustumCulled || j.intersectsObject(t))
                            ) {
                                i &&
                                    Y.setFromMatrixPosition(
                                        t.matrixWorld,
                                    ).applyMatrix4(z);
                                const e = lt.update(t),
                                    r = t.material;
                                if (Array.isArray(r)) {
                                    const i = e.groups;
                                    for (let a = 0, s = i.length; a < s; a++) {
                                        const s = i[a],
                                            o = r[s.materialIndex];
                                        o &&
                                            o.visible &&
                                            g.push(t, e, o, n, Y.z, s);
                                    }
                                } else
                                    r.visible && g.push(t, e, r, n, Y.z, null);
                            }
                        const r = t.children;
                        for (let t = 0, a = r.length; t < a; t++)
                            Vt(r[t], e, n, i);
                    }
                    function Nt(t, e, n, i) {
                        const r = t.opaque,
                            a = t.transmissive,
                            o = t.transparent;
                        x.setupLightsView(n),
                            a.length > 0 &&
                                (function (t, e, n) {
                                    const i = $.isWebGL2;
                                    null === B &&
                                        (B = new vt(1, 1, {
                                            generateMipmaps: !0,
                                            type: X.has(
                                                "EXT_color_buffer_half_float",
                                            )
                                                ? m
                                                : d,
                                            minFilter: u,
                                            samples: i && !0 === s ? 4 : 0,
                                        })),
                                        S.getDrawingBufferSize(q),
                                        i
                                            ? B.setSize(q.x, q.y)
                                            : B.setSize(W(q.x), W(q.y));
                                    const r = S.getRenderTarget();
                                    S.setRenderTarget(B), S.clear();
                                    const a = S.toneMapping;
                                    (S.toneMapping = 0),
                                        Gt(t, e, n),
                                        (S.toneMapping = a),
                                        it.updateMultisampleRenderTarget(B),
                                        it.updateRenderTargetMipmap(B),
                                        S.setRenderTarget(r);
                                })(r, e, n),
                            i && tt.viewport(R.copy(i)),
                            r.length > 0 && Gt(r, e, n),
                            a.length > 0 && Gt(a, e, n),
                            o.length > 0 && Gt(o, e, n),
                            tt.buffers.depth.setTest(!0),
                            tt.buffers.depth.setMask(!0),
                            tt.buffers.color.setMask(!0),
                            tt.setPolygonOffset(!1);
                    }
                    function Gt(t, e, n) {
                        const i = !0 === e.isScene ? e.overrideMaterial : null;
                        for (let r = 0, a = t.length; r < a; r++) {
                            const a = t[r],
                                s = a.object,
                                o = a.geometry,
                                l = null === i ? a.material : i,
                                c = a.group;
                            s.layers.test(n.layers) && jt(s, e, n, o, l, c);
                        }
                    }
                    function jt(t, e, n, i, r, a) {
                        t.onBeforeRender(S, e, n, i, r, a),
                            t.modelViewMatrix.multiplyMatrices(
                                n.matrixWorldInverse,
                                t.matrixWorld,
                            ),
                            t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
                            r.onBeforeRender(S, e, n, i, t, a),
                            !0 === r.transparent && 3 === r.side
                                ? ((r.side = 1),
                                  (r.needsUpdate = !0),
                                  S.renderBufferDirect(n, e, i, r, t, a),
                                  (r.side = 0),
                                  (r.needsUpdate = !0),
                                  S.renderBufferDirect(n, e, i, r, t, a),
                                  (r.side = 3))
                                : S.renderBufferDirect(n, e, i, r, t, a),
                            t.onAfterRender(S, e, n, i, r, a);
                    }
                    function Ht(t, e, n) {
                        !0 !== e.isScene && (e = J);
                        const i = nt.get(t),
                            r = x.state.lights,
                            a = x.state.shadowsArray,
                            s = r.state.version,
                            o = ct.getParameters(t, r.state, a, e, n),
                            l = ct.getProgramCacheKey(o);
                        let c = i.programs;
                        (i.environment = t.isMeshStandardMaterial
                            ? e.environment
                            : null),
                            (i.fog = e.fog),
                            (i.envMap = (
                                t.isMeshStandardMaterial ? at : rt
                            ).get(t.envMap || i.environment)),
                            void 0 === c &&
                                (t.addEventListener("dispose", It),
                                (c = new Map()),
                                (i.programs = c));
                        let h = c.get(l);
                        if (void 0 !== h) {
                            if (
                                i.currentProgram === h &&
                                i.lightsStateVersion === s
                            )
                                return Ft(t, o), h;
                        } else
                            (o.uniforms = ct.getUniforms(t)),
                                t.onBuild(n, o, S),
                                t.onBeforeCompile(o, S),
                                (h = ct.acquireProgram(o, l)),
                                c.set(l, h),
                                (i.uniforms = o.uniforms);
                        const u = i.uniforms;
                        ((t.isShaderMaterial || t.isRawShaderMaterial) &&
                            !0 !== t.clipping) ||
                            (u.clippingPlanes = pt.uniform),
                            Ft(t, o),
                            (i.needsLights = (function (t) {
                                return (
                                    t.isMeshLambertMaterial ||
                                    t.isMeshToonMaterial ||
                                    t.isMeshPhongMaterial ||
                                    t.isMeshStandardMaterial ||
                                    t.isShadowMaterial ||
                                    (t.isShaderMaterial && !0 === t.lights)
                                );
                            })(t)),
                            (i.lightsStateVersion = s),
                            i.needsLights &&
                                ((u.ambientLightColor.value = r.state.ambient),
                                (u.lightProbe.value = r.state.probe),
                                (u.directionalLights.value =
                                    r.state.directional),
                                (u.directionalLightShadows.value =
                                    r.state.directionalShadow),
                                (u.spotLights.value = r.state.spot),
                                (u.spotLightShadows.value = r.state.spotShadow),
                                (u.rectAreaLights.value = r.state.rectArea),
                                (u.ltc_1.value = r.state.rectAreaLTC1),
                                (u.ltc_2.value = r.state.rectAreaLTC2),
                                (u.pointLights.value = r.state.point),
                                (u.pointLightShadows.value =
                                    r.state.pointShadow),
                                (u.hemisphereLights.value = r.state.hemi),
                                (u.directionalShadowMap.value =
                                    r.state.directionalShadowMap),
                                (u.directionalShadowMatrix.value =
                                    r.state.directionalShadowMatrix),
                                (u.spotShadowMap.value = r.state.spotShadowMap),
                                (u.spotLightMatrix.value =
                                    r.state.spotLightMatrix),
                                (u.spotLightMap.value = r.state.spotLightMap),
                                (u.pointShadowMap.value =
                                    r.state.pointShadowMap),
                                (u.pointShadowMatrix.value =
                                    r.state.pointShadowMatrix));
                        const d = h.getUniforms(),
                            p = gr.seqWithValue(d.seq, u);
                        return (i.currentProgram = h), (i.uniformsList = p), h;
                    }
                    function Ft(t, e) {
                        const n = nt.get(t);
                        (n.outputEncoding = e.outputEncoding),
                            (n.instancing = e.instancing),
                            (n.skinning = e.skinning),
                            (n.morphTargets = e.morphTargets),
                            (n.morphNormals = e.morphNormals),
                            (n.morphColors = e.morphColors),
                            (n.morphTargetsCount = e.morphTargetsCount),
                            (n.numClippingPlanes = e.numClippingPlanes),
                            (n.numIntersection = e.numClipIntersection),
                            (n.vertexAlphas = e.vertexAlphas),
                            (n.vertexTangents = e.vertexTangents),
                            (n.toneMapping = e.toneMapping);
                    }
                    Ut.setAnimationLoop(function (t) {
                        Ot && Ot(t);
                    }),
                        "undefined" != typeof self && Ut.setContext(self),
                        (this.setAnimationLoop = function (t) {
                            (Ot = t),
                                Rt.setAnimationLoop(t),
                                null === t ? Ut.stop() : Ut.start();
                        }),
                        Rt.addEventListener("sessionstart", Dt),
                        Rt.addEventListener("sessionend", Pt),
                        (this.render = function (t, e) {
                            if (void 0 !== e && !0 !== e.isCamera)
                                return void console.error(
                                    "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.",
                                );
                            if (!0 === M) return;
                            !0 === t.matrixWorldAutoUpdate &&
                                t.updateMatrixWorld(),
                                null === e.parent &&
                                    !0 === e.matrixWorldAutoUpdate &&
                                    e.updateMatrixWorld(),
                                !0 === Rt.enabled &&
                                    !0 === Rt.isPresenting &&
                                    (!0 === Rt.cameraAutoUpdate &&
                                        Rt.updateCamera(e),
                                    (e = Rt.getCamera())),
                                !0 === t.isScene &&
                                    t.onBeforeRender(S, t, e, w),
                                (x = dt.get(t, y.length)),
                                x.init(),
                                y.push(x),
                                z.multiplyMatrices(
                                    e.projectionMatrix,
                                    e.matrixWorldInverse,
                                ),
                                j.setFromProjectionMatrix(z),
                                (F = this.localClippingEnabled),
                                (H = pt.init(this.clippingPlanes, F, e)),
                                (g = ut.get(t, b.length)),
                                g.init(),
                                b.push(g),
                                Vt(t, e, 0, S.sortObjects),
                                g.finish(),
                                !0 === S.sortObjects && g.sort(P, U),
                                !0 === H && pt.beginShadows();
                            const n = x.state.shadowsArray;
                            if (
                                (ft.render(n, t, e),
                                !0 === H && pt.endShadows(),
                                !0 === this.info.autoReset && this.info.reset(),
                                mt.render(g, t),
                                x.setupLights(S.physicallyCorrectLights),
                                e.isArrayCamera)
                            ) {
                                const n = e.cameras;
                                for (let e = 0, i = n.length; e < i; e++) {
                                    const i = n[e];
                                    Nt(g, t, i, i.viewport);
                                }
                            } else Nt(g, t, e);
                            null !== w &&
                                (it.updateMultisampleRenderTarget(w),
                                it.updateRenderTargetMipmap(w)),
                                !0 === t.isScene && t.onAfterRender(S, t, e),
                                At.resetDefaultState(),
                                (T = -1),
                                (E = null),
                                y.pop(),
                                (x = y.length > 0 ? y[y.length - 1] : null),
                                b.pop(),
                                (g = b.length > 0 ? b[b.length - 1] : null);
                        }),
                        (this.getActiveCubeFace = function () {
                            return A;
                        }),
                        (this.getActiveMipmapLevel = function () {
                            return _;
                        }),
                        (this.getRenderTarget = function () {
                            return w;
                        }),
                        (this.setRenderTargetTextures = function (t, e, n) {
                            (nt.get(t.texture).__webglTexture = e),
                                (nt.get(t.depthTexture).__webglTexture = n);
                            const i = nt.get(t);
                            (i.__hasExternalTextures = !0),
                                i.__hasExternalTextures &&
                                    ((i.__autoAllocateDepthBuffer =
                                        void 0 === n),
                                    i.__autoAllocateDepthBuffer ||
                                        (!0 ===
                                            X.has(
                                                "WEBGL_multisampled_render_to_texture",
                                            ) &&
                                            (console.warn(
                                                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided",
                                            ),
                                            (i.__useRenderToTexture = !1))));
                        }),
                        (this.setRenderTargetFramebuffer = function (t, e) {
                            const n = nt.get(t);
                            (n.__webglFramebuffer = e),
                                (n.__useDefaultFramebuffer = void 0 === e);
                        }),
                        (this.setRenderTarget = function (t, e = 0, n = 0) {
                            (w = t), (A = e), (_ = n);
                            let i = !0,
                                r = null,
                                a = !1,
                                s = !1;
                            if (t) {
                                const n = nt.get(t);
                                void 0 !== n.__useDefaultFramebuffer
                                    ? (tt.bindFramebuffer(36160, null),
                                      (i = !1))
                                    : void 0 === n.__webglFramebuffer
                                    ? it.setupRenderTarget(t)
                                    : n.__hasExternalTextures &&
                                      it.rebindTextures(
                                          t,
                                          nt.get(t.texture).__webglTexture,
                                          nt.get(t.depthTexture).__webglTexture,
                                      );
                                const o = t.texture;
                                (o.isData3DTexture ||
                                    o.isDataArrayTexture ||
                                    o.isCompressedArrayTexture) &&
                                    (s = !0);
                                const l = nt.get(t).__webglFramebuffer;
                                t.isWebGLCubeRenderTarget
                                    ? ((r = l[e]), (a = !0))
                                    : (r =
                                          $.isWebGL2 &&
                                          t.samples > 0 &&
                                          !1 === it.useMultisampledRTT(t)
                                              ? nt.get(t)
                                                    .__webglMultisampledFramebuffer
                                              : l),
                                    R.copy(t.viewport),
                                    k.copy(t.scissor),
                                    (L = t.scissorTest);
                            } else
                                R.copy(V).multiplyScalar(D).floor(),
                                    k.copy(N).multiplyScalar(D).floor(),
                                    (L = G);
                            if (
                                (tt.bindFramebuffer(36160, r) &&
                                    $.drawBuffers &&
                                    i &&
                                    tt.drawBuffers(t, r),
                                tt.viewport(R),
                                tt.scissor(k),
                                tt.setScissorTest(L),
                                a)
                            ) {
                                const i = nt.get(t.texture);
                                wt.framebufferTexture2D(
                                    36160,
                                    36064,
                                    34069 + e,
                                    i.__webglTexture,
                                    n,
                                );
                            } else if (s) {
                                const i = nt.get(t.texture),
                                    r = e || 0;
                                wt.framebufferTextureLayer(
                                    36160,
                                    36064,
                                    i.__webglTexture,
                                    n || 0,
                                    r,
                                );
                            }
                            T = -1;
                        }),
                        (this.readRenderTargetPixels = function (
                            t,
                            e,
                            n,
                            i,
                            r,
                            a,
                            s,
                        ) {
                            if (!t || !t.isWebGLRenderTarget)
                                return void console.error(
                                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
                                );
                            let o = nt.get(t).__webglFramebuffer;
                            if (
                                (t.isWebGLCubeRenderTarget &&
                                    void 0 !== s &&
                                    (o = o[s]),
                                o)
                            ) {
                                tt.bindFramebuffer(36160, o);
                                try {
                                    const s = t.texture,
                                        o = s.format,
                                        l = s.type;
                                    if (
                                        o !== v &&
                                        Mt.convert(o) !== wt.getParameter(35739)
                                    )
                                        return void console.error(
                                            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.",
                                        );
                                    const c =
                                        l === m &&
                                        (X.has("EXT_color_buffer_half_float") ||
                                            ($.isWebGL2 &&
                                                X.has(
                                                    "EXT_color_buffer_float",
                                                )));
                                    if (
                                        !(
                                            l === d ||
                                            Mt.convert(l) ===
                                                wt.getParameter(35738) ||
                                            (l === f &&
                                                ($.isWebGL2 ||
                                                    X.has(
                                                        "OES_texture_float",
                                                    ) ||
                                                    X.has(
                                                        "WEBGL_color_buffer_float",
                                                    ))) ||
                                            c
                                        )
                                    )
                                        return void console.error(
                                            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.",
                                        );
                                    e >= 0 &&
                                        e <= t.width - i &&
                                        n >= 0 &&
                                        n <= t.height - r &&
                                        wt.readPixels(
                                            e,
                                            n,
                                            i,
                                            r,
                                            Mt.convert(o),
                                            Mt.convert(l),
                                            a,
                                        );
                                } finally {
                                    const t =
                                        null !== w
                                            ? nt.get(w).__webglFramebuffer
                                            : null;
                                    tt.bindFramebuffer(36160, t);
                                }
                            }
                        }),
                        (this.copyFramebufferToTexture = function (
                            t,
                            e,
                            n = 0,
                        ) {
                            const i = Math.pow(2, -n),
                                r = Math.floor(e.image.width * i),
                                a = Math.floor(e.image.height * i);
                            it.setTexture2D(e, 0),
                                wt.copyTexSubImage2D(
                                    3553,
                                    n,
                                    0,
                                    0,
                                    t.x,
                                    t.y,
                                    r,
                                    a,
                                ),
                                tt.unbindTexture();
                        }),
                        (this.copyTextureToTexture = function (t, e, n, i = 0) {
                            const r = e.image.width,
                                a = e.image.height,
                                s = Mt.convert(n.format),
                                o = Mt.convert(n.type);
                            it.setTexture2D(n, 0),
                                wt.pixelStorei(37440, n.flipY),
                                wt.pixelStorei(37441, n.premultiplyAlpha),
                                wt.pixelStorei(3317, n.unpackAlignment),
                                e.isDataTexture
                                    ? wt.texSubImage2D(
                                          3553,
                                          i,
                                          t.x,
                                          t.y,
                                          r,
                                          a,
                                          s,
                                          o,
                                          e.image.data,
                                      )
                                    : e.isCompressedTexture
                                    ? wt.compressedTexSubImage2D(
                                          3553,
                                          i,
                                          t.x,
                                          t.y,
                                          e.mipmaps[0].width,
                                          e.mipmaps[0].height,
                                          s,
                                          e.mipmaps[0].data,
                                      )
                                    : wt.texSubImage2D(
                                          3553,
                                          i,
                                          t.x,
                                          t.y,
                                          s,
                                          o,
                                          e.image,
                                      ),
                                0 === i &&
                                    n.generateMipmaps &&
                                    wt.generateMipmap(3553),
                                tt.unbindTexture();
                        }),
                        (this.copyTextureToTexture3D = function (
                            t,
                            e,
                            n,
                            i,
                            r = 0,
                        ) {
                            if (S.isWebGL1Renderer)
                                return void console.warn(
                                    "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.",
                                );
                            const a = t.max.x - t.min.x + 1,
                                s = t.max.y - t.min.y + 1,
                                o = t.max.z - t.min.z + 1,
                                l = Mt.convert(i.format),
                                c = Mt.convert(i.type);
                            let h;
                            if (i.isData3DTexture)
                                it.setTexture3D(i, 0), (h = 32879);
                            else {
                                if (!i.isDataArrayTexture)
                                    return void console.warn(
                                        "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.",
                                    );
                                it.setTexture2DArray(i, 0), (h = 35866);
                            }
                            wt.pixelStorei(37440, i.flipY),
                                wt.pixelStorei(37441, i.premultiplyAlpha),
                                wt.pixelStorei(3317, i.unpackAlignment);
                            const u = wt.getParameter(3314),
                                d = wt.getParameter(32878),
                                p = wt.getParameter(3316),
                                f = wt.getParameter(3315),
                                m = wt.getParameter(32877),
                                g = n.isCompressedTexture
                                    ? n.mipmaps[0]
                                    : n.image;
                            wt.pixelStorei(3314, g.width),
                                wt.pixelStorei(32878, g.height),
                                wt.pixelStorei(3316, t.min.x),
                                wt.pixelStorei(3315, t.min.y),
                                wt.pixelStorei(32877, t.min.z),
                                n.isDataTexture || n.isData3DTexture
                                    ? wt.texSubImage3D(
                                          h,
                                          r,
                                          e.x,
                                          e.y,
                                          e.z,
                                          a,
                                          s,
                                          o,
                                          l,
                                          c,
                                          g.data,
                                      )
                                    : n.isCompressedArrayTexture
                                    ? (console.warn(
                                          "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.",
                                      ),
                                      wt.compressedTexSubImage3D(
                                          h,
                                          r,
                                          e.x,
                                          e.y,
                                          e.z,
                                          a,
                                          s,
                                          o,
                                          l,
                                          g.data,
                                      ))
                                    : wt.texSubImage3D(
                                          h,
                                          r,
                                          e.x,
                                          e.y,
                                          e.z,
                                          a,
                                          s,
                                          o,
                                          l,
                                          c,
                                          g,
                                      ),
                                wt.pixelStorei(3314, u),
                                wt.pixelStorei(32878, d),
                                wt.pixelStorei(3316, p),
                                wt.pixelStorei(3315, f),
                                wt.pixelStorei(32877, m),
                                0 === r &&
                                    i.generateMipmaps &&
                                    wt.generateMipmap(h),
                                tt.unbindTexture();
                        }),
                        (this.initTexture = function (t) {
                            t.isCubeTexture
                                ? it.setTextureCube(t, 0)
                                : t.isData3DTexture
                                ? it.setTexture3D(t, 0)
                                : t.isDataArrayTexture ||
                                  t.isCompressedArrayTexture
                                ? it.setTexture2DArray(t, 0)
                                : it.setTexture2D(t, 0),
                                tt.unbindTexture();
                        }),
                        (this.resetState = function () {
                            (A = 0),
                                (_ = 0),
                                (w = null),
                                tt.reset(),
                                At.reset();
                        }),
                        "undefined" != typeof __THREE_DEVTOOLS__ &&
                            __THREE_DEVTOOLS__.dispatchEvent(
                                new CustomEvent("observe", { detail: this }),
                            );
                }
                (class extends la {}.prototype.isWebGL1Renderer = !0);
                class ca extends Pe {
                    constructor(t) {
                        super(),
                            (this.isLineBasicMaterial = !0),
                            (this.type = "LineBasicMaterial"),
                            (this.color = new ct(16777215)),
                            (this.linewidth = 1),
                            (this.linecap = "round"),
                            (this.linejoin = "round"),
                            (this.fog = !0),
                            this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            this.color.copy(t.color),
                            (this.linewidth = t.linewidth),
                            (this.linecap = t.linecap),
                            (this.linejoin = t.linejoin),
                            (this.fog = t.fog),
                            this
                        );
                    }
                }
                const ha = new St(),
                    ua = new St(),
                    da = new Xt(),
                    pa = new Zt(),
                    fa = new Ft();
                class ma extends Me {
                    constructor(t = new Ze(), e = new ca()) {
                        super(),
                            (this.isLine = !0),
                            (this.type = "Line"),
                            (this.geometry = t),
                            (this.material = e),
                            this.updateMorphTargets();
                    }
                    copy(t, e) {
                        return (
                            super.copy(t, e),
                            (this.material = t.material),
                            (this.geometry = t.geometry),
                            this
                        );
                    }
                    computeLineDistances() {
                        const t = this.geometry;
                        if (null === t.index) {
                            const e = t.attributes.position,
                                n = [0];
                            for (let t = 1, i = e.count; t < i; t++)
                                ha.fromBufferAttribute(e, t - 1),
                                    ua.fromBufferAttribute(e, t),
                                    (n[t] = n[t - 1]),
                                    (n[t] += ha.distanceTo(ua));
                            t.setAttribute("lineDistance", new Fe(n, 1));
                        } else
                            console.warn(
                                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
                            );
                        return this;
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            i = this.matrixWorld,
                            r = t.params.Line.threshold,
                            a = n.drawRange;
                        if (
                            (null === n.boundingSphere &&
                                n.computeBoundingSphere(),
                            fa.copy(n.boundingSphere),
                            fa.applyMatrix4(i),
                            (fa.radius += r),
                            !1 === t.ray.intersectsSphere(fa))
                        )
                            return;
                        da.copy(i).invert(), pa.copy(t.ray).applyMatrix4(da);
                        const s =
                                r /
                                ((this.scale.x + this.scale.y + this.scale.z) /
                                    3),
                            o = s * s,
                            l = new St(),
                            c = new St(),
                            h = new St(),
                            u = new St(),
                            d = this.isLineSegments ? 2 : 1,
                            p = n.index,
                            f = n.attributes.position;
                        if (null !== p)
                            for (
                                let n = Math.max(0, a.start),
                                    i =
                                        Math.min(p.count, a.start + a.count) -
                                        1;
                                n < i;
                                n += d
                            ) {
                                const i = p.getX(n),
                                    r = p.getX(n + 1);
                                if (
                                    (l.fromBufferAttribute(f, i),
                                    c.fromBufferAttribute(f, r),
                                    pa.distanceSqToSegment(l, c, u, h) > o)
                                )
                                    continue;
                                u.applyMatrix4(this.matrixWorld);
                                const a = t.ray.origin.distanceTo(u);
                                a < t.near ||
                                    a > t.far ||
                                    e.push({
                                        distance: a,
                                        point: h
                                            .clone()
                                            .applyMatrix4(this.matrixWorld),
                                        index: n,
                                        face: null,
                                        faceIndex: null,
                                        object: this,
                                    });
                            }
                        else
                            for (
                                let n = Math.max(0, a.start),
                                    i =
                                        Math.min(f.count, a.start + a.count) -
                                        1;
                                n < i;
                                n += d
                            ) {
                                if (
                                    (l.fromBufferAttribute(f, n),
                                    c.fromBufferAttribute(f, n + 1),
                                    pa.distanceSqToSegment(l, c, u, h) > o)
                                )
                                    continue;
                                u.applyMatrix4(this.matrixWorld);
                                const i = t.ray.origin.distanceTo(u);
                                i < t.near ||
                                    i > t.far ||
                                    e.push({
                                        distance: i,
                                        point: h
                                            .clone()
                                            .applyMatrix4(this.matrixWorld),
                                        index: n,
                                        face: null,
                                        faceIndex: null,
                                        object: this,
                                    });
                            }
                    }
                    updateMorphTargets() {
                        const t = this.geometry.morphAttributes,
                            e = Object.keys(t);
                        if (e.length > 0) {
                            const n = t[e[0]];
                            if (void 0 !== n) {
                                (this.morphTargetInfluences = []),
                                    (this.morphTargetDictionary = {});
                                for (let t = 0, e = n.length; t < e; t++) {
                                    const e = n[t].name || String(t);
                                    this.morphTargetInfluences.push(0),
                                        (this.morphTargetDictionary[e] = t);
                                }
                            }
                        }
                    }
                }
                const ga = new St(),
                    va = new St();
                class xa extends ma {
                    constructor(t, e) {
                        super(t, e),
                            (this.isLineSegments = !0),
                            (this.type = "LineSegments");
                    }
                    computeLineDistances() {
                        const t = this.geometry;
                        if (null === t.index) {
                            const e = t.attributes.position,
                                n = [];
                            for (let t = 0, i = e.count; t < i; t += 2)
                                ga.fromBufferAttribute(e, t),
                                    va.fromBufferAttribute(e, t + 1),
                                    (n[t] = 0 === t ? 0 : n[t - 1]),
                                    (n[t + 1] = n[t] + ga.distanceTo(va));
                            t.setAttribute("lineDistance", new Fe(n, 1));
                        } else
                            console.warn(
                                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
                            );
                        return this;
                    }
                }
                class ba extends Pe {
                    constructor(t) {
                        super(),
                            (this.isPointsMaterial = !0),
                            (this.type = "PointsMaterial"),
                            (this.color = new ct(16777215)),
                            (this.map = null),
                            (this.alphaMap = null),
                            (this.size = 1),
                            (this.sizeAttenuation = !0),
                            (this.fog = !0),
                            this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            this.color.copy(t.color),
                            (this.map = t.map),
                            (this.alphaMap = t.alphaMap),
                            (this.size = t.size),
                            (this.sizeAttenuation = t.sizeAttenuation),
                            (this.fog = t.fog),
                            this
                        );
                    }
                }
                const ya = new Xt(),
                    Sa = new Zt(),
                    Ma = new Ft(),
                    Aa = new St();
                class _a extends Me {
                    constructor(t = new Ze(), e = new ba()) {
                        super(),
                            (this.isPoints = !0),
                            (this.type = "Points"),
                            (this.geometry = t),
                            (this.material = e),
                            this.updateMorphTargets();
                    }
                    copy(t, e) {
                        return (
                            super.copy(t, e),
                            (this.material = t.material),
                            (this.geometry = t.geometry),
                            this
                        );
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            i = this.matrixWorld,
                            r = t.params.Points.threshold,
                            a = n.drawRange;
                        if (
                            (null === n.boundingSphere &&
                                n.computeBoundingSphere(),
                            Ma.copy(n.boundingSphere),
                            Ma.applyMatrix4(i),
                            (Ma.radius += r),
                            !1 === t.ray.intersectsSphere(Ma))
                        )
                            return;
                        ya.copy(i).invert(), Sa.copy(t.ray).applyMatrix4(ya);
                        const s =
                                r /
                                ((this.scale.x + this.scale.y + this.scale.z) /
                                    3),
                            o = s * s,
                            l = n.index,
                            c = n.attributes.position;
                        if (null !== l)
                            for (
                                let n = Math.max(0, a.start),
                                    r = Math.min(l.count, a.start + a.count);
                                n < r;
                                n++
                            ) {
                                const r = l.getX(n);
                                Aa.fromBufferAttribute(c, r),
                                    wa(Aa, r, o, i, t, e, this);
                            }
                        else
                            for (
                                let n = Math.max(0, a.start),
                                    r = Math.min(c.count, a.start + a.count);
                                n < r;
                                n++
                            )
                                Aa.fromBufferAttribute(c, n),
                                    wa(Aa, n, o, i, t, e, this);
                    }
                    updateMorphTargets() {
                        const t = this.geometry.morphAttributes,
                            e = Object.keys(t);
                        if (e.length > 0) {
                            const n = t[e[0]];
                            if (void 0 !== n) {
                                (this.morphTargetInfluences = []),
                                    (this.morphTargetDictionary = {});
                                for (let t = 0, e = n.length; t < e; t++) {
                                    const e = n[t].name || String(t);
                                    this.morphTargetInfluences.push(0),
                                        (this.morphTargetDictionary[e] = t);
                                }
                            }
                        }
                    }
                }
                function wa(t, e, n, i, r, a, s) {
                    const o = Sa.distanceSqToPoint(t);
                    if (o < n) {
                        const n = new St();
                        Sa.closestPointToPoint(t, n), n.applyMatrix4(i);
                        const l = r.ray.origin.distanceTo(n);
                        if (l < r.near || l > r.far) return;
                        a.push({
                            distance: l,
                            distanceToRay: Math.sqrt(o),
                            point: n,
                            index: e,
                            face: null,
                            object: s,
                        });
                    }
                }
                class Ta extends Pe {
                    constructor(t) {
                        super(),
                            (this.isMeshPhongMaterial = !0),
                            (this.type = "MeshPhongMaterial"),
                            (this.color = new ct(16777215)),
                            (this.specular = new ct(1118481)),
                            (this.shininess = 30),
                            (this.map = null),
                            (this.lightMap = null),
                            (this.lightMapIntensity = 1),
                            (this.aoMap = null),
                            (this.aoMapIntensity = 1),
                            (this.emissive = new ct(0)),
                            (this.emissiveIntensity = 1),
                            (this.emissiveMap = null),
                            (this.bumpMap = null),
                            (this.bumpScale = 1),
                            (this.normalMap = null),
                            (this.normalMapType = 0),
                            (this.normalScale = new K(1, 1)),
                            (this.displacementMap = null),
                            (this.displacementScale = 1),
                            (this.displacementBias = 0),
                            (this.specularMap = null),
                            (this.alphaMap = null),
                            (this.envMap = null),
                            (this.combine = 0),
                            (this.reflectivity = 1),
                            (this.refractionRatio = 0.98),
                            (this.wireframe = !1),
                            (this.wireframeLinewidth = 1),
                            (this.wireframeLinecap = "round"),
                            (this.wireframeLinejoin = "round"),
                            (this.flatShading = !1),
                            (this.fog = !0),
                            this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            this.color.copy(t.color),
                            this.specular.copy(t.specular),
                            (this.shininess = t.shininess),
                            (this.map = t.map),
                            (this.lightMap = t.lightMap),
                            (this.lightMapIntensity = t.lightMapIntensity),
                            (this.aoMap = t.aoMap),
                            (this.aoMapIntensity = t.aoMapIntensity),
                            this.emissive.copy(t.emissive),
                            (this.emissiveMap = t.emissiveMap),
                            (this.emissiveIntensity = t.emissiveIntensity),
                            (this.bumpMap = t.bumpMap),
                            (this.bumpScale = t.bumpScale),
                            (this.normalMap = t.normalMap),
                            (this.normalMapType = t.normalMapType),
                            this.normalScale.copy(t.normalScale),
                            (this.displacementMap = t.displacementMap),
                            (this.displacementScale = t.displacementScale),
                            (this.displacementBias = t.displacementBias),
                            (this.specularMap = t.specularMap),
                            (this.alphaMap = t.alphaMap),
                            (this.envMap = t.envMap),
                            (this.combine = t.combine),
                            (this.reflectivity = t.reflectivity),
                            (this.refractionRatio = t.refractionRatio),
                            (this.wireframe = t.wireframe),
                            (this.wireframeLinewidth = t.wireframeLinewidth),
                            (this.wireframeLinecap = t.wireframeLinecap),
                            (this.wireframeLinejoin = t.wireframeLinejoin),
                            (this.flatShading = t.flatShading),
                            (this.fog = t.fog),
                            this
                        );
                    }
                }
                function Ea(t, e, n) {
                    return ka(t)
                        ? new t.constructor(
                              t.subarray(e, void 0 !== n ? n : t.length),
                          )
                        : t.slice(e, n);
                }
                function Ra(t, e, n) {
                    return !t || (!n && t.constructor === e)
                        ? t
                        : "number" == typeof e.BYTES_PER_ELEMENT
                        ? new e(t)
                        : Array.prototype.slice.call(t);
                }
                function ka(t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView);
                }
                function Ca(t) {
                    const e = t.length,
                        n = new Array(e);
                    for (let t = 0; t !== e; ++t) n[t] = t;
                    return (
                        n.sort(function (e, n) {
                            return t[e] - t[n];
                        }),
                        n
                    );
                }
                function La(t, e, n) {
                    const i = t.length,
                        r = new t.constructor(i);
                    for (let a = 0, s = 0; s !== i; ++a) {
                        const i = n[a] * e;
                        for (let n = 0; n !== e; ++n) r[s++] = t[i + n];
                    }
                    return r;
                }
                function Ia(t, e, n, i) {
                    let r = 1,
                        a = t[0];
                    for (; void 0 !== a && void 0 === a[i]; ) a = t[r++];
                    if (void 0 === a) return;
                    let s = a[i];
                    if (void 0 !== s)
                        if (Array.isArray(s))
                            do {
                                (s = a[i]),
                                    void 0 !== s &&
                                        (e.push(a.time), n.push.apply(n, s)),
                                    (a = t[r++]);
                            } while (void 0 !== a);
                        else if (void 0 !== s.toArray)
                            do {
                                (s = a[i]),
                                    void 0 !== s &&
                                        (e.push(a.time),
                                        s.toArray(n, n.length)),
                                    (a = t[r++]);
                            } while (void 0 !== a);
                        else
                            do {
                                (s = a[i]),
                                    void 0 !== s && (e.push(a.time), n.push(s)),
                                    (a = t[r++]);
                            } while (void 0 !== a);
                }
                class Oa {
                    constructor(t, e, n, i) {
                        (this.parameterPositions = t),
                            (this._cachedIndex = 0),
                            (this.resultBuffer =
                                void 0 !== i ? i : new e.constructor(n)),
                            (this.sampleValues = e),
                            (this.valueSize = n),
                            (this.settings = null),
                            (this.DefaultSettings_ = {});
                    }
                    evaluate(t) {
                        const e = this.parameterPositions;
                        let n = this._cachedIndex,
                            i = e[n],
                            r = e[n - 1];
                        t: {
                            e: {
                                let a;
                                n: {
                                    i: if (!(t < i)) {
                                        for (let a = n + 2; ; ) {
                                            if (void 0 === i) {
                                                if (t < r) break i;
                                                return (
                                                    (n = e.length),
                                                    (this._cachedIndex = n),
                                                    this.copySampleValue_(n - 1)
                                                );
                                            }
                                            if (n === a) break;
                                            if (((r = i), (i = e[++n]), t < i))
                                                break e;
                                        }
                                        a = e.length;
                                        break n;
                                    }
                                    if (t >= r) break t;
                                    {
                                        const s = e[1];
                                        t < s && ((n = 2), (r = s));
                                        for (let a = n - 2; ; ) {
                                            if (void 0 === r)
                                                return (
                                                    (this._cachedIndex = 0),
                                                    this.copySampleValue_(0)
                                                );
                                            if (n === a) break;
                                            if (
                                                ((i = r),
                                                (r = e[--n - 1]),
                                                t >= r)
                                            )
                                                break e;
                                        }
                                        (a = n), (n = 0);
                                    }
                                }
                                for (; n < a; ) {
                                    const i = (n + a) >>> 1;
                                    t < e[i] ? (a = i) : (n = i + 1);
                                }
                                if (((i = e[n]), (r = e[n - 1]), void 0 === r))
                                    return (
                                        (this._cachedIndex = 0),
                                        this.copySampleValue_(0)
                                    );
                                if (void 0 === i)
                                    return (
                                        (n = e.length),
                                        (this._cachedIndex = n),
                                        this.copySampleValue_(n - 1)
                                    );
                            }
                            (this._cachedIndex = n),
                                this.intervalChanged_(n, r, i);
                        }
                        return this.interpolate_(n, r, t, i);
                    }
                    getSettings_() {
                        return this.settings || this.DefaultSettings_;
                    }
                    copySampleValue_(t) {
                        const e = this.resultBuffer,
                            n = this.sampleValues,
                            i = this.valueSize,
                            r = t * i;
                        for (let t = 0; t !== i; ++t) e[t] = n[r + t];
                        return e;
                    }
                    interpolate_() {
                        throw new Error("call to abstract method");
                    }
                    intervalChanged_() {}
                }
                class Da extends Oa {
                    constructor(t, e, n, i) {
                        super(t, e, n, i),
                            (this._weightPrev = -0),
                            (this._offsetPrev = -0),
                            (this._weightNext = -0),
                            (this._offsetNext = -0),
                            (this.DefaultSettings_ = {
                                endingStart: E,
                                endingEnd: E,
                            });
                    }
                    intervalChanged_(t, e, n) {
                        const i = this.parameterPositions;
                        let r = t - 2,
                            a = t + 1,
                            s = i[r],
                            o = i[a];
                        if (void 0 === s)
                            switch (this.getSettings_().endingStart) {
                                case R:
                                    (r = t), (s = 2 * e - n);
                                    break;
                                case k:
                                    (r = i.length - 2),
                                        (s = e + i[r] - i[r + 1]);
                                    break;
                                default:
                                    (r = t), (s = n);
                            }
                        if (void 0 === o)
                            switch (this.getSettings_().endingEnd) {
                                case R:
                                    (a = t), (o = 2 * n - e);
                                    break;
                                case k:
                                    (a = 1), (o = n + i[1] - i[0]);
                                    break;
                                default:
                                    (a = t - 1), (o = e);
                            }
                        const l = 0.5 * (n - e),
                            c = this.valueSize;
                        (this._weightPrev = l / (e - s)),
                            (this._weightNext = l / (o - n)),
                            (this._offsetPrev = r * c),
                            (this._offsetNext = a * c);
                    }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            a = this.sampleValues,
                            s = this.valueSize,
                            o = t * s,
                            l = o - s,
                            c = this._offsetPrev,
                            h = this._offsetNext,
                            u = this._weightPrev,
                            d = this._weightNext,
                            p = (n - e) / (i - e),
                            f = p * p,
                            m = f * p,
                            g = -u * m + 2 * u * f - u * p,
                            v =
                                (1 + u) * m +
                                (-1.5 - 2 * u) * f +
                                (-0.5 + u) * p +
                                1,
                            x = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
                            b = d * m - d * f;
                        for (let t = 0; t !== s; ++t)
                            r[t] =
                                g * a[c + t] +
                                v * a[l + t] +
                                x * a[o + t] +
                                b * a[h + t];
                        return r;
                    }
                }
                class Pa extends Oa {
                    constructor(t, e, n, i) {
                        super(t, e, n, i);
                    }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            a = this.sampleValues,
                            s = this.valueSize,
                            o = t * s,
                            l = o - s,
                            c = (n - e) / (i - e),
                            h = 1 - c;
                        for (let t = 0; t !== s; ++t)
                            r[t] = a[l + t] * h + a[o + t] * c;
                        return r;
                    }
                }
                class Ua extends Oa {
                    constructor(t, e, n, i) {
                        super(t, e, n, i);
                    }
                    interpolate_(t) {
                        return this.copySampleValue_(t - 1);
                    }
                }
                class Va {
                    constructor(t, e, n, i) {
                        if (void 0 === t)
                            throw new Error(
                                "THREE.KeyframeTrack: track name is undefined",
                            );
                        if (void 0 === e || 0 === e.length)
                            throw new Error(
                                "THREE.KeyframeTrack: no keyframes in track named " +
                                    t,
                            );
                        (this.name = t),
                            (this.times = Ra(e, this.TimeBufferType)),
                            (this.values = Ra(n, this.ValueBufferType)),
                            this.setInterpolation(
                                i || this.DefaultInterpolation,
                            );
                    }
                    static toJSON(t) {
                        const e = t.constructor;
                        let n;
                        if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                        else {
                            n = {
                                name: t.name,
                                times: Ra(t.times, Array),
                                values: Ra(t.values, Array),
                            };
                            const e = t.getInterpolation();
                            e !== t.DefaultInterpolation &&
                                (n.interpolation = e);
                        }
                        return (n.type = t.ValueTypeName), n;
                    }
                    InterpolantFactoryMethodDiscrete(t) {
                        return new Ua(
                            this.times,
                            this.values,
                            this.getValueSize(),
                            t,
                        );
                    }
                    InterpolantFactoryMethodLinear(t) {
                        return new Pa(
                            this.times,
                            this.values,
                            this.getValueSize(),
                            t,
                        );
                    }
                    InterpolantFactoryMethodSmooth(t) {
                        return new Da(
                            this.times,
                            this.values,
                            this.getValueSize(),
                            t,
                        );
                    }
                    setInterpolation(t) {
                        let e;
                        switch (t) {
                            case _:
                                e = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case w:
                                e = this.InterpolantFactoryMethodLinear;
                                break;
                            case T:
                                e = this.InterpolantFactoryMethodSmooth;
                        }
                        if (void 0 === e) {
                            const e =
                                "unsupported interpolation for " +
                                this.ValueTypeName +
                                " keyframe track named " +
                                this.name;
                            if (void 0 === this.createInterpolant) {
                                if (t === this.DefaultInterpolation)
                                    throw new Error(e);
                                this.setInterpolation(
                                    this.DefaultInterpolation,
                                );
                            }
                            return (
                                console.warn("THREE.KeyframeTrack:", e), this
                            );
                        }
                        return (this.createInterpolant = e), this;
                    }
                    getInterpolation() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return _;
                            case this.InterpolantFactoryMethodLinear:
                                return w;
                            case this.InterpolantFactoryMethodSmooth:
                                return T;
                        }
                    }
                    getValueSize() {
                        return this.values.length / this.times.length;
                    }
                    shift(t) {
                        if (0 !== t) {
                            const e = this.times;
                            for (let n = 0, i = e.length; n !== i; ++n)
                                e[n] += t;
                        }
                        return this;
                    }
                    scale(t) {
                        if (1 !== t) {
                            const e = this.times;
                            for (let n = 0, i = e.length; n !== i; ++n)
                                e[n] *= t;
                        }
                        return this;
                    }
                    trim(t, e) {
                        const n = this.times,
                            i = n.length;
                        let r = 0,
                            a = i - 1;
                        for (; r !== i && n[r] < t; ) ++r;
                        for (; -1 !== a && n[a] > e; ) --a;
                        if ((++a, 0 !== r || a !== i)) {
                            r >= a && ((a = Math.max(a, 1)), (r = a - 1));
                            const t = this.getValueSize();
                            (this.times = Ea(n, r, a)),
                                (this.values = Ea(this.values, r * t, a * t));
                        }
                        return this;
                    }
                    validate() {
                        let t = !0;
                        const e = this.getValueSize();
                        e - Math.floor(e) != 0 &&
                            (console.error(
                                "THREE.KeyframeTrack: Invalid value size in track.",
                                this,
                            ),
                            (t = !1));
                        const n = this.times,
                            i = this.values,
                            r = n.length;
                        0 === r &&
                            (console.error(
                                "THREE.KeyframeTrack: Track is empty.",
                                this,
                            ),
                            (t = !1));
                        let a = null;
                        for (let e = 0; e !== r; e++) {
                            const i = n[e];
                            if ("number" == typeof i && isNaN(i)) {
                                console.error(
                                    "THREE.KeyframeTrack: Time is not a valid number.",
                                    this,
                                    e,
                                    i,
                                ),
                                    (t = !1);
                                break;
                            }
                            if (null !== a && a > i) {
                                console.error(
                                    "THREE.KeyframeTrack: Out of order keys.",
                                    this,
                                    e,
                                    i,
                                    a,
                                ),
                                    (t = !1);
                                break;
                            }
                            a = i;
                        }
                        if (void 0 !== i && ka(i))
                            for (let e = 0, n = i.length; e !== n; ++e) {
                                const n = i[e];
                                if (isNaN(n)) {
                                    console.error(
                                        "THREE.KeyframeTrack: Value is not a valid number.",
                                        this,
                                        e,
                                        n,
                                    ),
                                        (t = !1);
                                    break;
                                }
                            }
                        return t;
                    }
                    optimize() {
                        const t = Ea(this.times),
                            e = Ea(this.values),
                            n = this.getValueSize(),
                            i = this.getInterpolation() === T,
                            r = t.length - 1;
                        let a = 1;
                        for (let s = 1; s < r; ++s) {
                            let r = !1;
                            const o = t[s];
                            if (o !== t[s + 1] && (1 !== s || o !== t[0]))
                                if (i) r = !0;
                                else {
                                    const t = s * n,
                                        i = t - n,
                                        a = t + n;
                                    for (let s = 0; s !== n; ++s) {
                                        const n = e[t + s];
                                        if (n !== e[i + s] || n !== e[a + s]) {
                                            r = !0;
                                            break;
                                        }
                                    }
                                }
                            if (r) {
                                if (s !== a) {
                                    t[a] = t[s];
                                    const i = s * n,
                                        r = a * n;
                                    for (let t = 0; t !== n; ++t)
                                        e[r + t] = e[i + t];
                                }
                                ++a;
                            }
                        }
                        if (r > 0) {
                            t[a] = t[r];
                            for (let t = r * n, i = a * n, s = 0; s !== n; ++s)
                                e[i + s] = e[t + s];
                            ++a;
                        }
                        return (
                            a !== t.length
                                ? ((this.times = Ea(t, 0, a)),
                                  (this.values = Ea(e, 0, a * n)))
                                : ((this.times = t), (this.values = e)),
                            this
                        );
                    }
                    clone() {
                        const t = Ea(this.times, 0),
                            e = Ea(this.values, 0),
                            n = new (0, this.constructor)(this.name, t, e);
                        return (
                            (n.createInterpolant = this.createInterpolant), n
                        );
                    }
                }
                (Va.prototype.TimeBufferType = Float32Array),
                    (Va.prototype.ValueBufferType = Float32Array),
                    (Va.prototype.DefaultInterpolation = w);
                class Na extends Va {}
                (Na.prototype.ValueTypeName = "bool"),
                    (Na.prototype.ValueBufferType = Array),
                    (Na.prototype.DefaultInterpolation = _),
                    (Na.prototype.InterpolantFactoryMethodLinear = void 0),
                    (Na.prototype.InterpolantFactoryMethodSmooth = void 0);
                class Ga extends Va {}
                Ga.prototype.ValueTypeName = "color";
                class ja extends Va {}
                ja.prototype.ValueTypeName = "number";
                class Ha extends Oa {
                    constructor(t, e, n, i) {
                        super(t, e, n, i);
                    }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            a = this.sampleValues,
                            s = this.valueSize,
                            o = (n - e) / (i - e);
                        let l = t * s;
                        for (let t = l + s; l !== t; l += 4)
                            yt.slerpFlat(r, 0, a, l - s, a, l, o);
                        return r;
                    }
                }
                class Fa extends Va {
                    InterpolantFactoryMethodLinear(t) {
                        return new Ha(
                            this.times,
                            this.values,
                            this.getValueSize(),
                            t,
                        );
                    }
                }
                (Fa.prototype.ValueTypeName = "quaternion"),
                    (Fa.prototype.DefaultInterpolation = w),
                    (Fa.prototype.InterpolantFactoryMethodSmooth = void 0);
                class Ba extends Va {}
                (Ba.prototype.ValueTypeName = "string"),
                    (Ba.prototype.ValueBufferType = Array),
                    (Ba.prototype.DefaultInterpolation = _),
                    (Ba.prototype.InterpolantFactoryMethodLinear = void 0),
                    (Ba.prototype.InterpolantFactoryMethodSmooth = void 0);
                class za extends Va {}
                za.prototype.ValueTypeName = "vector";
                class Wa {
                    constructor(t, e = -1, n, i = 2500) {
                        (this.name = t),
                            (this.tracks = n),
                            (this.duration = e),
                            (this.blendMode = i),
                            (this.uuid = H()),
                            this.duration < 0 && this.resetDuration();
                    }
                    static parse(t) {
                        const e = [],
                            n = t.tracks,
                            i = 1 / (t.fps || 1);
                        for (let t = 0, r = n.length; t !== r; ++t)
                            e.push(qa(n[t]).scale(i));
                        const r = new this(t.name, t.duration, e, t.blendMode);
                        return (r.uuid = t.uuid), r;
                    }
                    static toJSON(t) {
                        const e = [],
                            n = t.tracks,
                            i = {
                                name: t.name,
                                duration: t.duration,
                                tracks: e,
                                uuid: t.uuid,
                                blendMode: t.blendMode,
                            };
                        for (let t = 0, i = n.length; t !== i; ++t)
                            e.push(Va.toJSON(n[t]));
                        return i;
                    }
                    static CreateFromMorphTargetSequence(t, e, n, i) {
                        const r = e.length,
                            a = [];
                        for (let t = 0; t < r; t++) {
                            let s = [],
                                o = [];
                            s.push((t + r - 1) % r, t, (t + 1) % r),
                                o.push(0, 1, 0);
                            const l = Ca(s);
                            (s = La(s, 1, l)),
                                (o = La(o, 1, l)),
                                i || 0 !== s[0] || (s.push(r), o.push(o[0])),
                                a.push(
                                    new ja(
                                        ".morphTargetInfluences[" +
                                            e[t].name +
                                            "]",
                                        s,
                                        o,
                                    ).scale(1 / n),
                                );
                        }
                        return new this(t, -1, a);
                    }
                    static findByName(t, e) {
                        let n = t;
                        if (!Array.isArray(t)) {
                            const e = t;
                            n =
                                (e.geometry && e.geometry.animations) ||
                                e.animations;
                        }
                        for (let t = 0; t < n.length; t++)
                            if (n[t].name === e) return n[t];
                        return null;
                    }
                    static CreateClipsFromMorphTargetSequences(t, e, n) {
                        const i = {},
                            r = /^([\w-]*?)([\d]+)$/;
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e],
                                a = n.name.match(r);
                            if (a && a.length > 1) {
                                const t = a[1];
                                let e = i[t];
                                e || (i[t] = e = []), e.push(n);
                            }
                        }
                        const a = [];
                        for (const t in i)
                            a.push(
                                this.CreateFromMorphTargetSequence(
                                    t,
                                    i[t],
                                    e,
                                    n,
                                ),
                            );
                        return a;
                    }
                    static parseAnimation(t, e) {
                        if (!t)
                            return (
                                console.error(
                                    "THREE.AnimationClip: No animation in JSONLoader data.",
                                ),
                                null
                            );
                        const n = function (t, e, n, i, r) {
                                if (0 !== n.length) {
                                    const a = [],
                                        s = [];
                                    Ia(n, a, s, i),
                                        0 !== a.length &&
                                            r.push(new t(e, a, s));
                                }
                            },
                            i = [],
                            r = t.name || "default",
                            a = t.fps || 30,
                            s = t.blendMode;
                        let o = t.length || -1;
                        const l = t.hierarchy || [];
                        for (let t = 0; t < l.length; t++) {
                            const r = l[t].keys;
                            if (r && 0 !== r.length)
                                if (r[0].morphTargets) {
                                    const t = {};
                                    let e;
                                    for (e = 0; e < r.length; e++)
                                        if (r[e].morphTargets)
                                            for (
                                                let n = 0;
                                                n < r[e].morphTargets.length;
                                                n++
                                            )
                                                t[r[e].morphTargets[n]] = -1;
                                    for (const n in t) {
                                        const t = [],
                                            a = [];
                                        for (
                                            let i = 0;
                                            i !== r[e].morphTargets.length;
                                            ++i
                                        ) {
                                            const i = r[e];
                                            t.push(i.time),
                                                a.push(
                                                    i.morphTarget === n ? 1 : 0,
                                                );
                                        }
                                        i.push(
                                            new ja(
                                                ".morphTargetInfluence[" +
                                                    n +
                                                    "]",
                                                t,
                                                a,
                                            ),
                                        );
                                    }
                                    o = t.length * a;
                                } else {
                                    const a = ".bones[" + e[t].name + "]";
                                    n(za, a + ".position", r, "pos", i),
                                        n(Fa, a + ".quaternion", r, "rot", i),
                                        n(za, a + ".scale", r, "scl", i);
                                }
                        }
                        return 0 === i.length ? null : new this(r, o, i, s);
                    }
                    resetDuration() {
                        let t = 0;
                        for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                            const n = this.tracks[e];
                            t = Math.max(t, n.times[n.times.length - 1]);
                        }
                        return (this.duration = t), this;
                    }
                    trim() {
                        for (let t = 0; t < this.tracks.length; t++)
                            this.tracks[t].trim(0, this.duration);
                        return this;
                    }
                    validate() {
                        let t = !0;
                        for (let e = 0; e < this.tracks.length; e++)
                            t = t && this.tracks[e].validate();
                        return t;
                    }
                    optimize() {
                        for (let t = 0; t < this.tracks.length; t++)
                            this.tracks[t].optimize();
                        return this;
                    }
                    clone() {
                        const t = [];
                        for (let e = 0; e < this.tracks.length; e++)
                            t.push(this.tracks[e].clone());
                        return new this.constructor(
                            this.name,
                            this.duration,
                            t,
                            this.blendMode,
                        );
                    }
                    toJSON() {
                        return this.constructor.toJSON(this);
                    }
                }
                function qa(t) {
                    if (void 0 === t.type)
                        throw new Error(
                            "THREE.KeyframeTrack: track type undefined, can not parse",
                        );
                    const e = (function (t) {
                        switch (t.toLowerCase()) {
                            case "scalar":
                            case "double":
                            case "float":
                            case "number":
                            case "integer":
                                return ja;
                            case "vector":
                            case "vector2":
                            case "vector3":
                            case "vector4":
                                return za;
                            case "color":
                                return Ga;
                            case "quaternion":
                                return Fa;
                            case "bool":
                            case "boolean":
                                return Na;
                            case "string":
                                return Ba;
                        }
                        throw new Error(
                            "THREE.KeyframeTrack: Unsupported typeName: " + t,
                        );
                    })(t.type);
                    if (void 0 === t.times) {
                        const e = [],
                            n = [];
                        Ia(t.keys, e, n, "value"),
                            (t.times = e),
                            (t.values = n);
                    }
                    return void 0 !== e.parse
                        ? e.parse(t)
                        : new e(t.name, t.times, t.values, t.interpolation);
                }
                const Ya = {
                    enabled: !1,
                    files: {},
                    add: function (t, e) {
                        !1 !== this.enabled && (this.files[t] = e);
                    },
                    get: function (t) {
                        if (!1 !== this.enabled) return this.files[t];
                    },
                    remove: function (t) {
                        delete this.files[t];
                    },
                    clear: function () {
                        this.files = {};
                    },
                };
                class Ka {
                    constructor(t, e, n) {
                        const i = this;
                        let r,
                            a = !1,
                            s = 0,
                            o = 0;
                        const l = [];
                        (this.onStart = void 0),
                            (this.onLoad = t),
                            (this.onProgress = e),
                            (this.onError = n),
                            (this.itemStart = function (t) {
                                o++,
                                    !1 === a &&
                                        void 0 !== i.onStart &&
                                        i.onStart(t, s, o),
                                    (a = !0);
                            }),
                            (this.itemEnd = function (t) {
                                s++,
                                    void 0 !== i.onProgress &&
                                        i.onProgress(t, s, o),
                                    s === o &&
                                        ((a = !1),
                                        void 0 !== i.onLoad && i.onLoad());
                            }),
                            (this.itemError = function (t) {
                                void 0 !== i.onError && i.onError(t);
                            }),
                            (this.resolveURL = function (t) {
                                return r ? r(t) : t;
                            }),
                            (this.setURLModifier = function (t) {
                                return (r = t), this;
                            }),
                            (this.addHandler = function (t, e) {
                                return l.push(t, e), this;
                            }),
                            (this.removeHandler = function (t) {
                                const e = l.indexOf(t);
                                return -1 !== e && l.splice(e, 2), this;
                            }),
                            (this.getHandler = function (t) {
                                for (let e = 0, n = l.length; e < n; e += 2) {
                                    const n = l[e],
                                        i = l[e + 1];
                                    if (
                                        (n.global && (n.lastIndex = 0),
                                        n.test(t))
                                    )
                                        return i;
                                }
                                return null;
                            });
                    }
                }
                const Ja = new Ka();
                class Za {
                    constructor(t) {
                        (this.manager = void 0 !== t ? t : Ja),
                            (this.crossOrigin = "anonymous"),
                            (this.withCredentials = !1),
                            (this.path = ""),
                            (this.resourcePath = ""),
                            (this.requestHeader = {});
                    }
                    load() {}
                    loadAsync(t, e) {
                        const n = this;
                        return new Promise(function (i, r) {
                            n.load(t, i, e, r);
                        });
                    }
                    parse() {}
                    setCrossOrigin(t) {
                        return (this.crossOrigin = t), this;
                    }
                    setWithCredentials(t) {
                        return (this.withCredentials = t), this;
                    }
                    setPath(t) {
                        return (this.path = t), this;
                    }
                    setResourcePath(t) {
                        return (this.resourcePath = t), this;
                    }
                    setRequestHeader(t) {
                        return (this.requestHeader = t), this;
                    }
                }
                const Xa = {};
                class Qa extends Error {
                    constructor(t, e) {
                        super(t), (this.response = e);
                    }
                }
                class $a extends Za {
                    constructor(t) {
                        super(t);
                    }
                    load(t, e, n, i) {
                        void 0 === t && (t = ""),
                            void 0 !== this.path && (t = this.path + t),
                            (t = this.manager.resolveURL(t));
                        const r = Ya.get(t);
                        if (void 0 !== r)
                            return (
                                this.manager.itemStart(t),
                                setTimeout(() => {
                                    e && e(r), this.manager.itemEnd(t);
                                }, 0),
                                r
                            );
                        if (void 0 !== Xa[t])
                            return void Xa[t].push({
                                onLoad: e,
                                onProgress: n,
                                onError: i,
                            });
                        (Xa[t] = []),
                            Xa[t].push({
                                onLoad: e,
                                onProgress: n,
                                onError: i,
                            });
                        const a = new Request(t, {
                                headers: new Headers(this.requestHeader),
                                credentials: this.withCredentials
                                    ? "include"
                                    : "same-origin",
                            }),
                            s = this.mimeType,
                            o = this.responseType;
                        fetch(a)
                            .then((e) => {
                                if (200 === e.status || 0 === e.status) {
                                    if (
                                        (0 === e.status &&
                                            console.warn(
                                                "THREE.FileLoader: HTTP Status 0 received.",
                                            ),
                                        "undefined" == typeof ReadableStream ||
                                            void 0 === e.body ||
                                            void 0 === e.body.getReader)
                                    )
                                        return e;
                                    const n = Xa[t],
                                        i = e.body.getReader(),
                                        r =
                                            e.headers.get("Content-Length") ||
                                            e.headers.get("X-File-Size"),
                                        a = r ? parseInt(r) : 0,
                                        s = 0 !== a;
                                    let o = 0;
                                    const l = new ReadableStream({
                                        start(t) {
                                            !(function e() {
                                                i.read().then(
                                                    ({ done: i, value: r }) => {
                                                        if (i) t.close();
                                                        else {
                                                            o += r.byteLength;
                                                            const i =
                                                                new ProgressEvent(
                                                                    "progress",
                                                                    {
                                                                        lengthComputable:
                                                                            s,
                                                                        loaded: o,
                                                                        total: a,
                                                                    },
                                                                );
                                                            for (
                                                                let t = 0,
                                                                    e =
                                                                        n.length;
                                                                t < e;
                                                                t++
                                                            ) {
                                                                const e = n[t];
                                                                e.onProgress &&
                                                                    e.onProgress(
                                                                        i,
                                                                    );
                                                            }
                                                            t.enqueue(r), e();
                                                        }
                                                    },
                                                );
                                            })();
                                        },
                                    });
                                    return new Response(l);
                                }
                                throw new Qa(
                                    `fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`,
                                    e,
                                );
                            })
                            .then((t) => {
                                switch (o) {
                                    case "arraybuffer":
                                        return t.arrayBuffer();
                                    case "blob":
                                        return t.blob();
                                    case "document":
                                        return t
                                            .text()
                                            .then((t) =>
                                                new DOMParser().parseFromString(
                                                    t,
                                                    s,
                                                ),
                                            );
                                    case "json":
                                        return t.json();
                                    default:
                                        if (void 0 === s) return t.text();
                                        {
                                            const e =
                                                    /charset="?([^;"\s]*)"?/i.exec(
                                                        s,
                                                    ),
                                                n =
                                                    e && e[1]
                                                        ? e[1].toLowerCase()
                                                        : void 0,
                                                i = new TextDecoder(n);
                                            return t
                                                .arrayBuffer()
                                                .then((t) => i.decode(t));
                                        }
                                }
                            })
                            .then((e) => {
                                Ya.add(t, e);
                                const n = Xa[t];
                                delete Xa[t];
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    i.onLoad && i.onLoad(e);
                                }
                            })
                            .catch((e) => {
                                const n = Xa[t];
                                if (void 0 === n)
                                    throw (this.manager.itemError(t), e);
                                delete Xa[t];
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    i.onError && i.onError(e);
                                }
                                this.manager.itemError(t);
                            })
                            .finally(() => {
                                this.manager.itemEnd(t);
                            }),
                            this.manager.itemStart(t);
                    }
                    setResponseType(t) {
                        return (this.responseType = t), this;
                    }
                    setMimeType(t) {
                        return (this.mimeType = t), this;
                    }
                }
                class ts extends Za {
                    constructor(t) {
                        super(t);
                    }
                    load(t, e, n, i) {
                        void 0 !== this.path && (t = this.path + t),
                            (t = this.manager.resolveURL(t));
                        const r = this,
                            a = Ya.get(t);
                        if (void 0 !== a)
                            return (
                                r.manager.itemStart(t),
                                setTimeout(function () {
                                    e && e(a), r.manager.itemEnd(t);
                                }, 0),
                                a
                            );
                        const s = Q("img");
                        function o() {
                            c(),
                                Ya.add(t, this),
                                e && e(this),
                                r.manager.itemEnd(t);
                        }
                        function l(e) {
                            c(),
                                i && i(e),
                                r.manager.itemError(t),
                                r.manager.itemEnd(t);
                        }
                        function c() {
                            s.removeEventListener("load", o, !1),
                                s.removeEventListener("error", l, !1);
                        }
                        return (
                            s.addEventListener("load", o, !1),
                            s.addEventListener("error", l, !1),
                            "data:" !== t.slice(0, 5) &&
                                void 0 !== this.crossOrigin &&
                                (s.crossOrigin = this.crossOrigin),
                            r.manager.itemStart(t),
                            (s.src = t),
                            s
                        );
                    }
                }
                class es extends Za {
                    constructor(t) {
                        super(t);
                    }
                    load(t, e, n, i) {
                        const r = new mt(),
                            a = new ts(this.manager);
                        return (
                            a.setCrossOrigin(this.crossOrigin),
                            a.setPath(this.path),
                            a.load(
                                t,
                                function (t) {
                                    (r.image = t),
                                        (r.needsUpdate = !0),
                                        void 0 !== e && e(r);
                                },
                                n,
                                i,
                            ),
                            r
                        );
                    }
                }
                class ns extends Me {
                    constructor(t, e = 1) {
                        super(),
                            (this.isLight = !0),
                            (this.type = "Light"),
                            (this.color = new ct(t)),
                            (this.intensity = e);
                    }
                    dispose() {}
                    copy(t, e) {
                        return (
                            super.copy(t, e),
                            this.color.copy(t.color),
                            (this.intensity = t.intensity),
                            this
                        );
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return (
                            (e.object.color = this.color.getHex()),
                            (e.object.intensity = this.intensity),
                            void 0 !== this.groundColor &&
                                (e.object.groundColor =
                                    this.groundColor.getHex()),
                            void 0 !== this.distance &&
                                (e.object.distance = this.distance),
                            void 0 !== this.angle &&
                                (e.object.angle = this.angle),
                            void 0 !== this.decay &&
                                (e.object.decay = this.decay),
                            void 0 !== this.penumbra &&
                                (e.object.penumbra = this.penumbra),
                            void 0 !== this.shadow &&
                                (e.object.shadow = this.shadow.toJSON()),
                            e
                        );
                    }
                }
                const is = new Xt(),
                    rs = new St(),
                    as = new St();
                class ss {
                    constructor(t) {
                        (this.camera = t),
                            (this.bias = 0),
                            (this.normalBias = 0),
                            (this.radius = 1),
                            (this.blurSamples = 8),
                            (this.mapSize = new K(512, 512)),
                            (this.map = null),
                            (this.mapPass = null),
                            (this.matrix = new Xt()),
                            (this.autoUpdate = !0),
                            (this.needsUpdate = !1),
                            (this._frustum = new Ln()),
                            (this._frameExtents = new K(1, 1)),
                            (this._viewportCount = 1),
                            (this._viewports = [new gt(0, 0, 1, 1)]);
                    }
                    getViewportCount() {
                        return this._viewportCount;
                    }
                    getFrustum() {
                        return this._frustum;
                    }
                    updateMatrices(t) {
                        const e = this.camera,
                            n = this.matrix;
                        rs.setFromMatrixPosition(t.matrixWorld),
                            e.position.copy(rs),
                            as.setFromMatrixPosition(t.target.matrixWorld),
                            e.lookAt(as),
                            e.updateMatrixWorld(),
                            is.multiplyMatrices(
                                e.projectionMatrix,
                                e.matrixWorldInverse,
                            ),
                            this._frustum.setFromProjectionMatrix(is),
                            n.set(
                                0.5,
                                0,
                                0,
                                0.5,
                                0,
                                0.5,
                                0,
                                0.5,
                                0,
                                0,
                                0.5,
                                0.5,
                                0,
                                0,
                                0,
                                1,
                            ),
                            n.multiply(is);
                    }
                    getViewport(t) {
                        return this._viewports[t];
                    }
                    getFrameExtents() {
                        return this._frameExtents;
                    }
                    dispose() {
                        this.map && this.map.dispose(),
                            this.mapPass && this.mapPass.dispose();
                    }
                    copy(t) {
                        return (
                            (this.camera = t.camera.clone()),
                            (this.bias = t.bias),
                            (this.radius = t.radius),
                            this.mapSize.copy(t.mapSize),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    toJSON() {
                        const t = {};
                        return (
                            0 !== this.bias && (t.bias = this.bias),
                            0 !== this.normalBias &&
                                (t.normalBias = this.normalBias),
                            1 !== this.radius && (t.radius = this.radius),
                            (512 === this.mapSize.x &&
                                512 === this.mapSize.y) ||
                                (t.mapSize = this.mapSize.toArray()),
                            (t.camera = this.camera.toJSON(!1).object),
                            delete t.camera.matrix,
                            t
                        );
                    }
                }
                class os extends ss {
                    constructor() {
                        super(new Wn(-5, 5, 5, -5, 0.5, 500)),
                            (this.isDirectionalLightShadow = !0);
                    }
                }
                class ls {
                    static decodeText(t) {
                        if ("undefined" != typeof TextDecoder)
                            return new TextDecoder().decode(t);
                        let e = "";
                        for (let n = 0, i = t.length; n < i; n++)
                            e += String.fromCharCode(t[n]);
                        try {
                            return decodeURIComponent(escape(e));
                        } catch (t) {
                            return e;
                        }
                    }
                    static extractUrlBase(t) {
                        const e = t.lastIndexOf("/");
                        return -1 === e ? "./" : t.slice(0, e + 1);
                    }
                    static resolveURL(t, e) {
                        return "string" != typeof t || "" === t
                            ? ""
                            : (/^https?:\/\//i.test(e) &&
                                  /^\//.test(t) &&
                                  (e = e.replace(
                                      /(^https?:\/\/[^\/]+).*/i,
                                      "$1",
                                  )),
                              /^(https?:)?\/\//i.test(t) ||
                              /^data:.*,.*$/i.test(t) ||
                              /^blob:.*$/i.test(t)
                                  ? t
                                  : e + t);
                    }
                }
                function cs() {
                    return (
                        "undefined" == typeof performance ? Date : performance
                    ).now();
                }
                class hs {
                    constructor(t, e, n) {
                        let i, r, a;
                        switch (((this.binding = t), (this.valueSize = n), e)) {
                            case "quaternion":
                                (i = this._slerp),
                                    (r = this._slerpAdditive),
                                    (a = this._setAdditiveIdentityQuaternion),
                                    (this.buffer = new Float64Array(6 * n)),
                                    (this._workIndex = 5);
                                break;
                            case "string":
                            case "bool":
                                (i = this._select),
                                    (r = this._select),
                                    (a = this._setAdditiveIdentityOther),
                                    (this.buffer = new Array(5 * n));
                                break;
                            default:
                                (i = this._lerp),
                                    (r = this._lerpAdditive),
                                    (a = this._setAdditiveIdentityNumeric),
                                    (this.buffer = new Float64Array(5 * n));
                        }
                        (this._mixBufferRegion = i),
                            (this._mixBufferRegionAdditive = r),
                            (this._setIdentity = a),
                            (this._origIndex = 3),
                            (this._addIndex = 4),
                            (this.cumulativeWeight = 0),
                            (this.cumulativeWeightAdditive = 0),
                            (this.useCount = 0),
                            (this.referenceCount = 0);
                    }
                    accumulate(t, e) {
                        const n = this.buffer,
                            i = this.valueSize,
                            r = t * i + i;
                        let a = this.cumulativeWeight;
                        if (0 === a) {
                            for (let t = 0; t !== i; ++t) n[r + t] = n[t];
                            a = e;
                        } else {
                            a += e;
                            const t = e / a;
                            this._mixBufferRegion(n, r, 0, t, i);
                        }
                        this.cumulativeWeight = a;
                    }
                    accumulateAdditive(t) {
                        const e = this.buffer,
                            n = this.valueSize,
                            i = n * this._addIndex;
                        0 === this.cumulativeWeightAdditive &&
                            this._setIdentity(),
                            this._mixBufferRegionAdditive(e, i, 0, t, n),
                            (this.cumulativeWeightAdditive += t);
                    }
                    apply(t) {
                        const e = this.valueSize,
                            n = this.buffer,
                            i = t * e + e,
                            r = this.cumulativeWeight,
                            a = this.cumulativeWeightAdditive,
                            s = this.binding;
                        if (
                            ((this.cumulativeWeight = 0),
                            (this.cumulativeWeightAdditive = 0),
                            r < 1)
                        ) {
                            const t = e * this._origIndex;
                            this._mixBufferRegion(n, i, t, 1 - r, e);
                        }
                        a > 0 &&
                            this._mixBufferRegionAdditive(
                                n,
                                i,
                                this._addIndex * e,
                                1,
                                e,
                            );
                        for (let t = e, r = e + e; t !== r; ++t)
                            if (n[t] !== n[t + e]) {
                                s.setValue(n, i);
                                break;
                            }
                    }
                    saveOriginalState() {
                        const t = this.binding,
                            e = this.buffer,
                            n = this.valueSize,
                            i = n * this._origIndex;
                        t.getValue(e, i);
                        for (let t = n, r = i; t !== r; ++t)
                            e[t] = e[i + (t % n)];
                        this._setIdentity(),
                            (this.cumulativeWeight = 0),
                            (this.cumulativeWeightAdditive = 0);
                    }
                    restoreOriginalState() {
                        const t = 3 * this.valueSize;
                        this.binding.setValue(this.buffer, t);
                    }
                    _setAdditiveIdentityNumeric() {
                        const t = this._addIndex * this.valueSize,
                            e = t + this.valueSize;
                        for (let n = t; n < e; n++) this.buffer[n] = 0;
                    }
                    _setAdditiveIdentityQuaternion() {
                        this._setAdditiveIdentityNumeric(),
                            (this.buffer[
                                this._addIndex * this.valueSize + 3
                            ] = 1);
                    }
                    _setAdditiveIdentityOther() {
                        const t = this._origIndex * this.valueSize,
                            e = this._addIndex * this.valueSize;
                        for (let n = 0; n < this.valueSize; n++)
                            this.buffer[e + n] = this.buffer[t + n];
                    }
                    _select(t, e, n, i, r) {
                        if (i >= 0.5)
                            for (let i = 0; i !== r; ++i) t[e + i] = t[n + i];
                    }
                    _slerp(t, e, n, i) {
                        yt.slerpFlat(t, e, t, e, t, n, i);
                    }
                    _slerpAdditive(t, e, n, i, r) {
                        const a = this._workIndex * r;
                        yt.multiplyQuaternionsFlat(t, a, t, e, t, n),
                            yt.slerpFlat(t, e, t, e, t, a, i);
                    }
                    _lerp(t, e, n, i, r) {
                        const a = 1 - i;
                        for (let s = 0; s !== r; ++s) {
                            const r = e + s;
                            t[r] = t[r] * a + t[n + s] * i;
                        }
                    }
                    _lerpAdditive(t, e, n, i, r) {
                        for (let a = 0; a !== r; ++a) {
                            const r = e + a;
                            t[r] = t[r] + t[n + a] * i;
                        }
                    }
                }
                const us = "\\[\\]\\.:\\/",
                    ds = new RegExp("[" + us + "]", "g"),
                    ps = "[^" + us + "]",
                    fs = "[^" + us.replace("\\.", "") + "]",
                    ms = new RegExp(
                        "^" +
                            /((?:WC+[\/:])*)/.source.replace("WC", ps) +
                            /(WCOD+)?/.source.replace("WCOD", fs) +
                            /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace(
                                "WC",
                                ps,
                            ) +
                            /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", ps) +
                            "$",
                    ),
                    gs = ["material", "materials", "bones", "map"];
                class vs {
                    constructor(t, e, n) {
                        (this.path = e),
                            (this.parsedPath = n || vs.parseTrackName(e)),
                            (this.node =
                                vs.findNode(t, this.parsedPath.nodeName) || t),
                            (this.rootNode = t),
                            (this.getValue = this._getValue_unbound),
                            (this.setValue = this._setValue_unbound);
                    }
                    static create(t, e, n) {
                        return t && t.isAnimationObjectGroup
                            ? new vs.Composite(t, e, n)
                            : new vs(t, e, n);
                    }
                    static sanitizeNodeName(t) {
                        return t.replace(/\s/g, "_").replace(ds, "");
                    }
                    static parseTrackName(t) {
                        const e = ms.exec(t);
                        if (null === e)
                            throw new Error(
                                "PropertyBinding: Cannot parse trackName: " + t,
                            );
                        const n = {
                                nodeName: e[2],
                                objectName: e[3],
                                objectIndex: e[4],
                                propertyName: e[5],
                                propertyIndex: e[6],
                            },
                            i = n.nodeName && n.nodeName.lastIndexOf(".");
                        if (void 0 !== i && -1 !== i) {
                            const t = n.nodeName.substring(i + 1);
                            -1 !== gs.indexOf(t) &&
                                ((n.nodeName = n.nodeName.substring(0, i)),
                                (n.objectName = t));
                        }
                        if (
                            null === n.propertyName ||
                            0 === n.propertyName.length
                        )
                            throw new Error(
                                "PropertyBinding: can not parse propertyName from trackName: " +
                                    t,
                            );
                        return n;
                    }
                    static findNode(t, e) {
                        if (
                            void 0 === e ||
                            "" === e ||
                            "." === e ||
                            -1 === e ||
                            e === t.name ||
                            e === t.uuid
                        )
                            return t;
                        if (t.skeleton) {
                            const n = t.skeleton.getBoneByName(e);
                            if (void 0 !== n) return n;
                        }
                        if (t.children) {
                            const n = function (t) {
                                    for (let i = 0; i < t.length; i++) {
                                        const r = t[i];
                                        if (r.name === e || r.uuid === e)
                                            return r;
                                        const a = n(r.children);
                                        if (a) return a;
                                    }
                                    return null;
                                },
                                i = n(t.children);
                            if (i) return i;
                        }
                        return null;
                    }
                    _getValue_unavailable() {}
                    _setValue_unavailable() {}
                    _getValue_direct(t, e) {
                        t[e] = this.targetObject[this.propertyName];
                    }
                    _getValue_array(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i)
                            t[e++] = n[i];
                    }
                    _getValue_arrayElement(t, e) {
                        t[e] = this.resolvedProperty[this.propertyIndex];
                    }
                    _getValue_toArray(t, e) {
                        this.resolvedProperty.toArray(t, e);
                    }
                    _setValue_direct(t, e) {
                        this.targetObject[this.propertyName] = t[e];
                    }
                    _setValue_direct_setNeedsUpdate(t, e) {
                        (this.targetObject[this.propertyName] = t[e]),
                            (this.targetObject.needsUpdate = !0);
                    }
                    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                        (this.targetObject[this.propertyName] = t[e]),
                            (this.targetObject.matrixWorldNeedsUpdate = !0);
                    }
                    _setValue_array(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i)
                            n[i] = t[e++];
                    }
                    _setValue_array_setNeedsUpdate(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i)
                            n[i] = t[e++];
                        this.targetObject.needsUpdate = !0;
                    }
                    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i)
                            n[i] = t[e++];
                        this.targetObject.matrixWorldNeedsUpdate = !0;
                    }
                    _setValue_arrayElement(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e];
                    }
                    _setValue_arrayElement_setNeedsUpdate(t, e) {
                        (this.resolvedProperty[this.propertyIndex] = t[e]),
                            (this.targetObject.needsUpdate = !0);
                    }
                    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                        (this.resolvedProperty[this.propertyIndex] = t[e]),
                            (this.targetObject.matrixWorldNeedsUpdate = !0);
                    }
                    _setValue_fromArray(t, e) {
                        this.resolvedProperty.fromArray(t, e);
                    }
                    _setValue_fromArray_setNeedsUpdate(t, e) {
                        this.resolvedProperty.fromArray(t, e),
                            (this.targetObject.needsUpdate = !0);
                    }
                    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                        this.resolvedProperty.fromArray(t, e),
                            (this.targetObject.matrixWorldNeedsUpdate = !0);
                    }
                    _getValue_unbound(t, e) {
                        this.bind(), this.getValue(t, e);
                    }
                    _setValue_unbound(t, e) {
                        this.bind(), this.setValue(t, e);
                    }
                    bind() {
                        let t = this.node;
                        const e = this.parsedPath,
                            n = e.objectName,
                            i = e.propertyName;
                        let r = e.propertyIndex;
                        if (
                            (t ||
                                ((t =
                                    vs.findNode(this.rootNode, e.nodeName) ||
                                    this.rootNode),
                                (this.node = t)),
                            (this.getValue = this._getValue_unavailable),
                            (this.setValue = this._setValue_unavailable),
                            !t)
                        )
                            return void console.error(
                                "THREE.PropertyBinding: Trying to update node for track: " +
                                    this.path +
                                    " but it wasn't found.",
                            );
                        if (n) {
                            let i = e.objectIndex;
                            switch (n) {
                                case "materials":
                                    if (!t.material)
                                        return void console.error(
                                            "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                                            this,
                                        );
                                    if (!t.material.materials)
                                        return void console.error(
                                            "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                                            this,
                                        );
                                    t = t.material.materials;
                                    break;
                                case "bones":
                                    if (!t.skeleton)
                                        return void console.error(
                                            "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                                            this,
                                        );
                                    t = t.skeleton.bones;
                                    for (let e = 0; e < t.length; e++)
                                        if (t[e].name === i) {
                                            i = e;
                                            break;
                                        }
                                    break;
                                case "map":
                                    if ("map" in t) {
                                        t = t.map;
                                        break;
                                    }
                                    if (!t.material)
                                        return void console.error(
                                            "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                                            this,
                                        );
                                    if (!t.material.map)
                                        return void console.error(
                                            "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                                            this,
                                        );
                                    t = t.material.map;
                                    break;
                                default:
                                    if (void 0 === t[n])
                                        return void console.error(
                                            "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                                            this,
                                        );
                                    t = t[n];
                            }
                            if (void 0 !== i) {
                                if (void 0 === t[i])
                                    return void console.error(
                                        "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                                        this,
                                        t,
                                    );
                                t = t[i];
                            }
                        }
                        const a = t[i];
                        if (void 0 === a) {
                            const n = e.nodeName;
                            return void console.error(
                                "THREE.PropertyBinding: Trying to update property for track: " +
                                    n +
                                    "." +
                                    i +
                                    " but it wasn't found.",
                                t,
                            );
                        }
                        let s = this.Versioning.None;
                        (this.targetObject = t),
                            void 0 !== t.needsUpdate
                                ? (s = this.Versioning.NeedsUpdate)
                                : void 0 !== t.matrixWorldNeedsUpdate &&
                                  (s = this.Versioning.MatrixWorldNeedsUpdate);
                        let o = this.BindingType.Direct;
                        if (void 0 !== r) {
                            if ("morphTargetInfluences" === i) {
                                if (!t.geometry)
                                    return void console.error(
                                        "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                                        this,
                                    );
                                if (!t.geometry.morphAttributes)
                                    return void console.error(
                                        "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                                        this,
                                    );
                                void 0 !== t.morphTargetDictionary[r] &&
                                    (r = t.morphTargetDictionary[r]);
                            }
                            (o = this.BindingType.ArrayElement),
                                (this.resolvedProperty = a),
                                (this.propertyIndex = r);
                        } else
                            void 0 !== a.fromArray && void 0 !== a.toArray
                                ? ((o = this.BindingType.HasFromToArray),
                                  (this.resolvedProperty = a))
                                : Array.isArray(a)
                                ? ((o = this.BindingType.EntireArray),
                                  (this.resolvedProperty = a))
                                : (this.propertyName = i);
                        (this.getValue = this.GetterByBindingType[o]),
                            (this.setValue =
                                this.SetterByBindingTypeAndVersioning[o][s]);
                    }
                    unbind() {
                        (this.node = null),
                            (this.getValue = this._getValue_unbound),
                            (this.setValue = this._setValue_unbound);
                    }
                }
                (vs.Composite = class {
                    constructor(t, e, n) {
                        const i = n || vs.parseTrackName(e);
                        (this._targetGroup = t),
                            (this._bindings = t.subscribe_(e, i));
                    }
                    getValue(t, e) {
                        this.bind();
                        const n = this._targetGroup.nCachedObjects_,
                            i = this._bindings[n];
                        void 0 !== i && i.getValue(t, e);
                    }
                    setValue(t, e) {
                        const n = this._bindings;
                        for (
                            let i = this._targetGroup.nCachedObjects_,
                                r = n.length;
                            i !== r;
                            ++i
                        )
                            n[i].setValue(t, e);
                    }
                    bind() {
                        const t = this._bindings;
                        for (
                            let e = this._targetGroup.nCachedObjects_,
                                n = t.length;
                            e !== n;
                            ++e
                        )
                            t[e].bind();
                    }
                    unbind() {
                        const t = this._bindings;
                        for (
                            let e = this._targetGroup.nCachedObjects_,
                                n = t.length;
                            e !== n;
                            ++e
                        )
                            t[e].unbind();
                    }
                }),
                    (vs.prototype.BindingType = {
                        Direct: 0,
                        EntireArray: 1,
                        ArrayElement: 2,
                        HasFromToArray: 3,
                    }),
                    (vs.prototype.Versioning = {
                        None: 0,
                        NeedsUpdate: 1,
                        MatrixWorldNeedsUpdate: 2,
                    }),
                    (vs.prototype.GetterByBindingType = [
                        vs.prototype._getValue_direct,
                        vs.prototype._getValue_array,
                        vs.prototype._getValue_arrayElement,
                        vs.prototype._getValue_toArray,
                    ]),
                    (vs.prototype.SetterByBindingTypeAndVersioning = [
                        [
                            vs.prototype._setValue_direct,
                            vs.prototype._setValue_direct_setNeedsUpdate,
                            vs.prototype
                                ._setValue_direct_setMatrixWorldNeedsUpdate,
                        ],
                        [
                            vs.prototype._setValue_array,
                            vs.prototype._setValue_array_setNeedsUpdate,
                            vs.prototype
                                ._setValue_array_setMatrixWorldNeedsUpdate,
                        ],
                        [
                            vs.prototype._setValue_arrayElement,
                            vs.prototype._setValue_arrayElement_setNeedsUpdate,
                            vs.prototype
                                ._setValue_arrayElement_setMatrixWorldNeedsUpdate,
                        ],
                        [
                            vs.prototype._setValue_fromArray,
                            vs.prototype._setValue_fromArray_setNeedsUpdate,
                            vs.prototype
                                ._setValue_fromArray_setMatrixWorldNeedsUpdate,
                        ],
                    ]);
                class xs {
                    constructor(t, e, n = null, i = e.blendMode) {
                        (this._mixer = t),
                            (this._clip = e),
                            (this._localRoot = n),
                            (this.blendMode = i);
                        const r = e.tracks,
                            a = r.length,
                            s = new Array(a),
                            o = { endingStart: E, endingEnd: E };
                        for (let t = 0; t !== a; ++t) {
                            const e = r[t].createInterpolant(null);
                            (s[t] = e), (e.settings = o);
                        }
                        (this._interpolantSettings = o),
                            (this._interpolants = s),
                            (this._propertyBindings = new Array(a)),
                            (this._cacheIndex = null),
                            (this._byClipCacheIndex = null),
                            (this._timeScaleInterpolant = null),
                            (this._weightInterpolant = null),
                            (this.loop = 2201),
                            (this._loopCount = -1),
                            (this._startTime = null),
                            (this.time = 0),
                            (this.timeScale = 1),
                            (this._effectiveTimeScale = 1),
                            (this.weight = 1),
                            (this._effectiveWeight = 1),
                            (this.repetitions = 1 / 0),
                            (this.paused = !1),
                            (this.enabled = !0),
                            (this.clampWhenFinished = !1),
                            (this.zeroSlopeAtStart = !0),
                            (this.zeroSlopeAtEnd = !0);
                    }
                    play() {
                        return this._mixer._activateAction(this), this;
                    }
                    stop() {
                        return (
                            this._mixer._deactivateAction(this), this.reset()
                        );
                    }
                    reset() {
                        return (
                            (this.paused = !1),
                            (this.enabled = !0),
                            (this.time = 0),
                            (this._loopCount = -1),
                            (this._startTime = null),
                            this.stopFading().stopWarping()
                        );
                    }
                    isRunning() {
                        return (
                            this.enabled &&
                            !this.paused &&
                            0 !== this.timeScale &&
                            null === this._startTime &&
                            this._mixer._isActiveAction(this)
                        );
                    }
                    isScheduled() {
                        return this._mixer._isActiveAction(this);
                    }
                    startAt(t) {
                        return (this._startTime = t), this;
                    }
                    setLoop(t, e) {
                        return (this.loop = t), (this.repetitions = e), this;
                    }
                    setEffectiveWeight(t) {
                        return (
                            (this.weight = t),
                            (this._effectiveWeight = this.enabled ? t : 0),
                            this.stopFading()
                        );
                    }
                    getEffectiveWeight() {
                        return this._effectiveWeight;
                    }
                    fadeIn(t) {
                        return this._scheduleFading(t, 0, 1);
                    }
                    fadeOut(t) {
                        return this._scheduleFading(t, 1, 0);
                    }
                    crossFadeFrom(t, e, n) {
                        if ((t.fadeOut(e), this.fadeIn(e), n)) {
                            const n = this._clip.duration,
                                i = t._clip.duration,
                                r = i / n,
                                a = n / i;
                            t.warp(1, r, e), this.warp(a, 1, e);
                        }
                        return this;
                    }
                    crossFadeTo(t, e, n) {
                        return t.crossFadeFrom(this, e, n);
                    }
                    stopFading() {
                        const t = this._weightInterpolant;
                        return (
                            null !== t &&
                                ((this._weightInterpolant = null),
                                this._mixer._takeBackControlInterpolant(t)),
                            this
                        );
                    }
                    setEffectiveTimeScale(t) {
                        return (
                            (this.timeScale = t),
                            (this._effectiveTimeScale = this.paused ? 0 : t),
                            this.stopWarping()
                        );
                    }
                    getEffectiveTimeScale() {
                        return this._effectiveTimeScale;
                    }
                    setDuration(t) {
                        return (
                            (this.timeScale = this._clip.duration / t),
                            this.stopWarping()
                        );
                    }
                    syncWith(t) {
                        return (
                            (this.time = t.time),
                            (this.timeScale = t.timeScale),
                            this.stopWarping()
                        );
                    }
                    halt(t) {
                        return this.warp(this._effectiveTimeScale, 0, t);
                    }
                    warp(t, e, n) {
                        const i = this._mixer,
                            r = i.time,
                            a = this.timeScale;
                        let s = this._timeScaleInterpolant;
                        null === s &&
                            ((s = i._lendControlInterpolant()),
                            (this._timeScaleInterpolant = s));
                        const o = s.parameterPositions,
                            l = s.sampleValues;
                        return (
                            (o[0] = r),
                            (o[1] = r + n),
                            (l[0] = t / a),
                            (l[1] = e / a),
                            this
                        );
                    }
                    stopWarping() {
                        const t = this._timeScaleInterpolant;
                        return (
                            null !== t &&
                                ((this._timeScaleInterpolant = null),
                                this._mixer._takeBackControlInterpolant(t)),
                            this
                        );
                    }
                    getMixer() {
                        return this._mixer;
                    }
                    getClip() {
                        return this._clip;
                    }
                    getRoot() {
                        return this._localRoot || this._mixer._root;
                    }
                    _update(t, e, n, i) {
                        if (!this.enabled) return void this._updateWeight(t);
                        const r = this._startTime;
                        if (null !== r) {
                            const i = (t - r) * n;
                            i < 0 || 0 === n
                                ? (e = 0)
                                : ((this._startTime = null), (e = n * i));
                        }
                        e *= this._updateTimeScale(t);
                        const a = this._updateTime(e),
                            s = this._updateWeight(t);
                        if (s > 0) {
                            const t = this._interpolants,
                                e = this._propertyBindings;
                            if (2501 === this.blendMode)
                                for (let n = 0, i = t.length; n !== i; ++n)
                                    t[n].evaluate(a),
                                        e[n].accumulateAdditive(s);
                            else
                                for (let n = 0, r = t.length; n !== r; ++n)
                                    t[n].evaluate(a), e[n].accumulate(i, s);
                        }
                    }
                    _updateWeight(t) {
                        let e = 0;
                        if (this.enabled) {
                            e = this.weight;
                            const n = this._weightInterpolant;
                            if (null !== n) {
                                const i = n.evaluate(t)[0];
                                (e *= i),
                                    t > n.parameterPositions[1] &&
                                        (this.stopFading(),
                                        0 === i && (this.enabled = !1));
                            }
                        }
                        return (this._effectiveWeight = e), e;
                    }
                    _updateTimeScale(t) {
                        let e = 0;
                        if (!this.paused) {
                            e = this.timeScale;
                            const n = this._timeScaleInterpolant;
                            null !== n &&
                                ((e *= n.evaluate(t)[0]),
                                t > n.parameterPositions[1] &&
                                    (this.stopWarping(),
                                    0 === e
                                        ? (this.paused = !0)
                                        : (this.timeScale = e)));
                        }
                        return (this._effectiveTimeScale = e), e;
                    }
                    _updateTime(t) {
                        const e = this._clip.duration,
                            n = this.loop;
                        let i = this.time + t,
                            r = this._loopCount;
                        const a = 2202 === n;
                        if (0 === t)
                            return -1 === r ? i : a && 1 == (1 & r) ? e - i : i;
                        if (2200 === n) {
                            -1 === r &&
                                ((this._loopCount = 0),
                                this._setEndings(!0, !0, !1));
                            t: {
                                if (i >= e) i = e;
                                else {
                                    if (!(i < 0)) {
                                        this.time = i;
                                        break t;
                                    }
                                    i = 0;
                                }
                                this.clampWhenFinished
                                    ? (this.paused = !0)
                                    : (this.enabled = !1),
                                    (this.time = i),
                                    this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: t < 0 ? -1 : 1,
                                    });
                            }
                        } else {
                            if (
                                (-1 === r &&
                                    (t >= 0
                                        ? ((r = 0),
                                          this._setEndings(
                                              !0,
                                              0 === this.repetitions,
                                              a,
                                          ))
                                        : this._setEndings(
                                              0 === this.repetitions,
                                              !0,
                                              a,
                                          )),
                                i >= e || i < 0)
                            ) {
                                const n = Math.floor(i / e);
                                (i -= e * n), (r += Math.abs(n));
                                const s = this.repetitions - r;
                                if (s <= 0)
                                    this.clampWhenFinished
                                        ? (this.paused = !0)
                                        : (this.enabled = !1),
                                        (i = t > 0 ? e : 0),
                                        (this.time = i),
                                        this._mixer.dispatchEvent({
                                            type: "finished",
                                            action: this,
                                            direction: t > 0 ? 1 : -1,
                                        });
                                else {
                                    if (1 === s) {
                                        const e = t < 0;
                                        this._setEndings(e, !e, a);
                                    } else this._setEndings(!1, !1, a);
                                    (this._loopCount = r),
                                        (this.time = i),
                                        this._mixer.dispatchEvent({
                                            type: "loop",
                                            action: this,
                                            loopDelta: n,
                                        });
                                }
                            } else this.time = i;
                            if (a && 1 == (1 & r)) return e - i;
                        }
                        return i;
                    }
                    _setEndings(t, e, n) {
                        const i = this._interpolantSettings;
                        n
                            ? ((i.endingStart = R), (i.endingEnd = R))
                            : ((i.endingStart = t
                                  ? this.zeroSlopeAtStart
                                      ? R
                                      : E
                                  : k),
                              (i.endingEnd = e
                                  ? this.zeroSlopeAtEnd
                                      ? R
                                      : E
                                  : k));
                    }
                    _scheduleFading(t, e, n) {
                        const i = this._mixer,
                            r = i.time;
                        let a = this._weightInterpolant;
                        null === a &&
                            ((a = i._lendControlInterpolant()),
                            (this._weightInterpolant = a));
                        const s = a.parameterPositions,
                            o = a.sampleValues;
                        return (
                            (s[0] = r),
                            (o[0] = e),
                            (s[1] = r + t),
                            (o[1] = n),
                            this
                        );
                    }
                }
                const bs = new Float32Array(1);
                class ys extends V {
                    constructor(t) {
                        super(),
                            (this._root = t),
                            this._initMemoryManager(),
                            (this._accuIndex = 0),
                            (this.time = 0),
                            (this.timeScale = 1);
                    }
                    _bindAction(t, e) {
                        const n = t._localRoot || this._root,
                            i = t._clip.tracks,
                            r = i.length,
                            a = t._propertyBindings,
                            s = t._interpolants,
                            o = n.uuid,
                            l = this._bindingsByRootAndName;
                        let c = l[o];
                        void 0 === c && ((c = {}), (l[o] = c));
                        for (let t = 0; t !== r; ++t) {
                            const r = i[t],
                                l = r.name;
                            let h = c[l];
                            if (void 0 !== h) ++h.referenceCount, (a[t] = h);
                            else {
                                if (((h = a[t]), void 0 !== h)) {
                                    null === h._cacheIndex &&
                                        (++h.referenceCount,
                                        this._addInactiveBinding(h, o, l));
                                    continue;
                                }
                                const i =
                                    e &&
                                    e._propertyBindings[t].binding.parsedPath;
                                (h = new hs(
                                    vs.create(n, l, i),
                                    r.ValueTypeName,
                                    r.getValueSize(),
                                )),
                                    ++h.referenceCount,
                                    this._addInactiveBinding(h, o, l),
                                    (a[t] = h);
                            }
                            s[t].resultBuffer = h.buffer;
                        }
                    }
                    _activateAction(t) {
                        if (!this._isActiveAction(t)) {
                            if (null === t._cacheIndex) {
                                const e = (t._localRoot || this._root).uuid,
                                    n = t._clip.uuid,
                                    i = this._actionsByClip[n];
                                this._bindAction(t, i && i.knownActions[0]),
                                    this._addInactiveAction(t, n, e);
                            }
                            const e = t._propertyBindings;
                            for (let t = 0, n = e.length; t !== n; ++t) {
                                const n = e[t];
                                0 == n.useCount++ &&
                                    (this._lendBinding(n),
                                    n.saveOriginalState());
                            }
                            this._lendAction(t);
                        }
                    }
                    _deactivateAction(t) {
                        if (this._isActiveAction(t)) {
                            const e = t._propertyBindings;
                            for (let t = 0, n = e.length; t !== n; ++t) {
                                const n = e[t];
                                0 == --n.useCount &&
                                    (n.restoreOriginalState(),
                                    this._takeBackBinding(n));
                            }
                            this._takeBackAction(t);
                        }
                    }
                    _initMemoryManager() {
                        (this._actions = []),
                            (this._nActiveActions = 0),
                            (this._actionsByClip = {}),
                            (this._bindings = []),
                            (this._nActiveBindings = 0),
                            (this._bindingsByRootAndName = {}),
                            (this._controlInterpolants = []),
                            (this._nActiveControlInterpolants = 0);
                        const t = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return t._actions.length;
                                },
                                get inUse() {
                                    return t._nActiveActions;
                                },
                            },
                            bindings: {
                                get total() {
                                    return t._bindings.length;
                                },
                                get inUse() {
                                    return t._nActiveBindings;
                                },
                            },
                            controlInterpolants: {
                                get total() {
                                    return t._controlInterpolants.length;
                                },
                                get inUse() {
                                    return t._nActiveControlInterpolants;
                                },
                            },
                        };
                    }
                    _isActiveAction(t) {
                        const e = t._cacheIndex;
                        return null !== e && e < this._nActiveActions;
                    }
                    _addInactiveAction(t, e, n) {
                        const i = this._actions,
                            r = this._actionsByClip;
                        let a = r[e];
                        if (void 0 === a)
                            (a = { knownActions: [t], actionByRoot: {} }),
                                (t._byClipCacheIndex = 0),
                                (r[e] = a);
                        else {
                            const e = a.knownActions;
                            (t._byClipCacheIndex = e.length), e.push(t);
                        }
                        (t._cacheIndex = i.length),
                            i.push(t),
                            (a.actionByRoot[n] = t);
                    }
                    _removeInactiveAction(t) {
                        const e = this._actions,
                            n = e[e.length - 1],
                            i = t._cacheIndex;
                        (n._cacheIndex = i),
                            (e[i] = n),
                            e.pop(),
                            (t._cacheIndex = null);
                        const r = t._clip.uuid,
                            a = this._actionsByClip,
                            s = a[r],
                            o = s.knownActions,
                            l = o[o.length - 1],
                            c = t._byClipCacheIndex;
                        (l._byClipCacheIndex = c),
                            (o[c] = l),
                            o.pop(),
                            (t._byClipCacheIndex = null),
                            delete s.actionByRoot[
                                (t._localRoot || this._root).uuid
                            ],
                            0 === o.length && delete a[r],
                            this._removeInactiveBindingsForAction(t);
                    }
                    _removeInactiveBindingsForAction(t) {
                        const e = t._propertyBindings;
                        for (let t = 0, n = e.length; t !== n; ++t) {
                            const n = e[t];
                            0 == --n.referenceCount &&
                                this._removeInactiveBinding(n);
                        }
                    }
                    _lendAction(t) {
                        const e = this._actions,
                            n = t._cacheIndex,
                            i = this._nActiveActions++,
                            r = e[i];
                        (t._cacheIndex = i),
                            (e[i] = t),
                            (r._cacheIndex = n),
                            (e[n] = r);
                    }
                    _takeBackAction(t) {
                        const e = this._actions,
                            n = t._cacheIndex,
                            i = --this._nActiveActions,
                            r = e[i];
                        (t._cacheIndex = i),
                            (e[i] = t),
                            (r._cacheIndex = n),
                            (e[n] = r);
                    }
                    _addInactiveBinding(t, e, n) {
                        const i = this._bindingsByRootAndName,
                            r = this._bindings;
                        let a = i[e];
                        void 0 === a && ((a = {}), (i[e] = a)),
                            (a[n] = t),
                            (t._cacheIndex = r.length),
                            r.push(t);
                    }
                    _removeInactiveBinding(t) {
                        const e = this._bindings,
                            n = t.binding,
                            i = n.rootNode.uuid,
                            r = n.path,
                            a = this._bindingsByRootAndName,
                            s = a[i],
                            o = e[e.length - 1],
                            l = t._cacheIndex;
                        (o._cacheIndex = l),
                            (e[l] = o),
                            e.pop(),
                            delete s[r],
                            0 === Object.keys(s).length && delete a[i];
                    }
                    _lendBinding(t) {
                        const e = this._bindings,
                            n = t._cacheIndex,
                            i = this._nActiveBindings++,
                            r = e[i];
                        (t._cacheIndex = i),
                            (e[i] = t),
                            (r._cacheIndex = n),
                            (e[n] = r);
                    }
                    _takeBackBinding(t) {
                        const e = this._bindings,
                            n = t._cacheIndex,
                            i = --this._nActiveBindings,
                            r = e[i];
                        (t._cacheIndex = i),
                            (e[i] = t),
                            (r._cacheIndex = n),
                            (e[n] = r);
                    }
                    _lendControlInterpolant() {
                        const t = this._controlInterpolants,
                            e = this._nActiveControlInterpolants++;
                        let n = t[e];
                        return (
                            void 0 === n &&
                                ((n = new Pa(
                                    new Float32Array(2),
                                    new Float32Array(2),
                                    1,
                                    bs,
                                )),
                                (n.__cacheIndex = e),
                                (t[e] = n)),
                            n
                        );
                    }
                    _takeBackControlInterpolant(t) {
                        const e = this._controlInterpolants,
                            n = t.__cacheIndex,
                            i = --this._nActiveControlInterpolants,
                            r = e[i];
                        (t.__cacheIndex = i),
                            (e[i] = t),
                            (r.__cacheIndex = n),
                            (e[n] = r);
                    }
                    clipAction(t, e, n) {
                        const i = e || this._root,
                            r = i.uuid;
                        let a = "string" == typeof t ? Wa.findByName(i, t) : t;
                        const s = null !== a ? a.uuid : t,
                            o = this._actionsByClip[s];
                        let l = null;
                        if (
                            (void 0 === n &&
                                (n = null !== a ? a.blendMode : 2500),
                            void 0 !== o)
                        ) {
                            const t = o.actionByRoot[r];
                            if (void 0 !== t && t.blendMode === n) return t;
                            (l = o.knownActions[0]),
                                null === a && (a = l._clip);
                        }
                        if (null === a) return null;
                        const c = new xs(this, a, e, n);
                        return (
                            this._bindAction(c, l),
                            this._addInactiveAction(c, s, r),
                            c
                        );
                    }
                    existingAction(t, e) {
                        const n = e || this._root,
                            i = n.uuid,
                            r = "string" == typeof t ? Wa.findByName(n, t) : t,
                            a = r ? r.uuid : t,
                            s = this._actionsByClip[a];
                        return (void 0 !== s && s.actionByRoot[i]) || null;
                    }
                    stopAllAction() {
                        const t = this._actions;
                        for (let e = this._nActiveActions - 1; e >= 0; --e)
                            t[e].stop();
                        return this;
                    }
                    update(t) {
                        t *= this.timeScale;
                        const e = this._actions,
                            n = this._nActiveActions,
                            i = (this.time += t),
                            r = Math.sign(t),
                            a = (this._accuIndex ^= 1);
                        for (let s = 0; s !== n; ++s) e[s]._update(i, t, r, a);
                        const s = this._bindings,
                            o = this._nActiveBindings;
                        for (let t = 0; t !== o; ++t) s[t].apply(a);
                        return this;
                    }
                    setTime(t) {
                        this.time = 0;
                        for (let t = 0; t < this._actions.length; t++)
                            this._actions[t].time = 0;
                        return this.update(t);
                    }
                    getRoot() {
                        return this._root;
                    }
                    uncacheClip(t) {
                        const e = this._actions,
                            n = t.uuid,
                            i = this._actionsByClip,
                            r = i[n];
                        if (void 0 !== r) {
                            const t = r.knownActions;
                            for (let n = 0, i = t.length; n !== i; ++n) {
                                const i = t[n];
                                this._deactivateAction(i);
                                const r = i._cacheIndex,
                                    a = e[e.length - 1];
                                (i._cacheIndex = null),
                                    (i._byClipCacheIndex = null),
                                    (a._cacheIndex = r),
                                    (e[r] = a),
                                    e.pop(),
                                    this._removeInactiveBindingsForAction(i);
                            }
                            delete i[n];
                        }
                    }
                    uncacheRoot(t) {
                        const e = t.uuid,
                            n = this._actionsByClip;
                        for (const t in n) {
                            const i = n[t].actionByRoot[e];
                            void 0 !== i &&
                                (this._deactivateAction(i),
                                this._removeInactiveAction(i));
                        }
                        const i = this._bindingsByRootAndName[e];
                        if (void 0 !== i)
                            for (const t in i) {
                                const e = i[t];
                                e.restoreOriginalState(),
                                    this._removeInactiveBinding(e);
                            }
                    }
                    uncacheAction(t, e) {
                        const n = this.existingAction(t, e);
                        null !== n &&
                            (this._deactivateAction(n),
                            this._removeInactiveAction(n));
                    }
                }
                class Ss {
                    constructor(t = 1, e = 0, n = 0) {
                        return (
                            (this.radius = t),
                            (this.phi = e),
                            (this.theta = n),
                            this
                        );
                    }
                    set(t, e, n) {
                        return (
                            (this.radius = t),
                            (this.phi = e),
                            (this.theta = n),
                            this
                        );
                    }
                    copy(t) {
                        return (
                            (this.radius = t.radius),
                            (this.phi = t.phi),
                            (this.theta = t.theta),
                            this
                        );
                    }
                    makeSafe() {
                        const t = 1e-6;
                        return (
                            (this.phi = Math.max(
                                t,
                                Math.min(Math.PI - t, this.phi),
                            )),
                            this
                        );
                    }
                    setFromVector3(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z);
                    }
                    setFromCartesianCoords(t, e, n) {
                        return (
                            (this.radius = Math.sqrt(t * t + e * e + n * n)),
                            0 === this.radius
                                ? ((this.theta = 0), (this.phi = 0))
                                : ((this.theta = Math.atan2(t, n)),
                                  (this.phi = Math.acos(
                                      F(e / this.radius, -1, 1),
                                  ))),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                "undefined" != typeof __THREE_DEVTOOLS__ &&
                    __THREE_DEVTOOLS__.dispatchEvent(
                        new CustomEvent("register", {
                            detail: { revision: t },
                        }),
                    ),
                    "undefined" != typeof window &&
                        (window.__THREE__
                            ? console.warn(
                                  "WARNING: Multiple instances of Three.js being imported.",
                              )
                            : (window.__THREE__ = t));
                const Ms = { type: "change" },
                    As = { type: "start" },
                    _s = { type: "end" };
                function ws(t, e) {
                    var n = t.__state.conversionName.toString(),
                        i = Math.round(t.r),
                        r = Math.round(t.g),
                        a = Math.round(t.b),
                        s = t.a,
                        o = Math.round(t.h),
                        l = t.s.toFixed(1),
                        c = t.v.toFixed(1);
                    if (e || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) {
                        for (var h = t.hex.toString(16); h.length < 6; )
                            h = "0" + h;
                        return "#" + h;
                    }
                    return "CSS_RGB" === n
                        ? "rgb(" + i + "," + r + "," + a + ")"
                        : "CSS_RGBA" === n
                        ? "rgba(" + i + "," + r + "," + a + "," + s + ")"
                        : "HEX" === n
                        ? "0x" + t.hex.toString(16)
                        : "RGB_ARRAY" === n
                        ? "[" + i + "," + r + "," + a + "]"
                        : "RGBA_ARRAY" === n
                        ? "[" + i + "," + r + "," + a + "," + s + "]"
                        : "RGB_OBJ" === n
                        ? "{r:" + i + ",g:" + r + ",b:" + a + "}"
                        : "RGBA_OBJ" === n
                        ? "{r:" + i + ",g:" + r + ",b:" + a + ",a:" + s + "}"
                        : "HSV_OBJ" === n
                        ? "{h:" + o + ",s:" + l + ",v:" + c + "}"
                        : "HSVA_OBJ" === n
                        ? "{h:" + o + ",s:" + l + ",v:" + c + ",a:" + s + "}"
                        : "unknown format";
                }
                var Ts = Array.prototype.forEach,
                    Es = Array.prototype.slice,
                    Rs = {
                        BREAK: {},
                        extend: function (t) {
                            return (
                                this.each(
                                    Es.call(arguments, 1),
                                    function (e) {
                                        (this.isObject(e)
                                            ? Object.keys(e)
                                            : []
                                        ).forEach(
                                            function (n) {
                                                this.isUndefined(e[n]) ||
                                                    (t[n] = e[n]);
                                            }.bind(this),
                                        );
                                    },
                                    this,
                                ),
                                t
                            );
                        },
                        defaults: function (t) {
                            return (
                                this.each(
                                    Es.call(arguments, 1),
                                    function (e) {
                                        (this.isObject(e)
                                            ? Object.keys(e)
                                            : []
                                        ).forEach(
                                            function (n) {
                                                this.isUndefined(t[n]) &&
                                                    (t[n] = e[n]);
                                            }.bind(this),
                                        );
                                    },
                                    this,
                                ),
                                t
                            );
                        },
                        compose: function () {
                            var t = Es.call(arguments);
                            return function () {
                                for (
                                    var e = Es.call(arguments),
                                        n = t.length - 1;
                                    n >= 0;
                                    n--
                                )
                                    e = [t[n].apply(this, e)];
                                return e[0];
                            };
                        },
                        each: function (t, e, n) {
                            if (t)
                                if (Ts && t.forEach && t.forEach === Ts)
                                    t.forEach(e, n);
                                else if (t.length === t.length + 0) {
                                    var i,
                                        r = void 0;
                                    for (r = 0, i = t.length; r < i; r++)
                                        if (
                                            r in t &&
                                            e.call(n, t[r], r) === this.BREAK
                                        )
                                            return;
                                } else
                                    for (var a in t)
                                        if (e.call(n, t[a], a) === this.BREAK)
                                            return;
                        },
                        defer: function (t) {
                            setTimeout(t, 0);
                        },
                        debounce: function (t, e, n) {
                            var i = void 0;
                            return function () {
                                var r = this,
                                    a = arguments;
                                function s() {
                                    (i = null), n || t.apply(r, a);
                                }
                                var o = n || !i;
                                clearTimeout(i),
                                    (i = setTimeout(s, e)),
                                    o && t.apply(r, a);
                            };
                        },
                        toArray: function (t) {
                            return t.toArray ? t.toArray() : Es.call(t);
                        },
                        isUndefined: function (t) {
                            return void 0 === t;
                        },
                        isNull: function (t) {
                            return null === t;
                        },
                        isNaN: (function (t) {
                            function e(e) {
                                return t.apply(this, arguments);
                            }
                            return (
                                (e.toString = function () {
                                    return t.toString();
                                }),
                                e
                            );
                        })(function (t) {
                            return isNaN(t);
                        }),
                        isArray:
                            Array.isArray ||
                            function (t) {
                                return t.constructor === Array;
                            },
                        isObject: function (t) {
                            return t === Object(t);
                        },
                        isNumber: function (t) {
                            return t === t + 0;
                        },
                        isString: function (t) {
                            return t === t + "";
                        },
                        isBoolean: function (t) {
                            return !1 === t || !0 === t;
                        },
                        isFunction: function (t) {
                            return t instanceof Function;
                        },
                    },
                    ks = [
                        {
                            litmus: Rs.isString,
                            conversions: {
                                THREE_CHAR_HEX: {
                                    read: function (t) {
                                        var e = t.match(
                                            /^#([A-F0-9])([A-F0-9])([A-F0-9])$/i,
                                        );
                                        return (
                                            null !== e && {
                                                space: "HEX",
                                                hex: parseInt(
                                                    "0x" +
                                                        e[1].toString() +
                                                        e[1].toString() +
                                                        e[2].toString() +
                                                        e[2].toString() +
                                                        e[3].toString() +
                                                        e[3].toString(),
                                                    0,
                                                ),
                                            }
                                        );
                                    },
                                    write: ws,
                                },
                                SIX_CHAR_HEX: {
                                    read: function (t) {
                                        var e = t.match(/^#([A-F0-9]{6})$/i);
                                        return (
                                            null !== e && {
                                                space: "HEX",
                                                hex: parseInt(
                                                    "0x" + e[1].toString(),
                                                    0,
                                                ),
                                            }
                                        );
                                    },
                                    write: ws,
                                },
                                CSS_RGB: {
                                    read: function (t) {
                                        var e = t.match(
                                            /^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/,
                                        );
                                        return (
                                            null !== e && {
                                                space: "RGB",
                                                r: parseFloat(e[1]),
                                                g: parseFloat(e[2]),
                                                b: parseFloat(e[3]),
                                            }
                                        );
                                    },
                                    write: ws,
                                },
                                CSS_RGBA: {
                                    read: function (t) {
                                        var e = t.match(
                                            /^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/,
                                        );
                                        return (
                                            null !== e && {
                                                space: "RGB",
                                                r: parseFloat(e[1]),
                                                g: parseFloat(e[2]),
                                                b: parseFloat(e[3]),
                                                a: parseFloat(e[4]),
                                            }
                                        );
                                    },
                                    write: ws,
                                },
                            },
                        },
                        {
                            litmus: Rs.isNumber,
                            conversions: {
                                HEX: {
                                    read: function (t) {
                                        return {
                                            space: "HEX",
                                            hex: t,
                                            conversionName: "HEX",
                                        };
                                    },
                                    write: function (t) {
                                        return t.hex;
                                    },
                                },
                            },
                        },
                        {
                            litmus: Rs.isArray,
                            conversions: {
                                RGB_ARRAY: {
                                    read: function (t) {
                                        return (
                                            3 === t.length && {
                                                space: "RGB",
                                                r: t[0],
                                                g: t[1],
                                                b: t[2],
                                            }
                                        );
                                    },
                                    write: function (t) {
                                        return [t.r, t.g, t.b];
                                    },
                                },
                                RGBA_ARRAY: {
                                    read: function (t) {
                                        return (
                                            4 === t.length && {
                                                space: "RGB",
                                                r: t[0],
                                                g: t[1],
                                                b: t[2],
                                                a: t[3],
                                            }
                                        );
                                    },
                                    write: function (t) {
                                        return [t.r, t.g, t.b, t.a];
                                    },
                                },
                            },
                        },
                        {
                            litmus: Rs.isObject,
                            conversions: {
                                RGBA_OBJ: {
                                    read: function (t) {
                                        return (
                                            !!(
                                                Rs.isNumber(t.r) &&
                                                Rs.isNumber(t.g) &&
                                                Rs.isNumber(t.b) &&
                                                Rs.isNumber(t.a)
                                            ) && {
                                                space: "RGB",
                                                r: t.r,
                                                g: t.g,
                                                b: t.b,
                                                a: t.a,
                                            }
                                        );
                                    },
                                    write: function (t) {
                                        return {
                                            r: t.r,
                                            g: t.g,
                                            b: t.b,
                                            a: t.a,
                                        };
                                    },
                                },
                                RGB_OBJ: {
                                    read: function (t) {
                                        return (
                                            !!(
                                                Rs.isNumber(t.r) &&
                                                Rs.isNumber(t.g) &&
                                                Rs.isNumber(t.b)
                                            ) && {
                                                space: "RGB",
                                                r: t.r,
                                                g: t.g,
                                                b: t.b,
                                            }
                                        );
                                    },
                                    write: function (t) {
                                        return { r: t.r, g: t.g, b: t.b };
                                    },
                                },
                                HSVA_OBJ: {
                                    read: function (t) {
                                        return (
                                            !!(
                                                Rs.isNumber(t.h) &&
                                                Rs.isNumber(t.s) &&
                                                Rs.isNumber(t.v) &&
                                                Rs.isNumber(t.a)
                                            ) && {
                                                space: "HSV",
                                                h: t.h,
                                                s: t.s,
                                                v: t.v,
                                                a: t.a,
                                            }
                                        );
                                    },
                                    write: function (t) {
                                        return {
                                            h: t.h,
                                            s: t.s,
                                            v: t.v,
                                            a: t.a,
                                        };
                                    },
                                },
                                HSV_OBJ: {
                                    read: function (t) {
                                        return (
                                            !!(
                                                Rs.isNumber(t.h) &&
                                                Rs.isNumber(t.s) &&
                                                Rs.isNumber(t.v)
                                            ) && {
                                                space: "HSV",
                                                h: t.h,
                                                s: t.s,
                                                v: t.v,
                                            }
                                        );
                                    },
                                    write: function (t) {
                                        return { h: t.h, s: t.s, v: t.v };
                                    },
                                },
                            },
                        },
                    ],
                    Cs = void 0,
                    Ls = void 0,
                    Is = function () {
                        Ls = !1;
                        var t =
                            arguments.length > 1
                                ? Rs.toArray(arguments)
                                : arguments[0];
                        return (
                            Rs.each(ks, function (e) {
                                if (e.litmus(t))
                                    return (
                                        Rs.each(e.conversions, function (e, n) {
                                            if (
                                                ((Cs = e.read(t)),
                                                !1 === Ls && !1 !== Cs)
                                            )
                                                return (
                                                    (Ls = Cs),
                                                    (Cs.conversionName = n),
                                                    (Cs.conversion = e),
                                                    Rs.BREAK
                                                );
                                        }),
                                        Rs.BREAK
                                    );
                            }),
                            Ls
                        );
                    },
                    Os = void 0,
                    Ds = {
                        hsv_to_rgb: function (t, e, n) {
                            var i = Math.floor(t / 60) % 6,
                                r = t / 60 - Math.floor(t / 60),
                                a = n * (1 - e),
                                s = n * (1 - r * e),
                                o = n * (1 - (1 - r) * e),
                                l = [
                                    [n, o, a],
                                    [s, n, a],
                                    [a, n, o],
                                    [a, s, n],
                                    [o, a, n],
                                    [n, a, s],
                                ][i];
                            return {
                                r: 255 * l[0],
                                g: 255 * l[1],
                                b: 255 * l[2],
                            };
                        },
                        rgb_to_hsv: function (t, e, n) {
                            var i = Math.min(t, e, n),
                                r = Math.max(t, e, n),
                                a = r - i,
                                s = void 0;
                            return 0 === r
                                ? { h: NaN, s: 0, v: 0 }
                                : ((s =
                                      t === r
                                          ? (e - n) / a
                                          : e === r
                                          ? 2 + (n - t) / a
                                          : 4 + (t - e) / a),
                                  (s /= 6) < 0 && (s += 1),
                                  { h: 360 * s, s: a / r, v: r / 255 });
                        },
                        rgb_to_hex: function (t, e, n) {
                            var i = this.hex_with_component(0, 2, t);
                            return (
                                (i = this.hex_with_component(i, 1, e)),
                                this.hex_with_component(i, 0, n)
                            );
                        },
                        component_from_hex: function (t, e) {
                            return (t >> (8 * e)) & 255;
                        },
                        hex_with_component: function (t, e, n) {
                            return (n << (Os = 8 * e)) | (t & ~(255 << Os));
                        },
                    },
                    Ps =
                        "function" == typeof Symbol &&
                        "symbol" == typeof Symbol.iterator
                            ? function (t) {
                                  return typeof t;
                              }
                            : function (t) {
                                  return t &&
                                      "function" == typeof Symbol &&
                                      t.constructor === Symbol &&
                                      t !== Symbol.prototype
                                      ? "symbol"
                                      : typeof t;
                              },
                    Us = function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function",
                            );
                    },
                    Vs = (function () {
                        function t(t, e) {
                            for (var n = 0; n < e.length; n++) {
                                var i = e[n];
                                (i.enumerable = i.enumerable || !1),
                                    (i.configurable = !0),
                                    "value" in i && (i.writable = !0),
                                    Object.defineProperty(t, i.key, i);
                            }
                        }
                        return function (e, n, i) {
                            return n && t(e.prototype, n), i && t(e, i), e;
                        };
                    })(),
                    Ns = function t(e, n, i) {
                        null === e && (e = Function.prototype);
                        var r = Object.getOwnPropertyDescriptor(e, n);
                        if (void 0 === r) {
                            var a = Object.getPrototypeOf(e);
                            return null === a ? void 0 : t(a, n, i);
                        }
                        if ("value" in r) return r.value;
                        var s = r.get;
                        return void 0 !== s ? s.call(i) : void 0;
                    },
                    Gs = function (t, e) {
                        if ("function" != typeof e && null !== e)
                            throw new TypeError(
                                "Super expression must either be null or a function, not " +
                                    typeof e,
                            );
                        (t.prototype = Object.create(e && e.prototype, {
                            constructor: {
                                value: t,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0,
                            },
                        })),
                            e &&
                                (Object.setPrototypeOf
                                    ? Object.setPrototypeOf(t, e)
                                    : (t.__proto__ = e));
                    },
                    js = function (t, e) {
                        if (!t)
                            throw new ReferenceError(
                                "this hasn't been initialised - super() hasn't been called",
                            );
                        return !e ||
                            ("object" != typeof e && "function" != typeof e)
                            ? t
                            : e;
                    },
                    Hs = (function () {
                        function t() {
                            if (
                                (Us(this, t),
                                (this.__state = Is.apply(this, arguments)),
                                !1 === this.__state)
                            )
                                throw new Error(
                                    "Failed to interpret color arguments",
                                );
                            this.__state.a = this.__state.a || 1;
                        }
                        return (
                            Vs(t, [
                                {
                                    key: "toString",
                                    value: function () {
                                        return ws(this);
                                    },
                                },
                                {
                                    key: "toHexString",
                                    value: function () {
                                        return ws(this, !0);
                                    },
                                },
                                {
                                    key: "toOriginal",
                                    value: function () {
                                        return this.__state.conversion.write(
                                            this,
                                        );
                                    },
                                },
                            ]),
                            t
                        );
                    })();
                function Fs(t, e, n) {
                    Object.defineProperty(t, e, {
                        get: function () {
                            return (
                                "RGB" === this.__state.space ||
                                    Hs.recalculateRGB(this, e, n),
                                this.__state[e]
                            );
                        },
                        set: function (t) {
                            "RGB" !== this.__state.space &&
                                (Hs.recalculateRGB(this, e, n),
                                (this.__state.space = "RGB")),
                                (this.__state[e] = t);
                        },
                    });
                }
                function Bs(t, e) {
                    Object.defineProperty(t, e, {
                        get: function () {
                            return (
                                "HSV" === this.__state.space ||
                                    Hs.recalculateHSV(this),
                                this.__state[e]
                            );
                        },
                        set: function (t) {
                            "HSV" !== this.__state.space &&
                                (Hs.recalculateHSV(this),
                                (this.__state.space = "HSV")),
                                (this.__state[e] = t);
                        },
                    });
                }
                (Hs.recalculateRGB = function (t, e, n) {
                    if ("HEX" === t.__state.space)
                        t.__state[e] = Ds.component_from_hex(t.__state.hex, n);
                    else {
                        if ("HSV" !== t.__state.space)
                            throw new Error("Corrupted color state");
                        Rs.extend(
                            t.__state,
                            Ds.hsv_to_rgb(
                                t.__state.h,
                                t.__state.s,
                                t.__state.v,
                            ),
                        );
                    }
                }),
                    (Hs.recalculateHSV = function (t) {
                        var e = Ds.rgb_to_hsv(t.r, t.g, t.b);
                        Rs.extend(t.__state, { s: e.s, v: e.v }),
                            Rs.isNaN(e.h)
                                ? Rs.isUndefined(t.__state.h) &&
                                  (t.__state.h = 0)
                                : (t.__state.h = e.h);
                    }),
                    (Hs.COMPONENTS = [
                        "r",
                        "g",
                        "b",
                        "h",
                        "s",
                        "v",
                        "hex",
                        "a",
                    ]),
                    Fs(Hs.prototype, "r", 2),
                    Fs(Hs.prototype, "g", 1),
                    Fs(Hs.prototype, "b", 0),
                    Bs(Hs.prototype, "h"),
                    Bs(Hs.prototype, "s"),
                    Bs(Hs.prototype, "v"),
                    Object.defineProperty(Hs.prototype, "a", {
                        get: function () {
                            return this.__state.a;
                        },
                        set: function (t) {
                            this.__state.a = t;
                        },
                    }),
                    Object.defineProperty(Hs.prototype, "hex", {
                        get: function () {
                            return (
                                "HEX" !== this.__state.space &&
                                    ((this.__state.hex = Ds.rgb_to_hex(
                                        this.r,
                                        this.g,
                                        this.b,
                                    )),
                                    (this.__state.space = "HEX")),
                                this.__state.hex
                            );
                        },
                        set: function (t) {
                            (this.__state.space = "HEX"),
                                (this.__state.hex = t);
                        },
                    });
                var zs = (function () {
                        function t(e, n) {
                            Us(this, t),
                                (this.initialValue = e[n]),
                                (this.domElement =
                                    document.createElement("div")),
                                (this.object = e),
                                (this.property = n),
                                (this.__onChange = void 0),
                                (this.__onFinishChange = void 0);
                        }
                        return (
                            Vs(t, [
                                {
                                    key: "onChange",
                                    value: function (t) {
                                        return (this.__onChange = t), this;
                                    },
                                },
                                {
                                    key: "onFinishChange",
                                    value: function (t) {
                                        return (
                                            (this.__onFinishChange = t), this
                                        );
                                    },
                                },
                                {
                                    key: "setValue",
                                    value: function (t) {
                                        return (
                                            (this.object[this.property] = t),
                                            this.__onChange &&
                                                this.__onChange.call(this, t),
                                            this.updateDisplay(),
                                            this
                                        );
                                    },
                                },
                                {
                                    key: "getValue",
                                    value: function () {
                                        return this.object[this.property];
                                    },
                                },
                                {
                                    key: "updateDisplay",
                                    value: function () {
                                        return this;
                                    },
                                },
                                {
                                    key: "isModified",
                                    value: function () {
                                        return (
                                            this.initialValue !==
                                            this.getValue()
                                        );
                                    },
                                },
                            ]),
                            t
                        );
                    })(),
                    Ws = {};
                Rs.each(
                    {
                        HTMLEvents: ["change"],
                        MouseEvents: [
                            "click",
                            "mousemove",
                            "mousedown",
                            "mouseup",
                            "mouseover",
                        ],
                        KeyboardEvents: ["keydown"],
                    },
                    function (t, e) {
                        Rs.each(t, function (t) {
                            Ws[t] = e;
                        });
                    },
                );
                var qs = /(\d+(\.\d+)?)px/;
                function Ys(t) {
                    if ("0" === t || Rs.isUndefined(t)) return 0;
                    var e = t.match(qs);
                    return Rs.isNull(e) ? 0 : parseFloat(e[1]);
                }
                var Ks = {
                        makeSelectable: function (t, e) {
                            void 0 !== t &&
                                void 0 !== t.style &&
                                ((t.onselectstart = e
                                    ? function () {
                                          return !1;
                                      }
                                    : function () {}),
                                (t.style.MozUserSelect = e ? "auto" : "none"),
                                (t.style.KhtmlUserSelect = e ? "auto" : "none"),
                                (t.unselectable = e ? "on" : "off"));
                        },
                        makeFullscreen: function (t, e, n) {
                            var i = n,
                                r = e;
                            Rs.isUndefined(r) && (r = !0),
                                Rs.isUndefined(i) && (i = !0),
                                (t.style.position = "absolute"),
                                r && ((t.style.left = 0), (t.style.right = 0)),
                                i && ((t.style.top = 0), (t.style.bottom = 0));
                        },
                        fakeEvent: function (t, e, n, i) {
                            var r = n || {},
                                a = Ws[e];
                            if (!a)
                                throw new Error(
                                    "Event type " + e + " not supported.",
                                );
                            var s = document.createEvent(a);
                            switch (a) {
                                case "MouseEvents":
                                    var o = r.x || r.clientX || 0,
                                        l = r.y || r.clientY || 0;
                                    s.initMouseEvent(
                                        e,
                                        r.bubbles || !1,
                                        r.cancelable || !0,
                                        window,
                                        r.clickCount || 1,
                                        0,
                                        0,
                                        o,
                                        l,
                                        !1,
                                        !1,
                                        !1,
                                        !1,
                                        0,
                                        null,
                                    );
                                    break;
                                case "KeyboardEvents":
                                    var c =
                                        s.initKeyboardEvent || s.initKeyEvent;
                                    Rs.defaults(r, {
                                        cancelable: !0,
                                        ctrlKey: !1,
                                        altKey: !1,
                                        shiftKey: !1,
                                        metaKey: !1,
                                        keyCode: void 0,
                                        charCode: void 0,
                                    }),
                                        c(
                                            e,
                                            r.bubbles || !1,
                                            r.cancelable,
                                            window,
                                            r.ctrlKey,
                                            r.altKey,
                                            r.shiftKey,
                                            r.metaKey,
                                            r.keyCode,
                                            r.charCode,
                                        );
                                    break;
                                default:
                                    s.initEvent(
                                        e,
                                        r.bubbles || !1,
                                        r.cancelable || !0,
                                    );
                            }
                            Rs.defaults(s, i), t.dispatchEvent(s);
                        },
                        bind: function (t, e, n, i) {
                            var r = i || !1;
                            return (
                                t.addEventListener
                                    ? t.addEventListener(e, n, r)
                                    : t.attachEvent &&
                                      t.attachEvent("on" + e, n),
                                Ks
                            );
                        },
                        unbind: function (t, e, n, i) {
                            var r = i || !1;
                            return (
                                t.removeEventListener
                                    ? t.removeEventListener(e, n, r)
                                    : t.detachEvent &&
                                      t.detachEvent("on" + e, n),
                                Ks
                            );
                        },
                        addClass: function (t, e) {
                            if (void 0 === t.className) t.className = e;
                            else if (t.className !== e) {
                                var n = t.className.split(/ +/);
                                -1 === n.indexOf(e) &&
                                    (n.push(e),
                                    (t.className = n
                                        .join(" ")
                                        .replace(/^\s+/, "")
                                        .replace(/\s+$/, "")));
                            }
                            return Ks;
                        },
                        removeClass: function (t, e) {
                            if (e)
                                if (t.className === e)
                                    t.removeAttribute("class");
                                else {
                                    var n = t.className.split(/ +/),
                                        i = n.indexOf(e);
                                    -1 !== i &&
                                        (n.splice(i, 1),
                                        (t.className = n.join(" ")));
                                }
                            else t.className = void 0;
                            return Ks;
                        },
                        hasClass: function (t, e) {
                            return (
                                new RegExp(
                                    "(?:^|\\s+)" + e + "(?:\\s+|$)",
                                ).test(t.className) || !1
                            );
                        },
                        getWidth: function (t) {
                            var e = getComputedStyle(t);
                            return (
                                Ys(e["border-left-width"]) +
                                Ys(e["border-right-width"]) +
                                Ys(e["padding-left"]) +
                                Ys(e["padding-right"]) +
                                Ys(e.width)
                            );
                        },
                        getHeight: function (t) {
                            var e = getComputedStyle(t);
                            return (
                                Ys(e["border-top-width"]) +
                                Ys(e["border-bottom-width"]) +
                                Ys(e["padding-top"]) +
                                Ys(e["padding-bottom"]) +
                                Ys(e.height)
                            );
                        },
                        getOffset: function (t) {
                            var e = t,
                                n = { left: 0, top: 0 };
                            if (e.offsetParent)
                                do {
                                    (n.left += e.offsetLeft),
                                        (n.top += e.offsetTop),
                                        (e = e.offsetParent);
                                } while (e);
                            return n;
                        },
                        isActive: function (t) {
                            return (
                                t === document.activeElement &&
                                (t.type || t.href)
                            );
                        },
                    },
                    Js = (function (t) {
                        function e(t, n) {
                            Us(this, e);
                            var i = js(
                                    this,
                                    (
                                        e.__proto__ || Object.getPrototypeOf(e)
                                    ).call(this, t, n),
                                ),
                                r = i;
                            return (
                                (i.__prev = i.getValue()),
                                (i.__checkbox =
                                    document.createElement("input")),
                                i.__checkbox.setAttribute("type", "checkbox"),
                                Ks.bind(
                                    i.__checkbox,
                                    "change",
                                    function () {
                                        r.setValue(!r.__prev);
                                    },
                                    !1,
                                ),
                                i.domElement.appendChild(i.__checkbox),
                                i.updateDisplay(),
                                i
                            );
                        }
                        return (
                            Gs(e, t),
                            Vs(e, [
                                {
                                    key: "setValue",
                                    value: function (t) {
                                        var n = Ns(
                                            e.prototype.__proto__ ||
                                                Object.getPrototypeOf(
                                                    e.prototype,
                                                ),
                                            "setValue",
                                            this,
                                        ).call(this, t);
                                        return (
                                            this.__onFinishChange &&
                                                this.__onFinishChange.call(
                                                    this,
                                                    this.getValue(),
                                                ),
                                            (this.__prev = this.getValue()),
                                            n
                                        );
                                    },
                                },
                                {
                                    key: "updateDisplay",
                                    value: function () {
                                        return (
                                            !0 === this.getValue()
                                                ? (this.__checkbox.setAttribute(
                                                      "checked",
                                                      "checked",
                                                  ),
                                                  (this.__checkbox.checked =
                                                      !0),
                                                  (this.__prev = !0))
                                                : ((this.__checkbox.checked =
                                                      !1),
                                                  (this.__prev = !1)),
                                            Ns(
                                                e.prototype.__proto__ ||
                                                    Object.getPrototypeOf(
                                                        e.prototype,
                                                    ),
                                                "updateDisplay",
                                                this,
                                            ).call(this)
                                        );
                                    },
                                },
                            ]),
                            e
                        );
                    })(zs),
                    Zs = (function (t) {
                        function e(t, n, i) {
                            Us(this, e);
                            var r = js(
                                    this,
                                    (
                                        e.__proto__ || Object.getPrototypeOf(e)
                                    ).call(this, t, n),
                                ),
                                a = i,
                                s = r;
                            if (
                                ((r.__select =
                                    document.createElement("select")),
                                Rs.isArray(a))
                            ) {
                                var o = {};
                                Rs.each(a, function (t) {
                                    o[t] = t;
                                }),
                                    (a = o);
                            }
                            return (
                                Rs.each(a, function (t, e) {
                                    var n = document.createElement("option");
                                    (n.innerHTML = e),
                                        n.setAttribute("value", t),
                                        s.__select.appendChild(n);
                                }),
                                r.updateDisplay(),
                                Ks.bind(r.__select, "change", function () {
                                    var t =
                                        this.options[this.selectedIndex].value;
                                    s.setValue(t);
                                }),
                                r.domElement.appendChild(r.__select),
                                r
                            );
                        }
                        return (
                            Gs(e, t),
                            Vs(e, [
                                {
                                    key: "setValue",
                                    value: function (t) {
                                        var n = Ns(
                                            e.prototype.__proto__ ||
                                                Object.getPrototypeOf(
                                                    e.prototype,
                                                ),
                                            "setValue",
                                            this,
                                        ).call(this, t);
                                        return (
                                            this.__onFinishChange &&
                                                this.__onFinishChange.call(
                                                    this,
                                                    this.getValue(),
                                                ),
                                            n
                                        );
                                    },
                                },
                                {
                                    key: "updateDisplay",
                                    value: function () {
                                        return Ks.isActive(this.__select)
                                            ? this
                                            : ((this.__select.value =
                                                  this.getValue()),
                                              Ns(
                                                  e.prototype.__proto__ ||
                                                      Object.getPrototypeOf(
                                                          e.prototype,
                                                      ),
                                                  "updateDisplay",
                                                  this,
                                              ).call(this));
                                    },
                                },
                            ]),
                            e
                        );
                    })(zs),
                    Xs = (function (t) {
                        function e(t, n) {
                            Us(this, e);
                            var i = js(
                                    this,
                                    (
                                        e.__proto__ || Object.getPrototypeOf(e)
                                    ).call(this, t, n),
                                ),
                                r = i;
                            function a() {
                                r.setValue(r.__input.value);
                            }
                            return (
                                (i.__input = document.createElement("input")),
                                i.__input.setAttribute("type", "text"),
                                Ks.bind(i.__input, "keyup", a),
                                Ks.bind(i.__input, "change", a),
                                Ks.bind(i.__input, "blur", function () {
                                    r.__onFinishChange &&
                                        r.__onFinishChange.call(
                                            r,
                                            r.getValue(),
                                        );
                                }),
                                Ks.bind(i.__input, "keydown", function (t) {
                                    13 === t.keyCode && this.blur();
                                }),
                                i.updateDisplay(),
                                i.domElement.appendChild(i.__input),
                                i
                            );
                        }
                        return (
                            Gs(e, t),
                            Vs(e, [
                                {
                                    key: "updateDisplay",
                                    value: function () {
                                        return (
                                            Ks.isActive(this.__input) ||
                                                (this.__input.value =
                                                    this.getValue()),
                                            Ns(
                                                e.prototype.__proto__ ||
                                                    Object.getPrototypeOf(
                                                        e.prototype,
                                                    ),
                                                "updateDisplay",
                                                this,
                                            ).call(this)
                                        );
                                    },
                                },
                            ]),
                            e
                        );
                    })(zs);
                function Qs(t) {
                    var e = t.toString();
                    return e.indexOf(".") > -1
                        ? e.length - e.indexOf(".") - 1
                        : 0;
                }
                var $s = (function (t) {
                        function e(t, n, i) {
                            Us(this, e);
                            var r = js(
                                    this,
                                    (
                                        e.__proto__ || Object.getPrototypeOf(e)
                                    ).call(this, t, n),
                                ),
                                a = i || {};
                            return (
                                (r.__min = a.min),
                                (r.__max = a.max),
                                (r.__step = a.step),
                                Rs.isUndefined(r.__step)
                                    ? 0 === r.initialValue
                                        ? (r.__impliedStep = 1)
                                        : (r.__impliedStep =
                                              Math.pow(
                                                  10,
                                                  Math.floor(
                                                      Math.log(
                                                          Math.abs(
                                                              r.initialValue,
                                                          ),
                                                      ) / Math.LN10,
                                                  ),
                                              ) / 10)
                                    : (r.__impliedStep = r.__step),
                                (r.__precision = Qs(r.__impliedStep)),
                                r
                            );
                        }
                        return (
                            Gs(e, t),
                            Vs(e, [
                                {
                                    key: "setValue",
                                    value: function (t) {
                                        var n = t;
                                        return (
                                            void 0 !== this.__min &&
                                            n < this.__min
                                                ? (n = this.__min)
                                                : void 0 !== this.__max &&
                                                  n > this.__max &&
                                                  (n = this.__max),
                                            void 0 !== this.__step &&
                                                n % this.__step != 0 &&
                                                (n =
                                                    Math.round(
                                                        n / this.__step,
                                                    ) * this.__step),
                                            Ns(
                                                e.prototype.__proto__ ||
                                                    Object.getPrototypeOf(
                                                        e.prototype,
                                                    ),
                                                "setValue",
                                                this,
                                            ).call(this, n)
                                        );
                                    },
                                },
                                {
                                    key: "min",
                                    value: function (t) {
                                        return (this.__min = t), this;
                                    },
                                },
                                {
                                    key: "max",
                                    value: function (t) {
                                        return (this.__max = t), this;
                                    },
                                },
                                {
                                    key: "step",
                                    value: function (t) {
                                        return (
                                            (this.__step = t),
                                            (this.__impliedStep = t),
                                            (this.__precision = Qs(t)),
                                            this
                                        );
                                    },
                                },
                            ]),
                            e
                        );
                    })(zs),
                    to = (function (t) {
                        function e(t, n, i) {
                            Us(this, e);
                            var r = js(
                                this,
                                (e.__proto__ || Object.getPrototypeOf(e)).call(
                                    this,
                                    t,
                                    n,
                                    i,
                                ),
                            );
                            r.__truncationSuspended = !1;
                            var a = r,
                                s = void 0;
                            function o() {
                                a.__onFinishChange &&
                                    a.__onFinishChange.call(a, a.getValue());
                            }
                            function l(t) {
                                var e = s - t.clientY;
                                a.setValue(a.getValue() + e * a.__impliedStep),
                                    (s = t.clientY);
                            }
                            function c() {
                                Ks.unbind(window, "mousemove", l),
                                    Ks.unbind(window, "mouseup", c),
                                    o();
                            }
                            return (
                                (r.__input = document.createElement("input")),
                                r.__input.setAttribute("type", "text"),
                                Ks.bind(r.__input, "change", function () {
                                    var t = parseFloat(a.__input.value);
                                    Rs.isNaN(t) || a.setValue(t);
                                }),
                                Ks.bind(r.__input, "blur", function () {
                                    o();
                                }),
                                Ks.bind(r.__input, "mousedown", function (t) {
                                    Ks.bind(window, "mousemove", l),
                                        Ks.bind(window, "mouseup", c),
                                        (s = t.clientY);
                                }),
                                Ks.bind(r.__input, "keydown", function (t) {
                                    13 === t.keyCode &&
                                        ((a.__truncationSuspended = !0),
                                        this.blur(),
                                        (a.__truncationSuspended = !1),
                                        o());
                                }),
                                r.updateDisplay(),
                                r.domElement.appendChild(r.__input),
                                r
                            );
                        }
                        return (
                            Gs(e, t),
                            Vs(e, [
                                {
                                    key: "updateDisplay",
                                    value: function () {
                                        var t, n, i;
                                        return (
                                            (this.__input.value = this
                                                .__truncationSuspended
                                                ? this.getValue()
                                                : ((t = this.getValue()),
                                                  (n = this.__precision),
                                                  (i = Math.pow(10, n)),
                                                  Math.round(t * i) / i)),
                                            Ns(
                                                e.prototype.__proto__ ||
                                                    Object.getPrototypeOf(
                                                        e.prototype,
                                                    ),
                                                "updateDisplay",
                                                this,
                                            ).call(this)
                                        );
                                    },
                                },
                            ]),
                            e
                        );
                    })($s);
                function eo(t, e, n, i, r) {
                    return i + ((t - e) / (n - e)) * (r - i);
                }
                var no = (function (t) {
                        function e(t, n, i, r, a) {
                            Us(this, e);
                            var s = js(
                                    this,
                                    (
                                        e.__proto__ || Object.getPrototypeOf(e)
                                    ).call(this, t, n, {
                                        min: i,
                                        max: r,
                                        step: a,
                                    }),
                                ),
                                o = s;
                            function l(t) {
                                t.preventDefault();
                                var e = o.__background.getBoundingClientRect();
                                return (
                                    o.setValue(
                                        eo(
                                            t.clientX,
                                            e.left,
                                            e.right,
                                            o.__min,
                                            o.__max,
                                        ),
                                    ),
                                    !1
                                );
                            }
                            function c() {
                                Ks.unbind(window, "mousemove", l),
                                    Ks.unbind(window, "mouseup", c),
                                    o.__onFinishChange &&
                                        o.__onFinishChange.call(
                                            o,
                                            o.getValue(),
                                        );
                            }
                            function h(t) {
                                var e = t.touches[0].clientX,
                                    n = o.__background.getBoundingClientRect();
                                o.setValue(
                                    eo(e, n.left, n.right, o.__min, o.__max),
                                );
                            }
                            function u() {
                                Ks.unbind(window, "touchmove", h),
                                    Ks.unbind(window, "touchend", u),
                                    o.__onFinishChange &&
                                        o.__onFinishChange.call(
                                            o,
                                            o.getValue(),
                                        );
                            }
                            return (
                                (s.__background =
                                    document.createElement("div")),
                                (s.__foreground =
                                    document.createElement("div")),
                                Ks.bind(
                                    s.__background,
                                    "mousedown",
                                    function (t) {
                                        document.activeElement.blur(),
                                            Ks.bind(window, "mousemove", l),
                                            Ks.bind(window, "mouseup", c),
                                            l(t);
                                    },
                                ),
                                Ks.bind(
                                    s.__background,
                                    "touchstart",
                                    function (t) {
                                        1 === t.touches.length &&
                                            (Ks.bind(window, "touchmove", h),
                                            Ks.bind(window, "touchend", u),
                                            h(t));
                                    },
                                ),
                                Ks.addClass(s.__background, "slider"),
                                Ks.addClass(s.__foreground, "slider-fg"),
                                s.updateDisplay(),
                                s.__background.appendChild(s.__foreground),
                                s.domElement.appendChild(s.__background),
                                s
                            );
                        }
                        return (
                            Gs(e, t),
                            Vs(e, [
                                {
                                    key: "updateDisplay",
                                    value: function () {
                                        var t =
                                            (this.getValue() - this.__min) /
                                            (this.__max - this.__min);
                                        return (
                                            (this.__foreground.style.width =
                                                100 * t + "%"),
                                            Ns(
                                                e.prototype.__proto__ ||
                                                    Object.getPrototypeOf(
                                                        e.prototype,
                                                    ),
                                                "updateDisplay",
                                                this,
                                            ).call(this)
                                        );
                                    },
                                },
                            ]),
                            e
                        );
                    })($s),
                    io = (function (t) {
                        function e(t, n, i) {
                            Us(this, e);
                            var r = js(
                                    this,
                                    (
                                        e.__proto__ || Object.getPrototypeOf(e)
                                    ).call(this, t, n),
                                ),
                                a = r;
                            return (
                                (r.__button = document.createElement("div")),
                                (r.__button.innerHTML =
                                    void 0 === i ? "Fire" : i),
                                Ks.bind(r.__button, "click", function (t) {
                                    return t.preventDefault(), a.fire(), !1;
                                }),
                                Ks.addClass(r.__button, "button"),
                                r.domElement.appendChild(r.__button),
                                r
                            );
                        }
                        return (
                            Gs(e, t),
                            Vs(e, [
                                {
                                    key: "fire",
                                    value: function () {
                                        this.__onChange &&
                                            this.__onChange.call(this),
                                            this.getValue().call(this.object),
                                            this.__onFinishChange &&
                                                this.__onFinishChange.call(
                                                    this,
                                                    this.getValue(),
                                                );
                                    },
                                },
                            ]),
                            e
                        );
                    })(zs),
                    ro = (function (t) {
                        function e(t, n) {
                            Us(this, e);
                            var i = js(
                                this,
                                (e.__proto__ || Object.getPrototypeOf(e)).call(
                                    this,
                                    t,
                                    n,
                                ),
                            );
                            (i.__color = new Hs(i.getValue())),
                                (i.__temp = new Hs(0));
                            var r = i;
                            (i.domElement = document.createElement("div")),
                                Ks.makeSelectable(i.domElement, !1),
                                (i.__selector = document.createElement("div")),
                                (i.__selector.className = "selector"),
                                (i.__saturation_field =
                                    document.createElement("div")),
                                (i.__saturation_field.className =
                                    "saturation-field"),
                                (i.__field_knob =
                                    document.createElement("div")),
                                (i.__field_knob.className = "field-knob"),
                                (i.__field_knob_border = "2px solid "),
                                (i.__hue_knob = document.createElement("div")),
                                (i.__hue_knob.className = "hue-knob"),
                                (i.__hue_field = document.createElement("div")),
                                (i.__hue_field.className = "hue-field"),
                                (i.__input = document.createElement("input")),
                                (i.__input.type = "text"),
                                (i.__input_textShadow = "0 1px 1px "),
                                Ks.bind(i.__input, "keydown", function (t) {
                                    13 === t.keyCode && u.call(this);
                                }),
                                Ks.bind(i.__input, "blur", u),
                                Ks.bind(i.__selector, "mousedown", function () {
                                    Ks.addClass(this, "drag").bind(
                                        window,
                                        "mouseup",
                                        function () {
                                            Ks.removeClass(
                                                r.__selector,
                                                "drag",
                                            );
                                        },
                                    );
                                }),
                                Ks.bind(
                                    i.__selector,
                                    "touchstart",
                                    function () {
                                        Ks.addClass(this, "drag").bind(
                                            window,
                                            "touchend",
                                            function () {
                                                Ks.removeClass(
                                                    r.__selector,
                                                    "drag",
                                                );
                                            },
                                        );
                                    },
                                );
                            var a,
                                s = document.createElement("div");
                            function o(t) {
                                p(t),
                                    Ks.bind(window, "mousemove", p),
                                    Ks.bind(window, "touchmove", p),
                                    Ks.bind(window, "mouseup", c),
                                    Ks.bind(window, "touchend", c);
                            }
                            function l(t) {
                                f(t),
                                    Ks.bind(window, "mousemove", f),
                                    Ks.bind(window, "touchmove", f),
                                    Ks.bind(window, "mouseup", h),
                                    Ks.bind(window, "touchend", h);
                            }
                            function c() {
                                Ks.unbind(window, "mousemove", p),
                                    Ks.unbind(window, "touchmove", p),
                                    Ks.unbind(window, "mouseup", c),
                                    Ks.unbind(window, "touchend", c),
                                    d();
                            }
                            function h() {
                                Ks.unbind(window, "mousemove", f),
                                    Ks.unbind(window, "touchmove", f),
                                    Ks.unbind(window, "mouseup", h),
                                    Ks.unbind(window, "touchend", h),
                                    d();
                            }
                            function u() {
                                var t = Is(this.value);
                                !1 !== t
                                    ? ((r.__color.__state = t),
                                      r.setValue(r.__color.toOriginal()))
                                    : (this.value = r.__color.toString());
                            }
                            function d() {
                                r.__onFinishChange &&
                                    r.__onFinishChange.call(
                                        r,
                                        r.__color.toOriginal(),
                                    );
                            }
                            function p(t) {
                                -1 === t.type.indexOf("touch") &&
                                    t.preventDefault();
                                var e =
                                        r.__saturation_field.getBoundingClientRect(),
                                    n = (t.touches && t.touches[0]) || t,
                                    i = n.clientX,
                                    a = n.clientY,
                                    s = (i - e.left) / (e.right - e.left),
                                    o = 1 - (a - e.top) / (e.bottom - e.top);
                                return (
                                    o > 1 ? (o = 1) : o < 0 && (o = 0),
                                    s > 1 ? (s = 1) : s < 0 && (s = 0),
                                    (r.__color.v = o),
                                    (r.__color.s = s),
                                    r.setValue(r.__color.toOriginal()),
                                    !1
                                );
                            }
                            function f(t) {
                                -1 === t.type.indexOf("touch") &&
                                    t.preventDefault();
                                var e = r.__hue_field.getBoundingClientRect(),
                                    n =
                                        1 -
                                        (((t.touches && t.touches[0]) || t)
                                            .clientY -
                                            e.top) /
                                            (e.bottom - e.top);
                                return (
                                    n > 1 ? (n = 1) : n < 0 && (n = 0),
                                    (r.__color.h = 360 * n),
                                    r.setValue(r.__color.toOriginal()),
                                    !1
                                );
                            }
                            return (
                                Rs.extend(i.__selector.style, {
                                    width: "122px",
                                    height: "102px",
                                    padding: "3px",
                                    backgroundColor: "#222",
                                    boxShadow: "0px 1px 3px rgba(0,0,0,0.3)",
                                }),
                                Rs.extend(i.__field_knob.style, {
                                    position: "absolute",
                                    width: "12px",
                                    height: "12px",
                                    border:
                                        i.__field_knob_border +
                                        (i.__color.v < 0.5 ? "#fff" : "#000"),
                                    boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                                    borderRadius: "12px",
                                    zIndex: 1,
                                }),
                                Rs.extend(i.__hue_knob.style, {
                                    position: "absolute",
                                    width: "15px",
                                    height: "2px",
                                    borderRight: "4px solid #fff",
                                    zIndex: 1,
                                }),
                                Rs.extend(i.__saturation_field.style, {
                                    width: "100px",
                                    height: "100px",
                                    border: "1px solid #555",
                                    marginRight: "3px",
                                    display: "inline-block",
                                    cursor: "pointer",
                                }),
                                Rs.extend(s.style, {
                                    width: "100%",
                                    height: "100%",
                                    background: "none",
                                }),
                                so(s, "top", "rgba(0,0,0,0)", "#000"),
                                Rs.extend(i.__hue_field.style, {
                                    width: "15px",
                                    height: "100px",
                                    border: "1px solid #555",
                                    cursor: "ns-resize",
                                    position: "absolute",
                                    top: "3px",
                                    right: "3px",
                                }),
                                ((a = i.__hue_field).style.background = ""),
                                (a.style.cssText +=
                                    "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);"),
                                (a.style.cssText +=
                                    "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
                                (a.style.cssText +=
                                    "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
                                (a.style.cssText +=
                                    "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
                                (a.style.cssText +=
                                    "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
                                Rs.extend(i.__input.style, {
                                    outline: "none",
                                    textAlign: "center",
                                    color: "#fff",
                                    border: 0,
                                    fontWeight: "bold",
                                    textShadow:
                                        i.__input_textShadow +
                                        "rgba(0,0,0,0.7)",
                                }),
                                Ks.bind(i.__saturation_field, "mousedown", o),
                                Ks.bind(i.__saturation_field, "touchstart", o),
                                Ks.bind(i.__field_knob, "mousedown", o),
                                Ks.bind(i.__field_knob, "touchstart", o),
                                Ks.bind(i.__hue_field, "mousedown", l),
                                Ks.bind(i.__hue_field, "touchstart", l),
                                i.__saturation_field.appendChild(s),
                                i.__selector.appendChild(i.__field_knob),
                                i.__selector.appendChild(i.__saturation_field),
                                i.__selector.appendChild(i.__hue_field),
                                i.__hue_field.appendChild(i.__hue_knob),
                                i.domElement.appendChild(i.__input),
                                i.domElement.appendChild(i.__selector),
                                i.updateDisplay(),
                                i
                            );
                        }
                        return (
                            Gs(e, t),
                            Vs(e, [
                                {
                                    key: "updateDisplay",
                                    value: function () {
                                        var t = Is(this.getValue());
                                        if (!1 !== t) {
                                            var e = !1;
                                            Rs.each(
                                                Hs.COMPONENTS,
                                                function (n) {
                                                    if (
                                                        !Rs.isUndefined(t[n]) &&
                                                        !Rs.isUndefined(
                                                            this.__color
                                                                .__state[n],
                                                        ) &&
                                                        t[n] !==
                                                            this.__color
                                                                .__state[n]
                                                    )
                                                        return (e = !0), {};
                                                },
                                                this,
                                            ),
                                                e &&
                                                    Rs.extend(
                                                        this.__color.__state,
                                                        t,
                                                    );
                                        }
                                        Rs.extend(
                                            this.__temp.__state,
                                            this.__color.__state,
                                        ),
                                            (this.__temp.a = 1);
                                        var n =
                                                this.__color.v < 0.5 ||
                                                this.__color.s > 0.5
                                                    ? 255
                                                    : 0,
                                            i = 255 - n;
                                        Rs.extend(this.__field_knob.style, {
                                            marginLeft:
                                                100 * this.__color.s - 7 + "px",
                                            marginTop:
                                                100 * (1 - this.__color.v) -
                                                7 +
                                                "px",
                                            backgroundColor:
                                                this.__temp.toHexString(),
                                            border:
                                                this.__field_knob_border +
                                                "rgb(" +
                                                n +
                                                "," +
                                                n +
                                                "," +
                                                n +
                                                ")",
                                        }),
                                            (this.__hue_knob.style.marginTop =
                                                100 *
                                                    (1 - this.__color.h / 360) +
                                                "px"),
                                            (this.__temp.s = 1),
                                            (this.__temp.v = 1),
                                            so(
                                                this.__saturation_field,
                                                "left",
                                                "#fff",
                                                this.__temp.toHexString(),
                                            ),
                                            (this.__input.value =
                                                this.__color.toString()),
                                            Rs.extend(this.__input.style, {
                                                backgroundColor:
                                                    this.__color.toHexString(),
                                                color:
                                                    "rgb(" +
                                                    n +
                                                    "," +
                                                    n +
                                                    "," +
                                                    n +
                                                    ")",
                                                textShadow:
                                                    this.__input_textShadow +
                                                    "rgba(" +
                                                    i +
                                                    "," +
                                                    i +
                                                    "," +
                                                    i +
                                                    ",.7)",
                                            });
                                    },
                                },
                            ]),
                            e
                        );
                    })(zs),
                    ao = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
                function so(t, e, n, i) {
                    (t.style.background = ""),
                        Rs.each(ao, function (r) {
                            t.style.cssText +=
                                "background: " +
                                r +
                                "linear-gradient(" +
                                e +
                                ", " +
                                n +
                                " 0%, " +
                                i +
                                " 100%); ";
                        });
                }
                var oo =
                        '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>',
                    lo = function (t, e) {
                        var n = t[e];
                        return Rs.isArray(arguments[2]) ||
                            Rs.isObject(arguments[2])
                            ? new Zs(t, e, arguments[2])
                            : Rs.isNumber(n)
                            ? Rs.isNumber(arguments[2]) &&
                              Rs.isNumber(arguments[3])
                                ? Rs.isNumber(arguments[4])
                                    ? new no(
                                          t,
                                          e,
                                          arguments[2],
                                          arguments[3],
                                          arguments[4],
                                      )
                                    : new no(t, e, arguments[2], arguments[3])
                                : Rs.isNumber(arguments[4])
                                ? new to(t, e, {
                                      min: arguments[2],
                                      max: arguments[3],
                                      step: arguments[4],
                                  })
                                : new to(t, e, {
                                      min: arguments[2],
                                      max: arguments[3],
                                  })
                            : Rs.isString(n)
                            ? new Xs(t, e)
                            : Rs.isFunction(n)
                            ? new io(t, e, "")
                            : Rs.isBoolean(n)
                            ? new Js(t, e)
                            : null;
                    },
                    co =
                        window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.oRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||
                        function (t) {
                            setTimeout(t, 1e3 / 60);
                        },
                    ho = (function () {
                        function t() {
                            Us(this, t),
                                (this.backgroundElement =
                                    document.createElement("div")),
                                Rs.extend(this.backgroundElement.style, {
                                    backgroundColor: "rgba(0,0,0,0.8)",
                                    top: 0,
                                    left: 0,
                                    display: "none",
                                    zIndex: "1000",
                                    opacity: 0,
                                    WebkitTransition: "opacity 0.2s linear",
                                    transition: "opacity 0.2s linear",
                                }),
                                Ks.makeFullscreen(this.backgroundElement),
                                (this.backgroundElement.style.position =
                                    "fixed"),
                                (this.domElement =
                                    document.createElement("div")),
                                Rs.extend(this.domElement.style, {
                                    position: "fixed",
                                    display: "none",
                                    zIndex: "1001",
                                    opacity: 0,
                                    WebkitTransition:
                                        "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
                                    transition:
                                        "transform 0.2s ease-out, opacity 0.2s linear",
                                }),
                                document.body.appendChild(
                                    this.backgroundElement,
                                ),
                                document.body.appendChild(this.domElement);
                            var e = this;
                            Ks.bind(
                                this.backgroundElement,
                                "click",
                                function () {
                                    e.hide();
                                },
                            );
                        }
                        return (
                            Vs(t, [
                                {
                                    key: "show",
                                    value: function () {
                                        var t = this;
                                        (this.backgroundElement.style.display =
                                            "block"),
                                            (this.domElement.style.display =
                                                "block"),
                                            (this.domElement.style.opacity = 0),
                                            (this.domElement.style.webkitTransform =
                                                "scale(1.1)"),
                                            this.layout(),
                                            Rs.defer(function () {
                                                (t.backgroundElement.style.opacity = 1),
                                                    (t.domElement.style.opacity = 1),
                                                    (t.domElement.style.webkitTransform =
                                                        "scale(1)");
                                            });
                                    },
                                },
                                {
                                    key: "hide",
                                    value: function () {
                                        var t = this,
                                            e = function e() {
                                                (t.domElement.style.display =
                                                    "none"),
                                                    (t.backgroundElement.style.display =
                                                        "none"),
                                                    Ks.unbind(
                                                        t.domElement,
                                                        "webkitTransitionEnd",
                                                        e,
                                                    ),
                                                    Ks.unbind(
                                                        t.domElement,
                                                        "transitionend",
                                                        e,
                                                    ),
                                                    Ks.unbind(
                                                        t.domElement,
                                                        "oTransitionEnd",
                                                        e,
                                                    );
                                            };
                                        Ks.bind(
                                            this.domElement,
                                            "webkitTransitionEnd",
                                            e,
                                        ),
                                            Ks.bind(
                                                this.domElement,
                                                "transitionend",
                                                e,
                                            ),
                                            Ks.bind(
                                                this.domElement,
                                                "oTransitionEnd",
                                                e,
                                            ),
                                            (this.backgroundElement.style.opacity = 0),
                                            (this.domElement.style.opacity = 0),
                                            (this.domElement.style.webkitTransform =
                                                "scale(1.1)");
                                    },
                                },
                                {
                                    key: "layout",
                                    value: function () {
                                        (this.domElement.style.left =
                                            window.innerWidth / 2 -
                                            Ks.getWidth(this.domElement) / 2 +
                                            "px"),
                                            (this.domElement.style.top =
                                                window.innerHeight / 2 -
                                                Ks.getHeight(this.domElement) /
                                                    2 +
                                                "px");
                                    },
                                },
                            ]),
                            t
                        );
                    })();
                !(function (t, e) {
                    var n = e || document,
                        i = document.createElement("style");
                    (i.type = "text/css"), (i.innerHTML = t);
                    var r = n.getElementsByTagName("head")[0];
                    try {
                        r.appendChild(i);
                    } catch (t) {}
                })(
                    (function (t) {
                        if (t && "undefined" != typeof window) {
                            var e = document.createElement("style");
                            return (
                                e.setAttribute("type", "text/css"),
                                (e.innerHTML = t),
                                document.head.appendChild(e),
                                t
                            );
                        }
                    })(
                        ".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
                    ),
                );
                var uo = "Default",
                    po = (function () {
                        try {
                            return !!window.localStorage;
                        } catch (t) {
                            return !1;
                        }
                    })(),
                    fo = void 0,
                    mo = !0,
                    go = void 0,
                    vo = !1,
                    xo = [],
                    bo = function t(e) {
                        var n = this,
                            i = e || {};
                        (this.domElement = document.createElement("div")),
                            (this.__ul = document.createElement("ul")),
                            this.domElement.appendChild(this.__ul),
                            Ks.addClass(this.domElement, "dg"),
                            (this.__folders = {}),
                            (this.__controllers = []),
                            (this.__rememberedObjects = []),
                            (this.__rememberedObjectIndecesToControllers = []),
                            (this.__listening = []),
                            (i = Rs.defaults(i, {
                                closeOnTop: !1,
                                autoPlace: !0,
                                width: t.DEFAULT_WIDTH,
                            })),
                            (i = Rs.defaults(i, {
                                resizable: i.autoPlace,
                                hideable: i.autoPlace,
                            })),
                            Rs.isUndefined(i.load)
                                ? (i.load = { preset: uo })
                                : i.preset && (i.load.preset = i.preset),
                            Rs.isUndefined(i.parent) &&
                                i.hideable &&
                                xo.push(this),
                            (i.resizable =
                                Rs.isUndefined(i.parent) && i.resizable),
                            i.autoPlace &&
                                Rs.isUndefined(i.scrollable) &&
                                (i.scrollable = !0);
                        var r,
                            a =
                                po &&
                                "true" ===
                                    localStorage.getItem(wo(0, "isLocal")),
                            s = void 0,
                            o = void 0;
                        if (
                            (Object.defineProperties(this, {
                                parent: {
                                    get: function () {
                                        return i.parent;
                                    },
                                },
                                scrollable: {
                                    get: function () {
                                        return i.scrollable;
                                    },
                                },
                                autoPlace: {
                                    get: function () {
                                        return i.autoPlace;
                                    },
                                },
                                closeOnTop: {
                                    get: function () {
                                        return i.closeOnTop;
                                    },
                                },
                                preset: {
                                    get: function () {
                                        return n.parent
                                            ? n.getRoot().preset
                                            : i.load.preset;
                                    },
                                    set: function (t) {
                                        n.parent
                                            ? (n.getRoot().preset = t)
                                            : (i.load.preset = t),
                                            (function (t) {
                                                for (
                                                    var e = 0;
                                                    e <
                                                    t.__preset_select.length;
                                                    e++
                                                )
                                                    t.__preset_select[e]
                                                        .value === t.preset &&
                                                        (t.__preset_select.selectedIndex =
                                                            e);
                                            })(this),
                                            n.revert();
                                    },
                                },
                                width: {
                                    get: function () {
                                        return i.width;
                                    },
                                    set: function (t) {
                                        (i.width = t), Co(n, t);
                                    },
                                },
                                name: {
                                    get: function () {
                                        return i.name;
                                    },
                                    set: function (t) {
                                        (i.name = t),
                                            o && (o.innerHTML = i.name);
                                    },
                                },
                                closed: {
                                    get: function () {
                                        return i.closed;
                                    },
                                    set: function (e) {
                                        (i.closed = e),
                                            i.closed
                                                ? Ks.addClass(
                                                      n.__ul,
                                                      t.CLASS_CLOSED,
                                                  )
                                                : Ks.removeClass(
                                                      n.__ul,
                                                      t.CLASS_CLOSED,
                                                  ),
                                            this.onResize(),
                                            n.__closeButton &&
                                                (n.__closeButton.innerHTML = e
                                                    ? t.TEXT_OPEN
                                                    : t.TEXT_CLOSED);
                                    },
                                },
                                load: {
                                    get: function () {
                                        return i.load;
                                    },
                                },
                                useLocalStorage: {
                                    get: function () {
                                        return a;
                                    },
                                    set: function (t) {
                                        po &&
                                            ((a = t),
                                            t
                                                ? Ks.bind(window, "unload", s)
                                                : Ks.unbind(
                                                      window,
                                                      "unload",
                                                      s,
                                                  ),
                                            localStorage.setItem(
                                                wo(0, "isLocal"),
                                                t,
                                            ));
                                    },
                                },
                            }),
                            Rs.isUndefined(i.parent))
                        ) {
                            if (
                                ((this.closed = i.closed || !1),
                                Ks.addClass(this.domElement, t.CLASS_MAIN),
                                Ks.makeSelectable(this.domElement, !1),
                                po && a)
                            ) {
                                n.useLocalStorage = !0;
                                var l = localStorage.getItem(wo(0, "gui"));
                                l && (i.load = JSON.parse(l));
                            }
                            (this.__closeButton =
                                document.createElement("div")),
                                (this.__closeButton.innerHTML = t.TEXT_CLOSED),
                                Ks.addClass(
                                    this.__closeButton,
                                    t.CLASS_CLOSE_BUTTON,
                                ),
                                i.closeOnTop
                                    ? (Ks.addClass(
                                          this.__closeButton,
                                          t.CLASS_CLOSE_TOP,
                                      ),
                                      this.domElement.insertBefore(
                                          this.__closeButton,
                                          this.domElement.childNodes[0],
                                      ))
                                    : (Ks.addClass(
                                          this.__closeButton,
                                          t.CLASS_CLOSE_BOTTOM,
                                      ),
                                      this.domElement.appendChild(
                                          this.__closeButton,
                                      )),
                                Ks.bind(
                                    this.__closeButton,
                                    "click",
                                    function () {
                                        n.closed = !n.closed;
                                    },
                                );
                        } else {
                            void 0 === i.closed && (i.closed = !0);
                            var c = document.createTextNode(i.name);
                            Ks.addClass(c, "controller-name"),
                                (o = yo(n, c)),
                                Ks.addClass(this.__ul, t.CLASS_CLOSED),
                                Ks.addClass(o, "title"),
                                Ks.bind(o, "click", function (t) {
                                    return (
                                        t.preventDefault(),
                                        (n.closed = !n.closed),
                                        !1
                                    );
                                }),
                                i.closed || (this.closed = !1);
                        }
                        i.autoPlace &&
                            (Rs.isUndefined(i.parent) &&
                                (mo &&
                                    ((go = document.createElement("div")),
                                    Ks.addClass(go, "dg"),
                                    Ks.addClass(
                                        go,
                                        t.CLASS_AUTO_PLACE_CONTAINER,
                                    ),
                                    document.body.appendChild(go),
                                    (mo = !1)),
                                go.appendChild(this.domElement),
                                Ks.addClass(
                                    this.domElement,
                                    t.CLASS_AUTO_PLACE,
                                )),
                            this.parent || Co(n, i.width)),
                            (this.__resizeHandler = function () {
                                n.onResizeDebounced();
                            }),
                            Ks.bind(window, "resize", this.__resizeHandler),
                            Ks.bind(
                                this.__ul,
                                "webkitTransitionEnd",
                                this.__resizeHandler,
                            ),
                            Ks.bind(
                                this.__ul,
                                "transitionend",
                                this.__resizeHandler,
                            ),
                            Ks.bind(
                                this.__ul,
                                "oTransitionEnd",
                                this.__resizeHandler,
                            ),
                            this.onResize(),
                            i.resizable && ko(this),
                            (s = function () {
                                po &&
                                    "true" ===
                                        localStorage.getItem(
                                            wo(0, "isLocal"),
                                        ) &&
                                    localStorage.setItem(
                                        wo(0, "gui"),
                                        JSON.stringify(n.getSaveObject()),
                                    );
                            }),
                            (this.saveToLocalStorageIfPossible = s),
                            i.parent ||
                                (((r = n.getRoot()).width += 1),
                                Rs.defer(function () {
                                    r.width -= 1;
                                }));
                    };
                function yo(t, e, n) {
                    var i = document.createElement("li");
                    return (
                        e && i.appendChild(e),
                        n ? t.__ul.insertBefore(i, n) : t.__ul.appendChild(i),
                        t.onResize(),
                        i
                    );
                }
                function So(t) {
                    Ks.unbind(window, "resize", t.__resizeHandler),
                        t.saveToLocalStorageIfPossible &&
                            Ks.unbind(
                                window,
                                "unload",
                                t.saveToLocalStorageIfPossible,
                            );
                }
                function Mo(t, e) {
                    var n = t.__preset_select[t.__preset_select.selectedIndex];
                    n.innerHTML = e ? n.value + "*" : n.value;
                }
                function Ao(t, e) {
                    var n = t.getRoot(),
                        i = n.__rememberedObjects.indexOf(e.object);
                    if (-1 !== i) {
                        var r = n.__rememberedObjectIndecesToControllers[i];
                        if (
                            (void 0 === r &&
                                ((r = {}),
                                (n.__rememberedObjectIndecesToControllers[i] =
                                    r)),
                            (r[e.property] = e),
                            n.load && n.load.remembered)
                        ) {
                            var a = n.load.remembered,
                                s = void 0;
                            if (a[t.preset]) s = a[t.preset];
                            else {
                                if (!a[uo]) return;
                                s = a[uo];
                            }
                            if (s[i] && void 0 !== s[i][e.property]) {
                                var o = s[i][e.property];
                                (e.initialValue = o), e.setValue(o);
                            }
                        }
                    }
                }
                function _o(t, e, n, i) {
                    if (void 0 === e[n])
                        throw new Error(
                            'Object "' + e + '" has no property "' + n + '"',
                        );
                    var r = void 0;
                    if (i.color) r = new ro(e, n);
                    else {
                        var a = [e, n].concat(i.factoryArgs);
                        r = lo.apply(t, a);
                    }
                    i.before instanceof zs && (i.before = i.before.__li),
                        Ao(t, r),
                        Ks.addClass(r.domElement, "c");
                    var s = document.createElement("span");
                    Ks.addClass(s, "property-name"), (s.innerHTML = r.property);
                    var o = document.createElement("div");
                    o.appendChild(s), o.appendChild(r.domElement);
                    var l = yo(t, o, i.before);
                    return (
                        Ks.addClass(l, bo.CLASS_CONTROLLER_ROW),
                        r instanceof ro
                            ? Ks.addClass(l, "color")
                            : Ks.addClass(l, Ps(r.getValue())),
                        (function (t, e, n) {
                            if (
                                ((n.__li = e),
                                (n.__gui = t),
                                Rs.extend(n, {
                                    options: function (e) {
                                        if (arguments.length > 1) {
                                            var i = n.__li.nextElementSibling;
                                            return (
                                                n.remove(),
                                                _o(t, n.object, n.property, {
                                                    before: i,
                                                    factoryArgs: [
                                                        Rs.toArray(arguments),
                                                    ],
                                                })
                                            );
                                        }
                                        if (Rs.isArray(e) || Rs.isObject(e)) {
                                            var r = n.__li.nextElementSibling;
                                            return (
                                                n.remove(),
                                                _o(t, n.object, n.property, {
                                                    before: r,
                                                    factoryArgs: [e],
                                                })
                                            );
                                        }
                                    },
                                    name: function (t) {
                                        return (
                                            (n.__li.firstElementChild.firstElementChild.innerHTML =
                                                t),
                                            n
                                        );
                                    },
                                    listen: function () {
                                        return n.__gui.listen(n), n;
                                    },
                                    remove: function () {
                                        return n.__gui.remove(n), n;
                                    },
                                }),
                                n instanceof no)
                            ) {
                                var i = new to(n.object, n.property, {
                                    min: n.__min,
                                    max: n.__max,
                                    step: n.__step,
                                });
                                Rs.each(
                                    [
                                        "updateDisplay",
                                        "onChange",
                                        "onFinishChange",
                                        "step",
                                        "min",
                                        "max",
                                    ],
                                    function (t) {
                                        var e = n[t],
                                            r = i[t];
                                        n[t] = i[t] = function () {
                                            var t =
                                                Array.prototype.slice.call(
                                                    arguments,
                                                );
                                            return r.apply(i, t), e.apply(n, t);
                                        };
                                    },
                                ),
                                    Ks.addClass(e, "has-slider"),
                                    n.domElement.insertBefore(
                                        i.domElement,
                                        n.domElement.firstElementChild,
                                    );
                            } else if (n instanceof to) {
                                var r = function (e) {
                                    if (
                                        Rs.isNumber(n.__min) &&
                                        Rs.isNumber(n.__max)
                                    ) {
                                        var i =
                                                n.__li.firstElementChild
                                                    .firstElementChild
                                                    .innerHTML,
                                            r =
                                                n.__gui.__listening.indexOf(n) >
                                                -1;
                                        n.remove();
                                        var a = _o(t, n.object, n.property, {
                                            before: n.__li.nextElementSibling,
                                            factoryArgs: [
                                                n.__min,
                                                n.__max,
                                                n.__step,
                                            ],
                                        });
                                        return a.name(i), r && a.listen(), a;
                                    }
                                    return e;
                                };
                                (n.min = Rs.compose(r, n.min)),
                                    (n.max = Rs.compose(r, n.max));
                            } else
                                n instanceof Js
                                    ? (Ks.bind(e, "click", function () {
                                          Ks.fakeEvent(n.__checkbox, "click");
                                      }),
                                      Ks.bind(
                                          n.__checkbox,
                                          "click",
                                          function (t) {
                                              t.stopPropagation();
                                          },
                                      ))
                                    : n instanceof io
                                    ? (Ks.bind(e, "click", function () {
                                          Ks.fakeEvent(n.__button, "click");
                                      }),
                                      Ks.bind(e, "mouseover", function () {
                                          Ks.addClass(n.__button, "hover");
                                      }),
                                      Ks.bind(e, "mouseout", function () {
                                          Ks.removeClass(n.__button, "hover");
                                      }))
                                    : n instanceof ro &&
                                      (Ks.addClass(e, "color"),
                                      (n.updateDisplay = Rs.compose(function (
                                          t,
                                      ) {
                                          return (
                                              (e.style.borderLeftColor =
                                                  n.__color.toString()),
                                              t
                                          );
                                      }, n.updateDisplay)),
                                      n.updateDisplay());
                            n.setValue = Rs.compose(function (e) {
                                return (
                                    t.getRoot().__preset_select &&
                                        n.isModified() &&
                                        Mo(t.getRoot(), !0),
                                    e
                                );
                            }, n.setValue);
                        })(t, l, r),
                        t.__controllers.push(r),
                        r
                    );
                }
                function wo(t, e) {
                    return document.location.href + "." + e;
                }
                function To(t, e, n) {
                    var i = document.createElement("option");
                    (i.innerHTML = e),
                        (i.value = e),
                        t.__preset_select.appendChild(i),
                        n &&
                            (t.__preset_select.selectedIndex =
                                t.__preset_select.length - 1);
                }
                function Eo(t, e) {
                    e.style.display = t.useLocalStorage ? "block" : "none";
                }
                function Ro(t) {
                    var e = (t.__save_row = document.createElement("li"));
                    Ks.addClass(t.domElement, "has-save"),
                        t.__ul.insertBefore(e, t.__ul.firstChild),
                        Ks.addClass(e, "save-row");
                    var n = document.createElement("span");
                    (n.innerHTML = "&nbsp;"), Ks.addClass(n, "button gears");
                    var i = document.createElement("span");
                    (i.innerHTML = "Save"),
                        Ks.addClass(i, "button"),
                        Ks.addClass(i, "save");
                    var r = document.createElement("span");
                    (r.innerHTML = "New"),
                        Ks.addClass(r, "button"),
                        Ks.addClass(r, "save-as");
                    var a = document.createElement("span");
                    (a.innerHTML = "Revert"),
                        Ks.addClass(a, "button"),
                        Ks.addClass(a, "revert");
                    var s = (t.__preset_select =
                        document.createElement("select"));
                    if (
                        (t.load && t.load.remembered
                            ? Rs.each(t.load.remembered, function (e, n) {
                                  To(t, n, n === t.preset);
                              })
                            : To(t, uo, !1),
                        Ks.bind(s, "change", function () {
                            for (var e = 0; e < t.__preset_select.length; e++)
                                t.__preset_select[e].innerHTML =
                                    t.__preset_select[e].value;
                            t.preset = this.value;
                        }),
                        e.appendChild(s),
                        e.appendChild(n),
                        e.appendChild(i),
                        e.appendChild(r),
                        e.appendChild(a),
                        po)
                    ) {
                        var o = document.getElementById("dg-local-explain"),
                            l = document.getElementById("dg-local-storage");
                        (document.getElementById(
                            "dg-save-locally",
                        ).style.display = "block"),
                            "true" === localStorage.getItem(wo(0, "isLocal")) &&
                                l.setAttribute("checked", "checked"),
                            Eo(t, o),
                            Ks.bind(l, "change", function () {
                                (t.useLocalStorage = !t.useLocalStorage),
                                    Eo(t, o);
                            });
                    }
                    var c = document.getElementById("dg-new-constructor");
                    Ks.bind(c, "keydown", function (t) {
                        !t.metaKey ||
                            (67 !== t.which && 67 !== t.keyCode) ||
                            fo.hide();
                    }),
                        Ks.bind(n, "click", function () {
                            (c.innerHTML = JSON.stringify(
                                t.getSaveObject(),
                                void 0,
                                2,
                            )),
                                fo.show(),
                                c.focus(),
                                c.select();
                        }),
                        Ks.bind(i, "click", function () {
                            t.save();
                        }),
                        Ks.bind(r, "click", function () {
                            var e = prompt("Enter a new preset name.");
                            e && t.saveAs(e);
                        }),
                        Ks.bind(a, "click", function () {
                            t.revert();
                        });
                }
                function ko(t) {
                    var e = void 0;
                    function n(n) {
                        return (
                            n.preventDefault(),
                            (t.width += e - n.clientX),
                            t.onResize(),
                            (e = n.clientX),
                            !1
                        );
                    }
                    function i() {
                        Ks.removeClass(t.__closeButton, bo.CLASS_DRAG),
                            Ks.unbind(window, "mousemove", n),
                            Ks.unbind(window, "mouseup", i);
                    }
                    function r(r) {
                        return (
                            r.preventDefault(),
                            (e = r.clientX),
                            Ks.addClass(t.__closeButton, bo.CLASS_DRAG),
                            Ks.bind(window, "mousemove", n),
                            Ks.bind(window, "mouseup", i),
                            !1
                        );
                    }
                    (t.__resize_handle = document.createElement("div")),
                        Rs.extend(t.__resize_handle.style, {
                            width: "6px",
                            marginLeft: "-3px",
                            height: "200px",
                            cursor: "ew-resize",
                            position: "absolute",
                        }),
                        Ks.bind(t.__resize_handle, "mousedown", r),
                        Ks.bind(t.__closeButton, "mousedown", r),
                        t.domElement.insertBefore(
                            t.__resize_handle,
                            t.domElement.firstElementChild,
                        );
                }
                function Co(t, e) {
                    (t.domElement.style.width = e + "px"),
                        t.__save_row &&
                            t.autoPlace &&
                            (t.__save_row.style.width = e + "px"),
                        t.__closeButton &&
                            (t.__closeButton.style.width = e + "px");
                }
                function Lo(t, e) {
                    var n = {};
                    return (
                        Rs.each(t.__rememberedObjects, function (i, r) {
                            var a = {},
                                s = t.__rememberedObjectIndecesToControllers[r];
                            Rs.each(s, function (t, n) {
                                a[n] = e ? t.initialValue : t.getValue();
                            }),
                                (n[r] = a);
                        }),
                        n
                    );
                }
                function Io(t) {
                    0 !== t.length &&
                        co.call(window, function () {
                            Io(t);
                        }),
                        Rs.each(t, function (t) {
                            t.updateDisplay();
                        });
                }
                (bo.toggleHide = function () {
                    (vo = !vo),
                        Rs.each(xo, function (t) {
                            t.domElement.style.display = vo ? "none" : "";
                        });
                }),
                    (bo.CLASS_AUTO_PLACE = "a"),
                    (bo.CLASS_AUTO_PLACE_CONTAINER = "ac"),
                    (bo.CLASS_MAIN = "main"),
                    (bo.CLASS_CONTROLLER_ROW = "cr"),
                    (bo.CLASS_TOO_TALL = "taller-than-window"),
                    (bo.CLASS_CLOSED = "closed"),
                    (bo.CLASS_CLOSE_BUTTON = "close-button"),
                    (bo.CLASS_CLOSE_TOP = "close-top"),
                    (bo.CLASS_CLOSE_BOTTOM = "close-bottom"),
                    (bo.CLASS_DRAG = "drag"),
                    (bo.DEFAULT_WIDTH = 245),
                    (bo.TEXT_CLOSED = "Close Controls"),
                    (bo.TEXT_OPEN = "Open Controls"),
                    (bo._keydownHandler = function (t) {
                        "text" === document.activeElement.type ||
                            (72 !== t.which && 72 !== t.keyCode) ||
                            bo.toggleHide();
                    }),
                    Ks.bind(window, "keydown", bo._keydownHandler, !1),
                    Rs.extend(bo.prototype, {
                        add: function (t, e) {
                            return _o(this, t, e, {
                                factoryArgs: Array.prototype.slice.call(
                                    arguments,
                                    2,
                                ),
                            });
                        },
                        addColor: function (t, e) {
                            return _o(this, t, e, { color: !0 });
                        },
                        remove: function (t) {
                            this.__ul.removeChild(t.__li),
                                this.__controllers.splice(
                                    this.__controllers.indexOf(t),
                                    1,
                                );
                            var e = this;
                            Rs.defer(function () {
                                e.onResize();
                            });
                        },
                        destroy: function () {
                            if (this.parent)
                                throw new Error(
                                    "Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.",
                                );
                            this.autoPlace && go.removeChild(this.domElement);
                            var t = this;
                            Rs.each(this.__folders, function (e) {
                                t.removeFolder(e);
                            }),
                                Ks.unbind(
                                    window,
                                    "keydown",
                                    bo._keydownHandler,
                                    !1,
                                ),
                                So(this);
                        },
                        addFolder: function (t) {
                            if (void 0 !== this.__folders[t])
                                throw new Error(
                                    'You already have a folder in this GUI by the name "' +
                                        t +
                                        '"',
                                );
                            var e = { name: t, parent: this };
                            (e.autoPlace = this.autoPlace),
                                this.load &&
                                    this.load.folders &&
                                    this.load.folders[t] &&
                                    ((e.closed = this.load.folders[t].closed),
                                    (e.load = this.load.folders[t]));
                            var n = new bo(e);
                            this.__folders[t] = n;
                            var i = yo(this, n.domElement);
                            return Ks.addClass(i, "folder"), n;
                        },
                        removeFolder: function (t) {
                            this.__ul.removeChild(t.domElement.parentElement),
                                delete this.__folders[t.name],
                                this.load &&
                                    this.load.folders &&
                                    this.load.folders[t.name] &&
                                    delete this.load.folders[t.name],
                                So(t);
                            var e = this;
                            Rs.each(t.__folders, function (e) {
                                t.removeFolder(e);
                            }),
                                Rs.defer(function () {
                                    e.onResize();
                                });
                        },
                        open: function () {
                            this.closed = !1;
                        },
                        close: function () {
                            this.closed = !0;
                        },
                        hide: function () {
                            this.domElement.style.display = "none";
                        },
                        show: function () {
                            this.domElement.style.display = "";
                        },
                        onResize: function () {
                            var t = this.getRoot();
                            if (t.scrollable) {
                                var e = Ks.getOffset(t.__ul).top,
                                    n = 0;
                                Rs.each(t.__ul.childNodes, function (e) {
                                    (t.autoPlace && e === t.__save_row) ||
                                        (n += Ks.getHeight(e));
                                }),
                                    window.innerHeight - e - 20 < n
                                        ? (Ks.addClass(
                                              t.domElement,
                                              bo.CLASS_TOO_TALL,
                                          ),
                                          (t.__ul.style.height =
                                              window.innerHeight -
                                              e -
                                              20 +
                                              "px"))
                                        : (Ks.removeClass(
                                              t.domElement,
                                              bo.CLASS_TOO_TALL,
                                          ),
                                          (t.__ul.style.height = "auto"));
                            }
                            t.__resize_handle &&
                                Rs.defer(function () {
                                    t.__resize_handle.style.height =
                                        t.__ul.offsetHeight + "px";
                                }),
                                t.__closeButton &&
                                    (t.__closeButton.style.width =
                                        t.width + "px");
                        },
                        onResizeDebounced: Rs.debounce(function () {
                            this.onResize();
                        }, 50),
                        remember: function () {
                            if (
                                (Rs.isUndefined(fo) &&
                                    ((fo = new ho()).domElement.innerHTML = oo),
                                this.parent)
                            )
                                throw new Error(
                                    "You can only call remember on a top level GUI.",
                                );
                            var t = this;
                            Rs.each(
                                Array.prototype.slice.call(arguments),
                                function (e) {
                                    0 === t.__rememberedObjects.length && Ro(t),
                                        -1 ===
                                            t.__rememberedObjects.indexOf(e) &&
                                            t.__rememberedObjects.push(e);
                                },
                            ),
                                this.autoPlace && Co(this, this.width);
                        },
                        getRoot: function () {
                            for (var t = this; t.parent; ) t = t.parent;
                            return t;
                        },
                        getSaveObject: function () {
                            var t = this.load;
                            return (
                                (t.closed = this.closed),
                                this.__rememberedObjects.length > 0 &&
                                    ((t.preset = this.preset),
                                    t.remembered || (t.remembered = {}),
                                    (t.remembered[this.preset] = Lo(this))),
                                (t.folders = {}),
                                Rs.each(this.__folders, function (e, n) {
                                    t.folders[n] = e.getSaveObject();
                                }),
                                t
                            );
                        },
                        save: function () {
                            this.load.remembered || (this.load.remembered = {}),
                                (this.load.remembered[this.preset] = Lo(this)),
                                Mo(this, !1),
                                this.saveToLocalStorageIfPossible();
                        },
                        saveAs: function (t) {
                            this.load.remembered ||
                                ((this.load.remembered = {}),
                                (this.load.remembered[uo] = Lo(this, !0))),
                                (this.load.remembered[t] = Lo(this)),
                                (this.preset = t),
                                To(this, t, !0),
                                this.saveToLocalStorageIfPossible();
                        },
                        revert: function (t) {
                            Rs.each(
                                this.__controllers,
                                function (e) {
                                    this.getRoot().load.remembered
                                        ? Ao(t || this.getRoot(), e)
                                        : e.setValue(e.initialValue),
                                        e.__onFinishChange &&
                                            e.__onFinishChange.call(
                                                e,
                                                e.getValue(),
                                            );
                                },
                                this,
                            ),
                                Rs.each(this.__folders, function (t) {
                                    t.revert(t);
                                }),
                                t || Mo(this.getRoot(), !1);
                        },
                        listen: function (t) {
                            var e = 0 === this.__listening.length;
                            this.__listening.push(t), e && Io(this.__listening);
                        },
                        updateDisplay: function () {
                            Rs.each(this.__controllers, function (t) {
                                t.updateDisplay();
                            }),
                                Rs.each(this.__folders, function (t) {
                                    t.updateDisplay();
                                });
                        },
                    });
                var Oo = bo;
                class Do {
                    constructor(t = "", e = {}) {
                        (this.baseUrl = t),
                            (this.options = e),
                            (this.materialsInfo = {}),
                            (this.materials = {}),
                            (this.materialsArray = []),
                            (this.nameLookup = {}),
                            (this.crossOrigin = "anonymous"),
                            (this.side =
                                void 0 !== this.options.side
                                    ? this.options.side
                                    : 0),
                            (this.wrap =
                                void 0 !== this.options.wrap
                                    ? this.options.wrap
                                    : a);
                    }
                    setCrossOrigin(t) {
                        return (this.crossOrigin = t), this;
                    }
                    setManager(t) {
                        this.manager = t;
                    }
                    setMaterials(t) {
                        (this.materialsInfo = this.convert(t)),
                            (this.materials = {}),
                            (this.materialsArray = []),
                            (this.nameLookup = {});
                    }
                    convert(t) {
                        if (!this.options) return t;
                        const e = {};
                        for (const n in t) {
                            const i = t[n],
                                r = {};
                            e[n] = r;
                            for (const t in i) {
                                let e = !0,
                                    n = i[t];
                                const a = t.toLowerCase();
                                switch (a) {
                                    case "kd":
                                    case "ka":
                                    case "ks":
                                        this.options &&
                                            this.options.normalizeRGB &&
                                            (n = [
                                                n[0] / 255,
                                                n[1] / 255,
                                                n[2] / 255,
                                            ]),
                                            this.options &&
                                                this.options.ignoreZeroRGBs &&
                                                0 === n[0] &&
                                                0 === n[1] &&
                                                0 === n[2] &&
                                                (e = !1);
                                }
                                e && (r[a] = n);
                            }
                        }
                        return e;
                    }
                    preload() {
                        for (const t in this.materialsInfo) this.create(t);
                    }
                    getIndex(t) {
                        return this.nameLookup[t];
                    }
                    getAsArray() {
                        let t = 0;
                        for (const e in this.materialsInfo)
                            (this.materialsArray[t] = this.create(e)),
                                (this.nameLookup[e] = t),
                                t++;
                        return this.materialsArray;
                    }
                    create(t) {
                        return (
                            void 0 === this.materials[t] &&
                                this.createMaterial_(t),
                            this.materials[t]
                        );
                    }
                    createMaterial_(t) {
                        const e = this,
                            n = this.materialsInfo[t],
                            i = { name: t, side: this.side };
                        function r(t, n) {
                            if (i[t]) return;
                            const r = e.getTextureParams(n, i),
                                a = e.loadTexture(
                                    ((s = e.baseUrl),
                                    "string" != typeof (o = r.url) || "" === o
                                        ? ""
                                        : /^https?:\/\//i.test(o)
                                        ? o
                                        : s + o),
                                );
                            var s, o;
                            a.repeat.copy(r.scale),
                                a.offset.copy(r.offset),
                                (a.wrapS = e.wrap),
                                (a.wrapT = e.wrap),
                                ("map" !== t && "emissiveMap" !== t) ||
                                    (a.encoding = L),
                                (i[t] = a);
                        }
                        for (const t in n) {
                            const e = n[t];
                            let a;
                            if ("" !== e)
                                switch (t.toLowerCase()) {
                                    case "kd":
                                        i.color = new ct()
                                            .fromArray(e)
                                            .convertSRGBToLinear();
                                        break;
                                    case "ks":
                                        i.specular = new ct()
                                            .fromArray(e)
                                            .convertSRGBToLinear();
                                        break;
                                    case "ke":
                                        i.emissive = new ct()
                                            .fromArray(e)
                                            .convertSRGBToLinear();
                                        break;
                                    case "map_kd":
                                        r("map", e);
                                        break;
                                    case "map_ks":
                                        r("specularMap", e);
                                        break;
                                    case "map_ke":
                                        r("emissiveMap", e);
                                        break;
                                    case "norm":
                                        r("normalMap", e);
                                        break;
                                    case "map_bump":
                                    case "bump":
                                        r("bumpMap", e);
                                        break;
                                    case "map_d":
                                        r("alphaMap", e), (i.transparent = !0);
                                        break;
                                    case "ns":
                                        i.shininess = parseFloat(e);
                                        break;
                                    case "d":
                                        (a = parseFloat(e)),
                                            a < 1 &&
                                                ((i.opacity = a),
                                                (i.transparent = !0));
                                        break;
                                    case "tr":
                                        (a = parseFloat(e)),
                                            this.options &&
                                                this.options.invertTrProperty &&
                                                (a = 1 - a),
                                            a > 0 &&
                                                ((i.opacity = 1 - a),
                                                (i.transparent = !0));
                                }
                        }
                        return (
                            (this.materials[t] = new Ta(i)), this.materials[t]
                        );
                    }
                    getTextureParams(t, e) {
                        const n = { scale: new K(1, 1), offset: new K(0, 0) },
                            i = t.split(/\s+/);
                        let r;
                        return (
                            (r = i.indexOf("-bm")),
                            r >= 0 &&
                                ((e.bumpScale = parseFloat(i[r + 1])),
                                i.splice(r, 2)),
                            (r = i.indexOf("-s")),
                            r >= 0 &&
                                (n.scale.set(
                                    parseFloat(i[r + 1]),
                                    parseFloat(i[r + 2]),
                                ),
                                i.splice(r, 4)),
                            (r = i.indexOf("-o")),
                            r >= 0 &&
                                (n.offset.set(
                                    parseFloat(i[r + 1]),
                                    parseFloat(i[r + 2]),
                                ),
                                i.splice(r, 4)),
                            (n.url = i.join(" ").trim()),
                            n
                        );
                    }
                    loadTexture(t, e, n, i, r) {
                        const a = void 0 !== this.manager ? this.manager : Ja;
                        let s = a.getHandler(t);
                        null === s && (s = new es(a)),
                            s.setCrossOrigin &&
                                s.setCrossOrigin(this.crossOrigin);
                        const o = s.load(t, n, i, r);
                        return void 0 !== e && (o.mapping = e), o;
                    }
                }
                const Po = /^[og]\s*(.+)?/,
                    Uo = /^mtllib /,
                    Vo = /^usemtl /,
                    No = /^usemap /,
                    Go = /\s+/,
                    jo = new St(),
                    Ho = new St(),
                    Fo = new St(),
                    Bo = new St(),
                    zo = new St(),
                    Wo = new ct();
                function qo() {
                    const t = {
                        objects: [],
                        object: {},
                        vertices: [],
                        normals: [],
                        colors: [],
                        uvs: [],
                        materials: {},
                        materialLibraries: [],
                        startObject: function (t, e) {
                            if (
                                this.object &&
                                !1 === this.object.fromDeclaration
                            )
                                return (
                                    (this.object.name = t),
                                    void (this.object.fromDeclaration =
                                        !1 !== e)
                                );
                            const n =
                                this.object &&
                                "function" == typeof this.object.currentMaterial
                                    ? this.object.currentMaterial()
                                    : void 0;
                            if (
                                (this.object &&
                                    "function" ==
                                        typeof this.object._finalize &&
                                    this.object._finalize(!0),
                                (this.object = {
                                    name: t || "",
                                    fromDeclaration: !1 !== e,
                                    geometry: {
                                        vertices: [],
                                        normals: [],
                                        colors: [],
                                        uvs: [],
                                        hasUVIndices: !1,
                                    },
                                    materials: [],
                                    smooth: !0,
                                    startMaterial: function (t, e) {
                                        const n = this._finalize(!1);
                                        n &&
                                            (n.inherited ||
                                                n.groupCount <= 0) &&
                                            this.materials.splice(n.index, 1);
                                        const i = {
                                            index: this.materials.length,
                                            name: t || "",
                                            mtllib:
                                                Array.isArray(e) && e.length > 0
                                                    ? e[e.length - 1]
                                                    : "",
                                            smooth:
                                                void 0 !== n
                                                    ? n.smooth
                                                    : this.smooth,
                                            groupStart:
                                                void 0 !== n ? n.groupEnd : 0,
                                            groupEnd: -1,
                                            groupCount: -1,
                                            inherited: !1,
                                            clone: function (t) {
                                                const e = {
                                                    index:
                                                        "number" == typeof t
                                                            ? t
                                                            : this.index,
                                                    name: this.name,
                                                    mtllib: this.mtllib,
                                                    smooth: this.smooth,
                                                    groupStart: 0,
                                                    groupEnd: -1,
                                                    groupCount: -1,
                                                    inherited: !1,
                                                };
                                                return (
                                                    (e.clone =
                                                        this.clone.bind(e)),
                                                    e
                                                );
                                            },
                                        };
                                        return this.materials.push(i), i;
                                    },
                                    currentMaterial: function () {
                                        if (this.materials.length > 0)
                                            return this.materials[
                                                this.materials.length - 1
                                            ];
                                    },
                                    _finalize: function (t) {
                                        const e = this.currentMaterial();
                                        if (
                                            (e &&
                                                -1 === e.groupEnd &&
                                                ((e.groupEnd =
                                                    this.geometry.vertices
                                                        .length / 3),
                                                (e.groupCount =
                                                    e.groupEnd - e.groupStart),
                                                (e.inherited = !1)),
                                            t && this.materials.length > 1)
                                        )
                                            for (
                                                let t =
                                                    this.materials.length - 1;
                                                t >= 0;
                                                t--
                                            )
                                                this.materials[t].groupCount <=
                                                    0 &&
                                                    this.materials.splice(t, 1);
                                        return (
                                            t &&
                                                0 === this.materials.length &&
                                                this.materials.push({
                                                    name: "",
                                                    smooth: this.smooth,
                                                }),
                                            e
                                        );
                                    },
                                }),
                                n && n.name && "function" == typeof n.clone)
                            ) {
                                const t = n.clone(0);
                                (t.inherited = !0),
                                    this.object.materials.push(t);
                            }
                            this.objects.push(this.object);
                        },
                        finalize: function () {
                            this.object &&
                                "function" == typeof this.object._finalize &&
                                this.object._finalize(!0);
                        },
                        parseVertexIndex: function (t, e) {
                            const n = parseInt(t, 10);
                            return 3 * (n >= 0 ? n - 1 : n + e / 3);
                        },
                        parseNormalIndex: function (t, e) {
                            const n = parseInt(t, 10);
                            return 3 * (n >= 0 ? n - 1 : n + e / 3);
                        },
                        parseUVIndex: function (t, e) {
                            const n = parseInt(t, 10);
                            return 2 * (n >= 0 ? n - 1 : n + e / 2);
                        },
                        addVertex: function (t, e, n) {
                            const i = this.vertices,
                                r = this.object.geometry.vertices;
                            r.push(i[t + 0], i[t + 1], i[t + 2]),
                                r.push(i[e + 0], i[e + 1], i[e + 2]),
                                r.push(i[n + 0], i[n + 1], i[n + 2]);
                        },
                        addVertexPoint: function (t) {
                            const e = this.vertices;
                            this.object.geometry.vertices.push(
                                e[t + 0],
                                e[t + 1],
                                e[t + 2],
                            );
                        },
                        addVertexLine: function (t) {
                            const e = this.vertices;
                            this.object.geometry.vertices.push(
                                e[t + 0],
                                e[t + 1],
                                e[t + 2],
                            );
                        },
                        addNormal: function (t, e, n) {
                            const i = this.normals,
                                r = this.object.geometry.normals;
                            r.push(i[t + 0], i[t + 1], i[t + 2]),
                                r.push(i[e + 0], i[e + 1], i[e + 2]),
                                r.push(i[n + 0], i[n + 1], i[n + 2]);
                        },
                        addFaceNormal: function (t, e, n) {
                            const i = this.vertices,
                                r = this.object.geometry.normals;
                            jo.fromArray(i, t),
                                Ho.fromArray(i, e),
                                Fo.fromArray(i, n),
                                zo.subVectors(Fo, Ho),
                                Bo.subVectors(jo, Ho),
                                zo.cross(Bo),
                                zo.normalize(),
                                r.push(zo.x, zo.y, zo.z),
                                r.push(zo.x, zo.y, zo.z),
                                r.push(zo.x, zo.y, zo.z);
                        },
                        addColor: function (t, e, n) {
                            const i = this.colors,
                                r = this.object.geometry.colors;
                            void 0 !== i[t] &&
                                r.push(i[t + 0], i[t + 1], i[t + 2]),
                                void 0 !== i[e] &&
                                    r.push(i[e + 0], i[e + 1], i[e + 2]),
                                void 0 !== i[n] &&
                                    r.push(i[n + 0], i[n + 1], i[n + 2]);
                        },
                        addUV: function (t, e, n) {
                            const i = this.uvs,
                                r = this.object.geometry.uvs;
                            r.push(i[t + 0], i[t + 1]),
                                r.push(i[e + 0], i[e + 1]),
                                r.push(i[n + 0], i[n + 1]);
                        },
                        addDefaultUV: function () {
                            const t = this.object.geometry.uvs;
                            t.push(0, 0), t.push(0, 0), t.push(0, 0);
                        },
                        addUVLine: function (t) {
                            const e = this.uvs;
                            this.object.geometry.uvs.push(e[t + 0], e[t + 1]);
                        },
                        addFace: function (t, e, n, i, r, a, s, o, l) {
                            const c = this.vertices.length;
                            let h = this.parseVertexIndex(t, c),
                                u = this.parseVertexIndex(e, c),
                                d = this.parseVertexIndex(n, c);
                            if (
                                (this.addVertex(h, u, d),
                                this.addColor(h, u, d),
                                void 0 !== s && "" !== s)
                            ) {
                                const t = this.normals.length;
                                (h = this.parseNormalIndex(s, t)),
                                    (u = this.parseNormalIndex(o, t)),
                                    (d = this.parseNormalIndex(l, t)),
                                    this.addNormal(h, u, d);
                            } else this.addFaceNormal(h, u, d);
                            if (void 0 !== i && "" !== i) {
                                const t = this.uvs.length;
                                (h = this.parseUVIndex(i, t)),
                                    (u = this.parseUVIndex(r, t)),
                                    (d = this.parseUVIndex(a, t)),
                                    this.addUV(h, u, d),
                                    (this.object.geometry.hasUVIndices = !0);
                            } else this.addDefaultUV();
                        },
                        addPointGeometry: function (t) {
                            this.object.geometry.type = "Points";
                            const e = this.vertices.length;
                            for (let n = 0, i = t.length; n < i; n++) {
                                const i = this.parseVertexIndex(t[n], e);
                                this.addVertexPoint(i), this.addColor(i);
                            }
                        },
                        addLineGeometry: function (t, e) {
                            this.object.geometry.type = "Line";
                            const n = this.vertices.length,
                                i = this.uvs.length;
                            for (let e = 0, i = t.length; e < i; e++)
                                this.addVertexLine(
                                    this.parseVertexIndex(t[e], n),
                                );
                            for (let t = 0, n = e.length; t < n; t++)
                                this.addUVLine(this.parseUVIndex(e[t], i));
                        },
                    };
                    return t.startObject("", !1), t;
                }
                const Yo = new (class extends Za {
                        constructor(t) {
                            super(t);
                        }
                        load(t, e, n, i) {
                            const r = this,
                                a =
                                    "" === this.path
                                        ? ls.extractUrlBase(t)
                                        : this.path,
                                s = new $a(this.manager);
                            s.setPath(this.path),
                                s.setRequestHeader(this.requestHeader),
                                s.setWithCredentials(this.withCredentials),
                                s.load(
                                    t,
                                    function (n) {
                                        try {
                                            e(r.parse(n, a));
                                        } catch (e) {
                                            i ? i(e) : console.error(e),
                                                r.manager.itemError(t);
                                        }
                                    },
                                    n,
                                    i,
                                );
                        }
                        setMaterialOptions(t) {
                            return (this.materialOptions = t), this;
                        }
                        parse(t, e) {
                            const n = t.split("\n");
                            let i = {};
                            const r = /\s+/,
                                a = {};
                            for (let t = 0; t < n.length; t++) {
                                let e = n[t];
                                if (
                                    ((e = e.trim()),
                                    0 === e.length || "#" === e.charAt(0))
                                )
                                    continue;
                                const s = e.indexOf(" ");
                                let o = s >= 0 ? e.substring(0, s) : e;
                                o = o.toLowerCase();
                                let l = s >= 0 ? e.substring(s + 1) : "";
                                if (((l = l.trim()), "newmtl" === o))
                                    (i = { name: l }), (a[l] = i);
                                else if (
                                    "ka" === o ||
                                    "kd" === o ||
                                    "ks" === o ||
                                    "ke" === o
                                ) {
                                    const t = l.split(r, 3);
                                    i[o] = [
                                        parseFloat(t[0]),
                                        parseFloat(t[1]),
                                        parseFloat(t[2]),
                                    ];
                                } else i[o] = l;
                            }
                            const s = new Do(
                                this.resourcePath || e,
                                this.materialOptions,
                            );
                            return (
                                s.setCrossOrigin(this.crossOrigin),
                                s.setManager(this.manager),
                                s.setMaterials(a),
                                s
                            );
                        }
                    })(),
                    Ko = new (class extends Za {
                        constructor(t) {
                            super(t), (this.materials = null);
                        }
                        load(t, e, n, i) {
                            const r = this,
                                a = new $a(this.manager);
                            a.setPath(this.path),
                                a.setRequestHeader(this.requestHeader),
                                a.setWithCredentials(this.withCredentials),
                                a.load(
                                    t,
                                    function (n) {
                                        try {
                                            e(r.parse(n));
                                        } catch (e) {
                                            i ? i(e) : console.error(e),
                                                r.manager.itemError(t);
                                        }
                                    },
                                    n,
                                    i,
                                );
                        }
                        setMaterials(t) {
                            return (this.materials = t), this;
                        }
                        parse(t) {
                            const e = new qo();
                            -1 !== t.indexOf("\r\n") &&
                                (t = t.replace(/\r\n/g, "\n")),
                                -1 !== t.indexOf("\\\n") &&
                                    (t = t.replace(/\\\n/g, ""));
                            const n = t.split("\n");
                            let i = [];
                            for (let t = 0, r = n.length; t < r; t++) {
                                const r = n[t].trimStart();
                                if (0 === r.length) continue;
                                const a = r.charAt(0);
                                if ("#" !== a)
                                    if ("v" === a) {
                                        const t = r.split(Go);
                                        switch (t[0]) {
                                            case "v":
                                                e.vertices.push(
                                                    parseFloat(t[1]),
                                                    parseFloat(t[2]),
                                                    parseFloat(t[3]),
                                                ),
                                                    t.length >= 7
                                                        ? (Wo.setRGB(
                                                              parseFloat(t[4]),
                                                              parseFloat(t[5]),
                                                              parseFloat(t[6]),
                                                          ).convertSRGBToLinear(),
                                                          e.colors.push(
                                                              Wo.r,
                                                              Wo.g,
                                                              Wo.b,
                                                          ))
                                                        : e.colors.push(
                                                              void 0,
                                                              void 0,
                                                              void 0,
                                                          );
                                                break;
                                            case "vn":
                                                e.normals.push(
                                                    parseFloat(t[1]),
                                                    parseFloat(t[2]),
                                                    parseFloat(t[3]),
                                                );
                                                break;
                                            case "vt":
                                                e.uvs.push(
                                                    parseFloat(t[1]),
                                                    parseFloat(t[2]),
                                                );
                                        }
                                    } else if ("f" === a) {
                                        const t = r.slice(1).trim().split(Go),
                                            n = [];
                                        for (
                                            let e = 0, i = t.length;
                                            e < i;
                                            e++
                                        ) {
                                            const i = t[e];
                                            if (i.length > 0) {
                                                const t = i.split("/");
                                                n.push(t);
                                            }
                                        }
                                        const i = n[0];
                                        for (
                                            let t = 1, r = n.length - 1;
                                            t < r;
                                            t++
                                        ) {
                                            const r = n[t],
                                                a = n[t + 1];
                                            e.addFace(
                                                i[0],
                                                r[0],
                                                a[0],
                                                i[1],
                                                r[1],
                                                a[1],
                                                i[2],
                                                r[2],
                                                a[2],
                                            );
                                        }
                                    } else if ("l" === a) {
                                        const t = r
                                            .substring(1)
                                            .trim()
                                            .split(" ");
                                        let n = [];
                                        const i = [];
                                        if (-1 === r.indexOf("/")) n = t;
                                        else
                                            for (
                                                let e = 0, r = t.length;
                                                e < r;
                                                e++
                                            ) {
                                                const r = t[e].split("/");
                                                "" !== r[0] && n.push(r[0]),
                                                    "" !== r[1] && i.push(r[1]);
                                            }
                                        e.addLineGeometry(n, i);
                                    } else if ("p" === a) {
                                        const t = r.slice(1).trim().split(" ");
                                        e.addPointGeometry(t);
                                    } else if (null !== (i = Po.exec(r))) {
                                        const t = (
                                            " " + i[0].slice(1).trim()
                                        ).slice(1);
                                        e.startObject(t);
                                    } else if (Vo.test(r))
                                        e.object.startMaterial(
                                            r.substring(7).trim(),
                                            e.materialLibraries,
                                        );
                                    else if (Uo.test(r))
                                        e.materialLibraries.push(
                                            r.substring(7).trim(),
                                        );
                                    else if (No.test(r))
                                        console.warn(
                                            'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.',
                                        );
                                    else if ("s" === a) {
                                        if (
                                            ((i = r.split(" ")), i.length > 1)
                                        ) {
                                            const t = i[1].trim().toLowerCase();
                                            e.object.smooth =
                                                "0" !== t && "off" !== t;
                                        } else e.object.smooth = !0;
                                        const t = e.object.currentMaterial();
                                        t && (t.smooth = e.object.smooth);
                                    } else {
                                        if ("\0" === r) continue;
                                        console.warn(
                                            'THREE.OBJLoader: Unexpected line: "' +
                                                r +
                                                '"',
                                        );
                                    }
                            }
                            e.finalize();
                            const r = new ea();
                            if (
                                ((r.materialLibraries = [].concat(
                                    e.materialLibraries,
                                )),
                                !0 ==
                                    !(
                                        1 === e.objects.length &&
                                        0 ===
                                            e.objects[0].geometry.vertices
                                                .length
                                    ))
                            )
                                for (
                                    let t = 0, n = e.objects.length;
                                    t < n;
                                    t++
                                ) {
                                    const n = e.objects[t],
                                        i = n.geometry,
                                        a = n.materials,
                                        s = "Line" === i.type,
                                        o = "Points" === i.type;
                                    let l = !1;
                                    if (0 === i.vertices.length) continue;
                                    const c = new Ze();
                                    c.setAttribute(
                                        "position",
                                        new Fe(i.vertices, 3),
                                    ),
                                        i.normals.length > 0 &&
                                            c.setAttribute(
                                                "normal",
                                                new Fe(i.normals, 3),
                                            ),
                                        i.colors.length > 0 &&
                                            ((l = !0),
                                            c.setAttribute(
                                                "color",
                                                new Fe(i.colors, 3),
                                            )),
                                        !0 === i.hasUVIndices &&
                                            c.setAttribute(
                                                "uv",
                                                new Fe(i.uvs, 2),
                                            );
                                    const h = [];
                                    for (let t = 0, n = a.length; t < n; t++) {
                                        const n = a[t],
                                            i =
                                                n.name +
                                                "_" +
                                                n.smooth +
                                                "_" +
                                                l;
                                        let r = e.materials[i];
                                        if (null !== this.materials)
                                            if (
                                                ((r = this.materials.create(
                                                    n.name,
                                                )),
                                                !s || !r || r instanceof ca)
                                            ) {
                                                if (
                                                    o &&
                                                    r &&
                                                    !(r instanceof ba)
                                                ) {
                                                    const t = new ba({
                                                        size: 10,
                                                        sizeAttenuation: !1,
                                                    });
                                                    Pe.prototype.copy.call(
                                                        t,
                                                        r,
                                                    ),
                                                        t.color.copy(r.color),
                                                        (t.map = r.map),
                                                        (r = t);
                                                }
                                            } else {
                                                const t = new ca();
                                                Pe.prototype.copy.call(t, r),
                                                    t.color.copy(r.color),
                                                    (r = t);
                                            }
                                        void 0 === r &&
                                            ((r = s
                                                ? new ca()
                                                : o
                                                ? new ba({
                                                      size: 1,
                                                      sizeAttenuation: !1,
                                                  })
                                                : new Ta()),
                                            (r.name = n.name),
                                            (r.flatShading = !n.smooth),
                                            (r.vertexColors = l),
                                            (e.materials[i] = r)),
                                            h.push(r);
                                    }
                                    let u;
                                    if (h.length > 1) {
                                        for (
                                            let t = 0, e = a.length;
                                            t < e;
                                            t++
                                        ) {
                                            const e = a[t];
                                            c.addGroup(
                                                e.groupStart,
                                                e.groupCount,
                                                t,
                                            );
                                        }
                                        u = s
                                            ? new xa(c, h)
                                            : o
                                            ? new _a(c, h)
                                            : new un(c, h);
                                    } else
                                        u = s
                                            ? new xa(c, h[0])
                                            : o
                                            ? new _a(c, h[0])
                                            : new un(c, h[0]);
                                    (u.name = n.name), r.add(u);
                                }
                            else if (e.vertices.length > 0) {
                                const t = new ba({
                                        size: 1,
                                        sizeAttenuation: !1,
                                    }),
                                    n = new Ze();
                                n.setAttribute(
                                    "position",
                                    new Fe(e.vertices, 3),
                                ),
                                    e.colors.length > 0 &&
                                        void 0 !== e.colors[0] &&
                                        (n.setAttribute(
                                            "color",
                                            new Fe(e.colors, 3),
                                        ),
                                        (t.vertexColors = !0));
                                const i = new _a(n, t);
                                r.add(i);
                            }
                            return r;
                        }
                    })();
                var Jo = new la({ antialias: !0 });
                Jo.setSize(window.innerWidth, window.innerHeight),
                    document.body.appendChild(Jo.domElement);
                const Zo = new (class extends Me {
                    constructor() {
                        super(),
                            (this.isScene = !0),
                            (this.type = "Scene"),
                            (this.background = null),
                            (this.environment = null),
                            (this.fog = null),
                            (this.backgroundBlurriness = 0),
                            (this.backgroundIntensity = 1),
                            (this.overrideMaterial = null),
                            "undefined" != typeof __THREE_DEVTOOLS__ &&
                                __THREE_DEVTOOLS__.dispatchEvent(
                                    new CustomEvent("observe", {
                                        detail: this,
                                    }),
                                );
                    }
                    copy(t, e) {
                        return (
                            super.copy(t, e),
                            null !== t.background &&
                                (this.background = t.background.clone()),
                            null !== t.environment &&
                                (this.environment = t.environment.clone()),
                            null !== t.fog && (this.fog = t.fog.clone()),
                            (this.backgroundBlurriness =
                                t.backgroundBlurriness),
                            (this.backgroundIntensity = t.backgroundIntensity),
                            null !== t.overrideMaterial &&
                                (this.overrideMaterial =
                                    t.overrideMaterial.clone()),
                            (this.matrixAutoUpdate = t.matrixAutoUpdate),
                            this
                        );
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return (
                            null !== this.fog &&
                                (e.object.fog = this.fog.toJSON()),
                            this.backgroundBlurriness > 0 &&
                                (e.backgroundBlurriness =
                                    this.backgroundBlurriness),
                            1 !== this.backgroundIntensity &&
                                (e.backgroundIntensity =
                                    this.backgroundIntensity),
                            e
                        );
                    }
                    get autoUpdate() {
                        return (
                            console.warn(
                                "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.",
                            ),
                            this.matrixWorldAutoUpdate
                        );
                    }
                    set autoUpdate(t) {
                        console.warn(
                            "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.",
                        ),
                            (this.matrixWorldAutoUpdate = t);
                    }
                })();
                var Xo = new yn(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1e3,
                );
                Xo.position.z = 25;
                const Qo = new (class extends V {
                        constructor(t, e) {
                            super(),
                                (this.object = t),
                                (this.domElement = e),
                                (this.domElement.style.touchAction = "none"),
                                (this.enabled = !0),
                                (this.target = new St()),
                                (this.minDistance = 0),
                                (this.maxDistance = 1 / 0),
                                (this.minZoom = 0),
                                (this.maxZoom = 1 / 0),
                                (this.minPolarAngle = 0),
                                (this.maxPolarAngle = Math.PI),
                                (this.minAzimuthAngle = -1 / 0),
                                (this.maxAzimuthAngle = 1 / 0),
                                (this.enableDamping = !1),
                                (this.dampingFactor = 0.05),
                                (this.enableZoom = !0),
                                (this.zoomSpeed = 1),
                                (this.enableRotate = !0),
                                (this.rotateSpeed = 1),
                                (this.enablePan = !0),
                                (this.panSpeed = 1),
                                (this.screenSpacePanning = !0),
                                (this.keyPanSpeed = 7),
                                (this.autoRotate = !1),
                                (this.autoRotateSpeed = 2),
                                (this.keys = {
                                    LEFT: "ArrowLeft",
                                    UP: "ArrowUp",
                                    RIGHT: "ArrowRight",
                                    BOTTOM: "ArrowDown",
                                }),
                                (this.mouseButtons = {
                                    LEFT: 0,
                                    MIDDLE: 1,
                                    RIGHT: 2,
                                }),
                                (this.touches = { ONE: 0, TWO: 2 }),
                                (this.target0 = this.target.clone()),
                                (this.position0 = this.object.position.clone()),
                                (this.zoom0 = this.object.zoom),
                                (this._domElementKeyEvents = null),
                                (this.getPolarAngle = function () {
                                    return s.phi;
                                }),
                                (this.getAzimuthalAngle = function () {
                                    return s.theta;
                                }),
                                (this.getDistance = function () {
                                    return this.object.position.distanceTo(
                                        this.target,
                                    );
                                }),
                                (this.listenToKeyEvents = function (t) {
                                    t.addEventListener("keydown", B),
                                        (this._domElementKeyEvents = t);
                                }),
                                (this.saveState = function () {
                                    n.target0.copy(n.target),
                                        n.position0.copy(n.object.position),
                                        (n.zoom0 = n.object.zoom);
                                }),
                                (this.reset = function () {
                                    n.target.copy(n.target0),
                                        n.object.position.copy(n.position0),
                                        (n.object.zoom = n.zoom0),
                                        n.object.updateProjectionMatrix(),
                                        n.dispatchEvent(Ms),
                                        n.update(),
                                        (r = i.NONE);
                                }),
                                (this.update = (function () {
                                    const e = new St(),
                                        u = new yt().setFromUnitVectors(
                                            t.up,
                                            new St(0, 1, 0),
                                        ),
                                        d = u.clone().invert(),
                                        p = new St(),
                                        f = new yt(),
                                        m = 2 * Math.PI;
                                    return function () {
                                        const t = n.object.position;
                                        e.copy(t).sub(n.target),
                                            e.applyQuaternion(u),
                                            s.setFromVector3(e),
                                            n.autoRotate &&
                                                r === i.NONE &&
                                                A(
                                                    ((2 * Math.PI) / 60 / 60) *
                                                        n.autoRotateSpeed,
                                                ),
                                            n.enableDamping
                                                ? ((s.theta +=
                                                      o.theta *
                                                      n.dampingFactor),
                                                  (s.phi +=
                                                      o.phi * n.dampingFactor))
                                                : ((s.theta += o.theta),
                                                  (s.phi += o.phi));
                                        let g = n.minAzimuthAngle,
                                            v = n.maxAzimuthAngle;
                                        return (
                                            isFinite(g) &&
                                                isFinite(v) &&
                                                (g < -Math.PI
                                                    ? (g += m)
                                                    : g > Math.PI && (g -= m),
                                                v < -Math.PI
                                                    ? (v += m)
                                                    : v > Math.PI && (v -= m),
                                                (s.theta =
                                                    g <= v
                                                        ? Math.max(
                                                              g,
                                                              Math.min(
                                                                  v,
                                                                  s.theta,
                                                              ),
                                                          )
                                                        : s.theta > (g + v) / 2
                                                        ? Math.max(g, s.theta)
                                                        : Math.min(
                                                              v,
                                                              s.theta,
                                                          ))),
                                            (s.phi = Math.max(
                                                n.minPolarAngle,
                                                Math.min(
                                                    n.maxPolarAngle,
                                                    s.phi,
                                                ),
                                            )),
                                            s.makeSafe(),
                                            (s.radius *= l),
                                            (s.radius = Math.max(
                                                n.minDistance,
                                                Math.min(
                                                    n.maxDistance,
                                                    s.radius,
                                                ),
                                            )),
                                            !0 === n.enableDamping
                                                ? n.target.addScaledVector(
                                                      c,
                                                      n.dampingFactor,
                                                  )
                                                : n.target.add(c),
                                            e.setFromSpherical(s),
                                            e.applyQuaternion(d),
                                            t.copy(n.target).add(e),
                                            n.object.lookAt(n.target),
                                            !0 === n.enableDamping
                                                ? ((o.theta *=
                                                      1 - n.dampingFactor),
                                                  (o.phi *=
                                                      1 - n.dampingFactor),
                                                  c.multiplyScalar(
                                                      1 - n.dampingFactor,
                                                  ))
                                                : (o.set(0, 0, 0),
                                                  c.set(0, 0, 0)),
                                            (l = 1),
                                            !!(
                                                h ||
                                                p.distanceToSquared(
                                                    n.object.position,
                                                ) > a ||
                                                8 *
                                                    (1 -
                                                        f.dot(
                                                            n.object.quaternion,
                                                        )) >
                                                    a
                                            ) &&
                                                (n.dispatchEvent(Ms),
                                                p.copy(n.object.position),
                                                f.copy(n.object.quaternion),
                                                (h = !1),
                                                !0)
                                        );
                                    };
                                })()),
                                (this.dispose = function () {
                                    n.domElement.removeEventListener(
                                        "contextmenu",
                                        z,
                                    ),
                                        n.domElement.removeEventListener(
                                            "pointerdown",
                                            N,
                                        ),
                                        n.domElement.removeEventListener(
                                            "pointercancel",
                                            H,
                                        ),
                                        n.domElement.removeEventListener(
                                            "wheel",
                                            F,
                                        ),
                                        n.domElement.removeEventListener(
                                            "pointermove",
                                            G,
                                        ),
                                        n.domElement.removeEventListener(
                                            "pointerup",
                                            j,
                                        ),
                                        null !== n._domElementKeyEvents &&
                                            n._domElementKeyEvents.removeEventListener(
                                                "keydown",
                                                B,
                                            );
                                });
                            const n = this,
                                i = {
                                    NONE: -1,
                                    ROTATE: 0,
                                    DOLLY: 1,
                                    PAN: 2,
                                    TOUCH_ROTATE: 3,
                                    TOUCH_PAN: 4,
                                    TOUCH_DOLLY_PAN: 5,
                                    TOUCH_DOLLY_ROTATE: 6,
                                };
                            let r = i.NONE;
                            const a = 1e-6,
                                s = new Ss(),
                                o = new Ss();
                            let l = 1;
                            const c = new St();
                            let h = !1;
                            const u = new K(),
                                d = new K(),
                                p = new K(),
                                f = new K(),
                                m = new K(),
                                g = new K(),
                                v = new K(),
                                x = new K(),
                                b = new K(),
                                y = [],
                                S = {};
                            function M() {
                                return Math.pow(0.95, n.zoomSpeed);
                            }
                            function A(t) {
                                o.theta -= t;
                            }
                            function _(t) {
                                o.phi -= t;
                            }
                            const w = (function () {
                                    const t = new St();
                                    return function (e, n) {
                                        t.setFromMatrixColumn(n, 0),
                                            t.multiplyScalar(-e),
                                            c.add(t);
                                    };
                                })(),
                                T = (function () {
                                    const t = new St();
                                    return function (e, i) {
                                        !0 === n.screenSpacePanning
                                            ? t.setFromMatrixColumn(i, 1)
                                            : (t.setFromMatrixColumn(i, 0),
                                              t.crossVectors(n.object.up, t)),
                                            t.multiplyScalar(e),
                                            c.add(t);
                                    };
                                })(),
                                E = (function () {
                                    const t = new St();
                                    return function (e, i) {
                                        const r = n.domElement;
                                        if (n.object.isPerspectiveCamera) {
                                            const a = n.object.position;
                                            t.copy(a).sub(n.target);
                                            let s = t.length();
                                            (s *= Math.tan(
                                                ((n.object.fov / 2) * Math.PI) /
                                                    180,
                                            )),
                                                w(
                                                    (2 * e * s) /
                                                        r.clientHeight,
                                                    n.object.matrix,
                                                ),
                                                T(
                                                    (2 * i * s) /
                                                        r.clientHeight,
                                                    n.object.matrix,
                                                );
                                        } else
                                            n.object.isOrthographicCamera
                                                ? (w(
                                                      (e *
                                                          (n.object.right -
                                                              n.object.left)) /
                                                          n.object.zoom /
                                                          r.clientWidth,
                                                      n.object.matrix,
                                                  ),
                                                  T(
                                                      (i *
                                                          (n.object.top -
                                                              n.object
                                                                  .bottom)) /
                                                          n.object.zoom /
                                                          r.clientHeight,
                                                      n.object.matrix,
                                                  ))
                                                : (console.warn(
                                                      "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.",
                                                  ),
                                                  (n.enablePan = !1));
                                    };
                                })();
                            function R(t) {
                                n.object.isPerspectiveCamera
                                    ? (l /= t)
                                    : n.object.isOrthographicCamera
                                    ? ((n.object.zoom = Math.max(
                                          n.minZoom,
                                          Math.min(
                                              n.maxZoom,
                                              n.object.zoom * t,
                                          ),
                                      )),
                                      n.object.updateProjectionMatrix(),
                                      (h = !0))
                                    : (console.warn(
                                          "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.",
                                      ),
                                      (n.enableZoom = !1));
                            }
                            function k(t) {
                                n.object.isPerspectiveCamera
                                    ? (l *= t)
                                    : n.object.isOrthographicCamera
                                    ? ((n.object.zoom = Math.max(
                                          n.minZoom,
                                          Math.min(
                                              n.maxZoom,
                                              n.object.zoom / t,
                                          ),
                                      )),
                                      n.object.updateProjectionMatrix(),
                                      (h = !0))
                                    : (console.warn(
                                          "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.",
                                      ),
                                      (n.enableZoom = !1));
                            }
                            function C(t) {
                                u.set(t.clientX, t.clientY);
                            }
                            function L(t) {
                                f.set(t.clientX, t.clientY);
                            }
                            function I() {
                                if (1 === y.length)
                                    u.set(y[0].pageX, y[0].pageY);
                                else {
                                    const t = 0.5 * (y[0].pageX + y[1].pageX),
                                        e = 0.5 * (y[0].pageY + y[1].pageY);
                                    u.set(t, e);
                                }
                            }
                            function O() {
                                if (1 === y.length)
                                    f.set(y[0].pageX, y[0].pageY);
                                else {
                                    const t = 0.5 * (y[0].pageX + y[1].pageX),
                                        e = 0.5 * (y[0].pageY + y[1].pageY);
                                    f.set(t, e);
                                }
                            }
                            function D() {
                                const t = y[0].pageX - y[1].pageX,
                                    e = y[0].pageY - y[1].pageY,
                                    n = Math.sqrt(t * t + e * e);
                                v.set(0, n);
                            }
                            function P(t) {
                                if (1 == y.length) d.set(t.pageX, t.pageY);
                                else {
                                    const e = Y(t),
                                        n = 0.5 * (t.pageX + e.x),
                                        i = 0.5 * (t.pageY + e.y);
                                    d.set(n, i);
                                }
                                p.subVectors(d, u).multiplyScalar(
                                    n.rotateSpeed,
                                );
                                const e = n.domElement;
                                A((2 * Math.PI * p.x) / e.clientHeight),
                                    _((2 * Math.PI * p.y) / e.clientHeight),
                                    u.copy(d);
                            }
                            function U(t) {
                                if (1 === y.length) m.set(t.pageX, t.pageY);
                                else {
                                    const e = Y(t),
                                        n = 0.5 * (t.pageX + e.x),
                                        i = 0.5 * (t.pageY + e.y);
                                    m.set(n, i);
                                }
                                g.subVectors(m, f).multiplyScalar(n.panSpeed),
                                    E(g.x, g.y),
                                    f.copy(m);
                            }
                            function V(t) {
                                const e = Y(t),
                                    i = t.pageX - e.x,
                                    r = t.pageY - e.y,
                                    a = Math.sqrt(i * i + r * r);
                                x.set(0, a),
                                    b.set(0, Math.pow(x.y / v.y, n.zoomSpeed)),
                                    R(b.y),
                                    v.copy(x);
                            }
                            function N(t) {
                                !1 !== n.enabled &&
                                    (0 === y.length &&
                                        (n.domElement.setPointerCapture(
                                            t.pointerId,
                                        ),
                                        n.domElement.addEventListener(
                                            "pointermove",
                                            G,
                                        ),
                                        n.domElement.addEventListener(
                                            "pointerup",
                                            j,
                                        )),
                                    (function (t) {
                                        y.push(t);
                                    })(t),
                                    "touch" === t.pointerType
                                        ? (function (t) {
                                              switch ((q(t), y.length)) {
                                                  case 1:
                                                      switch (n.touches.ONE) {
                                                          case 0:
                                                              if (
                                                                  !1 ===
                                                                  n.enableRotate
                                                              )
                                                                  return;
                                                              I(),
                                                                  (r =
                                                                      i.TOUCH_ROTATE);
                                                              break;
                                                          case 1:
                                                              if (
                                                                  !1 ===
                                                                  n.enablePan
                                                              )
                                                                  return;
                                                              O(),
                                                                  (r =
                                                                      i.TOUCH_PAN);
                                                              break;
                                                          default:
                                                              r = i.NONE;
                                                      }
                                                      break;
                                                  case 2:
                                                      switch (n.touches.TWO) {
                                                          case 2:
                                                              if (
                                                                  !1 ===
                                                                      n.enableZoom &&
                                                                  !1 ===
                                                                      n.enablePan
                                                              )
                                                                  return;
                                                              n.enableZoom &&
                                                                  D(),
                                                                  n.enablePan &&
                                                                      O(),
                                                                  (r =
                                                                      i.TOUCH_DOLLY_PAN);
                                                              break;
                                                          case 3:
                                                              if (
                                                                  !1 ===
                                                                      n.enableZoom &&
                                                                  !1 ===
                                                                      n.enableRotate
                                                              )
                                                                  return;
                                                              n.enableZoom &&
                                                                  D(),
                                                                  n.enableRotate &&
                                                                      I(),
                                                                  (r =
                                                                      i.TOUCH_DOLLY_ROTATE);
                                                              break;
                                                          default:
                                                              r = i.NONE;
                                                      }
                                                      break;
                                                  default:
                                                      r = i.NONE;
                                              }
                                              r !== i.NONE &&
                                                  n.dispatchEvent(As);
                                          })(t)
                                        : (function (t) {
                                              let e;
                                              switch (t.button) {
                                                  case 0:
                                                      e = n.mouseButtons.LEFT;
                                                      break;
                                                  case 1:
                                                      e = n.mouseButtons.MIDDLE;
                                                      break;
                                                  case 2:
                                                      e = n.mouseButtons.RIGHT;
                                                      break;
                                                  default:
                                                      e = -1;
                                              }
                                              switch (e) {
                                                  case 1:
                                                      if (!1 === n.enableZoom)
                                                          return;
                                                      !(function (t) {
                                                          v.set(
                                                              t.clientX,
                                                              t.clientY,
                                                          );
                                                      })(t),
                                                          (r = i.DOLLY);
                                                      break;
                                                  case 0:
                                                      if (
                                                          t.ctrlKey ||
                                                          t.metaKey ||
                                                          t.shiftKey
                                                      ) {
                                                          if (
                                                              !1 === n.enablePan
                                                          )
                                                              return;
                                                          L(t), (r = i.PAN);
                                                      } else {
                                                          if (
                                                              !1 ===
                                                              n.enableRotate
                                                          )
                                                              return;
                                                          C(t), (r = i.ROTATE);
                                                      }
                                                      break;
                                                  case 2:
                                                      if (
                                                          t.ctrlKey ||
                                                          t.metaKey ||
                                                          t.shiftKey
                                                      ) {
                                                          if (
                                                              !1 ===
                                                              n.enableRotate
                                                          )
                                                              return;
                                                          C(t), (r = i.ROTATE);
                                                      } else {
                                                          if (
                                                              !1 === n.enablePan
                                                          )
                                                              return;
                                                          L(t), (r = i.PAN);
                                                      }
                                                      break;
                                                  default:
                                                      r = i.NONE;
                                              }
                                              r !== i.NONE &&
                                                  n.dispatchEvent(As);
                                          })(t));
                            }
                            function G(t) {
                                !1 !== n.enabled &&
                                    ("touch" === t.pointerType
                                        ? (function (t) {
                                              switch ((q(t), r)) {
                                                  case i.TOUCH_ROTATE:
                                                      if (!1 === n.enableRotate)
                                                          return;
                                                      P(t), n.update();
                                                      break;
                                                  case i.TOUCH_PAN:
                                                      if (!1 === n.enablePan)
                                                          return;
                                                      U(t), n.update();
                                                      break;
                                                  case i.TOUCH_DOLLY_PAN:
                                                      if (
                                                          !1 === n.enableZoom &&
                                                          !1 === n.enablePan
                                                      )
                                                          return;
                                                      !(function (t) {
                                                          n.enableZoom && V(t),
                                                              n.enablePan &&
                                                                  U(t);
                                                      })(t),
                                                          n.update();
                                                      break;
                                                  case i.TOUCH_DOLLY_ROTATE:
                                                      if (
                                                          !1 === n.enableZoom &&
                                                          !1 === n.enableRotate
                                                      )
                                                          return;
                                                      !(function (t) {
                                                          n.enableZoom && V(t),
                                                              n.enableRotate &&
                                                                  P(t);
                                                      })(t),
                                                          n.update();
                                                      break;
                                                  default:
                                                      r = i.NONE;
                                              }
                                          })(t)
                                        : (function (t) {
                                              switch (r) {
                                                  case i.ROTATE:
                                                      if (!1 === n.enableRotate)
                                                          return;
                                                      !(function (t) {
                                                          d.set(
                                                              t.clientX,
                                                              t.clientY,
                                                          ),
                                                              p
                                                                  .subVectors(
                                                                      d,
                                                                      u,
                                                                  )
                                                                  .multiplyScalar(
                                                                      n.rotateSpeed,
                                                                  );
                                                          const e =
                                                              n.domElement;
                                                          A(
                                                              (2 *
                                                                  Math.PI *
                                                                  p.x) /
                                                                  e.clientHeight,
                                                          ),
                                                              _(
                                                                  (2 *
                                                                      Math.PI *
                                                                      p.y) /
                                                                      e.clientHeight,
                                                              ),
                                                              u.copy(d),
                                                              n.update();
                                                      })(t);
                                                      break;
                                                  case i.DOLLY:
                                                      if (!1 === n.enableZoom)
                                                          return;
                                                      !(function (t) {
                                                          x.set(
                                                              t.clientX,
                                                              t.clientY,
                                                          ),
                                                              b.subVectors(
                                                                  x,
                                                                  v,
                                                              ),
                                                              b.y > 0
                                                                  ? R(M())
                                                                  : b.y < 0 &&
                                                                    k(M()),
                                                              v.copy(x),
                                                              n.update();
                                                      })(t);
                                                      break;
                                                  case i.PAN:
                                                      if (!1 === n.enablePan)
                                                          return;
                                                      !(function (t) {
                                                          m.set(
                                                              t.clientX,
                                                              t.clientY,
                                                          ),
                                                              g
                                                                  .subVectors(
                                                                      m,
                                                                      f,
                                                                  )
                                                                  .multiplyScalar(
                                                                      n.panSpeed,
                                                                  ),
                                                              E(g.x, g.y),
                                                              f.copy(m),
                                                              n.update();
                                                      })(t);
                                              }
                                          })(t));
                            }
                            function j(t) {
                                W(t),
                                    0 === y.length &&
                                        (n.domElement.releasePointerCapture(
                                            t.pointerId,
                                        ),
                                        n.domElement.removeEventListener(
                                            "pointermove",
                                            G,
                                        ),
                                        n.domElement.removeEventListener(
                                            "pointerup",
                                            j,
                                        )),
                                    n.dispatchEvent(_s),
                                    (r = i.NONE);
                            }
                            function H(t) {
                                W(t);
                            }
                            function F(t) {
                                !1 !== n.enabled &&
                                    !1 !== n.enableZoom &&
                                    r === i.NONE &&
                                    (t.preventDefault(),
                                    n.dispatchEvent(As),
                                    (function (t) {
                                        t.deltaY < 0
                                            ? k(M())
                                            : t.deltaY > 0 && R(M()),
                                            n.update();
                                    })(t),
                                    n.dispatchEvent(_s));
                            }
                            function B(t) {
                                !1 !== n.enabled &&
                                    !1 !== n.enablePan &&
                                    (function (t) {
                                        let e = !1;
                                        switch (t.code) {
                                            case n.keys.UP:
                                                t.ctrlKey ||
                                                t.metaKey ||
                                                t.shiftKey
                                                    ? _(
                                                          (2 *
                                                              Math.PI *
                                                              n.rotateSpeed) /
                                                              n.domElement
                                                                  .clientHeight,
                                                      )
                                                    : E(0, n.keyPanSpeed),
                                                    (e = !0);
                                                break;
                                            case n.keys.BOTTOM:
                                                t.ctrlKey ||
                                                t.metaKey ||
                                                t.shiftKey
                                                    ? _(
                                                          (-2 *
                                                              Math.PI *
                                                              n.rotateSpeed) /
                                                              n.domElement
                                                                  .clientHeight,
                                                      )
                                                    : E(0, -n.keyPanSpeed),
                                                    (e = !0);
                                                break;
                                            case n.keys.LEFT:
                                                t.ctrlKey ||
                                                t.metaKey ||
                                                t.shiftKey
                                                    ? A(
                                                          (2 *
                                                              Math.PI *
                                                              n.rotateSpeed) /
                                                              n.domElement
                                                                  .clientHeight,
                                                      )
                                                    : E(n.keyPanSpeed, 0),
                                                    (e = !0);
                                                break;
                                            case n.keys.RIGHT:
                                                t.ctrlKey ||
                                                t.metaKey ||
                                                t.shiftKey
                                                    ? A(
                                                          (-2 *
                                                              Math.PI *
                                                              n.rotateSpeed) /
                                                              n.domElement
                                                                  .clientHeight,
                                                      )
                                                    : E(-n.keyPanSpeed, 0),
                                                    (e = !0);
                                        }
                                        e && (t.preventDefault(), n.update());
                                    })(t);
                            }
                            function z(t) {
                                !1 !== n.enabled && t.preventDefault();
                            }
                            function W(t) {
                                delete S[t.pointerId];
                                for (let e = 0; e < y.length; e++)
                                    if (y[e].pointerId == t.pointerId)
                                        return void y.splice(e, 1);
                            }
                            function q(t) {
                                let e = S[t.pointerId];
                                void 0 === e &&
                                    ((e = new K()), (S[t.pointerId] = e)),
                                    e.set(t.pageX, t.pageY);
                            }
                            function Y(t) {
                                const e =
                                    t.pointerId === y[0].pointerId
                                        ? y[1]
                                        : y[0];
                                return S[e.pointerId];
                            }
                            n.domElement.addEventListener("contextmenu", z),
                                n.domElement.addEventListener("pointerdown", N),
                                n.domElement.addEventListener(
                                    "pointercancel",
                                    H,
                                ),
                                n.domElement.addEventListener("wheel", F, {
                                    passive: !1,
                                }),
                                this.update();
                        }
                    })(Xo, Jo.domElement),
                    $o = new (class extends ys {
                        constructor() {
                            super(...arguments), (this.keyframe_tracks = []);
                        }
                        addKeyframeTrack(t) {
                            this.keyframe_tracks.push(t);
                        }
                        lock() {
                            (this.clip = new Wa(
                                "Action",
                                -1,
                                this.keyframe_tracks,
                            )),
                                this.clip.resetDuration(),
                                (this.clip_action = this.clipAction(this.clip)),
                                this.clip_action.play();
                        }
                    })(Zo),
                    tl = new (class {
                        constructor(t, e) {
                            (this.followable_objs = []),
                                (this.follow_obj = null),
                                (this.follow_obj_offset = new St()),
                                (this.rotation = !0),
                                (this.scene = t),
                                (this.camera = e);
                        }
                        addFollowableObject(t) {
                            this.followable_objs.push(t);
                        }
                        addFollowableObjects(t) {
                            t.forEach((t) => this.addFollowableObject(t));
                        }
                        update() {
                            if (null != this.follow_obj) {
                                if (!this.rotation) {
                                    var t = new St();
                                    this.follow_obj.getWorldPosition(t),
                                        this.camera.position.addVectors(
                                            t,
                                            this.follow_obj_offset,
                                        );
                                }
                                this.camera.lookAt(this.follow_obj.position);
                            }
                        }
                    })(Zo, Xo);
                var el = [],
                    nl = Ko.parse(
                        "\n# FreeCAD v0.19 build Arch module\n# http://www.freecadweb.org\no Body\nusemtl color_cccccc\nv 0.0 5.0 5.773503\nv 0.0 5.0 0.0\nv 0.0 -5.0 -0.0\nv 0.0 -5.0 5.773503\nv 10.0 5.0 0.0\nv 10.0 -5.0 -0.0\nv 10.0 5.0 0.0\nv 0.0 5.0 0.0\nv 0.0 -5.0 -0.0\nv 10.0 -5.0 -0.0\nvn -1.0 0.0 -0.0\nvn -1.0 -0.0 0.0\nvn 0.5 0.0 0.8660253882408142\nvn 0.5 -3.4641016446608475e-16 0.8660253882408142\nvn 0.0 3.999999802751738e-16 -1.0\nvn 0.0 3.999999802751738e-16 -1.0\nvn 0.0 1.0 0.0\nvn 0.0 -1.0 0.0\nf 1//1 2//1 3//1 \nf 1//2 3//2 4//2 \nf 5//3 1//3 4//3 \nf 5//4 4//4 6//4 \nf 2//5 5//5 6//5 \nf 2//6 6//6 3//6 \nf 7//7 8//7 1//7 \nf 9//8 10//8 4//8 \n\n",
                    );
                (nl.name = "ramp"),
                    Zo.add(nl),
                    nl.uuid,
                    el.push(nl),
                    Ko.setMaterials(
                        Yo.parse(
                            "\n# Blender MTL File: 'None'\n# Material Count: 1\n\nnewmtl Material.001\nNs 225.000000\nKa 1.000000 1.000000 1.000000\n#Kd 0.031744 0.795519 0.763070\nKd 1.000000 1.000000 1.000000\nKs 0.500000 0.500000 0.500000\nKe 0.000000 0.000000 0.000000\nNi 1.450000\nd 0.9\nillum 9\nmap_Kd data:image/jpg;base64,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\n",
                        ),
                    );
                var il = Ko.parse(
                    "\n# Blender v3.0.1 OBJ File: ''\n# www.blender.org\nmtllib sphere.mtl\no Sphere\nv 0.000000 0.980785 -0.195090\nv 0.000000 0.923880 -0.382683\nv 0.000000 0.831470 -0.555570\nv 0.000000 0.707107 -0.707107\nv 0.000000 0.555570 -0.831470\nv 0.000000 0.382683 -0.923880\nv 0.000000 0.195090 -0.980785\nv 0.000000 -0.555570 -0.831470\nv 0.000000 -0.707107 -0.707107\nv 0.000000 -0.831470 -0.555570\nv 0.038060 0.980785 -0.191342\nv 0.074658 0.923880 -0.375330\nv 0.108386 0.831470 -0.544895\nv 0.137950 0.707107 -0.693520\nv 0.162212 0.555570 -0.815493\nv 0.180240 0.382683 -0.906127\nv 0.191342 0.195090 -0.961940\nv 0.195090 -0.000000 -0.980785\nv 0.191342 -0.195090 -0.961940\nv 0.180240 -0.382683 -0.906127\nv 0.162212 -0.555570 -0.815493\nv 0.137950 -0.707107 -0.693520\nv 0.108386 -0.831470 -0.544895\nv 0.074658 -0.923880 -0.375330\nv 0.038060 -0.980785 -0.191342\nv 0.074658 0.980785 -0.180240\nv 0.146447 0.923880 -0.353553\nv 0.212608 0.831470 -0.513280\nv 0.270598 0.707107 -0.653281\nv 0.318190 0.555570 -0.768178\nv 0.353553 0.382683 -0.853553\nv 0.375330 0.195090 -0.906127\nv 0.382683 -0.000000 -0.923879\nv 0.375330 -0.195090 -0.906127\nv 0.353553 -0.382683 -0.853553\nv 0.318190 -0.555570 -0.768178\nv 0.270598 -0.707107 -0.653281\nv 0.212608 -0.831470 -0.513280\nv 0.146447 -0.923880 -0.353553\nv 0.074658 -0.980785 -0.180240\nv 0.108386 0.980785 -0.162212\nv 0.212608 0.923880 -0.318190\nv 0.308658 0.831470 -0.461940\nv 0.392848 0.707107 -0.587938\nv 0.461940 0.555570 -0.691342\nv 0.513280 0.382683 -0.768178\nv 0.544895 0.195090 -0.815493\nv 0.555570 -0.000000 -0.831469\nv 0.544895 -0.195090 -0.815493\nv 0.513280 -0.382683 -0.768178\nv 0.461940 -0.555570 -0.691342\nv 0.392848 -0.707107 -0.587938\nv 0.308658 -0.831470 -0.461940\nv 0.212608 -0.923880 -0.318190\nv 0.108386 -0.980785 -0.162212\nv 0.137950 0.980785 -0.137950\nv 0.270598 0.923880 -0.270598\nv 0.392848 0.831470 -0.392847\nv 0.500000 0.707107 -0.500000\nv 0.587938 0.555570 -0.587938\nv 0.653281 0.382683 -0.653281\nv 0.693520 0.195090 -0.693520\nv 0.707107 -0.000000 -0.707107\nv 0.693520 -0.195090 -0.693520\nv 0.653282 -0.382683 -0.653281\nv 0.587938 -0.555570 -0.587938\nv 0.500000 -0.707107 -0.500000\nv 0.392848 -0.831470 -0.392847\nv 0.270598 -0.923880 -0.270598\nv 0.137950 -0.980785 -0.137950\nv 0.162212 0.980785 -0.108386\nv 0.318190 0.923880 -0.212607\nv 0.461940 0.831470 -0.308658\nv 0.587938 0.707107 -0.392847\nv 0.691342 0.555570 -0.461940\nv 0.768178 0.382683 -0.513280\nv 0.815493 0.195090 -0.544895\nv 0.831470 -0.000000 -0.555570\nv 0.815493 -0.195090 -0.544895\nv 0.768178 -0.382683 -0.513280\nv 0.691342 -0.555570 -0.461940\nv 0.587938 -0.707107 -0.392847\nv 0.461940 -0.831470 -0.308658\nv 0.318190 -0.923880 -0.212608\nv 0.162212 -0.980785 -0.108386\nv 0.180240 0.980785 -0.074658\nv 0.353554 0.923880 -0.146447\nv 0.513280 0.831470 -0.212607\nv 0.653281 0.707107 -0.270598\nv 0.768178 0.555570 -0.318190\nv 0.853553 0.382683 -0.353553\nv 0.906127 0.195090 -0.375330\nv 0.923879 -0.000000 -0.382683\nv 0.906127 -0.195090 -0.375330\nv 0.853553 -0.382683 -0.353553\nv 0.768178 -0.555570 -0.318190\nv 0.653281 -0.707107 -0.270598\nv 0.513280 -0.831470 -0.212607\nv 0.353554 -0.923880 -0.146447\nv 0.180240 -0.980785 -0.074658\nv 0.191342 0.980785 -0.038060\nv 0.375330 0.923880 -0.074658\nv 0.544895 0.831470 -0.108386\nv 0.693520 0.707107 -0.137950\nv 0.815493 0.555570 -0.162212\nv 0.906127 0.382683 -0.180240\nv 0.961940 0.195090 -0.191342\nv 0.980785 -0.000000 -0.195090\nv 0.961940 -0.195090 -0.191342\nv 0.906128 -0.382683 -0.180240\nv 0.815493 -0.555570 -0.162212\nv 0.693520 -0.707107 -0.137950\nv 0.544895 -0.831470 -0.108386\nv 0.375330 -0.923880 -0.074658\nv 0.191342 -0.980785 -0.038060\nv 0.195090 0.980785 0.000000\nv 0.382684 0.923880 0.000000\nv 0.555570 0.831470 0.000000\nv 0.707107 0.707107 0.000000\nv 0.831469 0.555570 0.000000\nv 0.923879 0.382683 0.000000\nv 0.980785 0.195090 0.000000\nv 1.000000 -0.000000 0.000000\nv 0.980785 -0.195090 0.000000\nv 0.923880 -0.382683 0.000000\nv 0.831469 -0.555570 0.000000\nv 0.707107 -0.707107 0.000000\nv 0.555570 -0.831470 0.000000\nv 0.382684 -0.923880 0.000000\nv 0.195090 -0.980785 0.000000\nv 0.191342 0.980785 0.038060\nv 0.375330 0.923880 0.074658\nv 0.544895 0.831470 0.108386\nv 0.693520 0.707107 0.137950\nv 0.815493 0.555570 0.162212\nv 0.906127 0.382683 0.180240\nv 0.961940 0.195090 0.191342\nv 0.980785 -0.000000 0.195090\nv 0.961940 -0.195090 0.191342\nv 0.906127 -0.382683 0.180240\nv 0.815493 -0.555570 0.162212\nv 0.693520 -0.707107 0.137950\nv 0.544895 -0.831470 0.108386\nv 0.375330 -0.923880 0.074658\nv 0.191342 -0.980785 0.038060\nv 0.180240 0.980785 0.074658\nv 0.353553 0.923880 0.146447\nv 0.513280 0.831470 0.212608\nv 0.653281 0.707107 0.270598\nv 0.768178 0.555570 0.318190\nv 0.853553 0.382683 0.353553\nv 0.906127 0.195090 0.375330\nv 0.923879 -0.000000 0.382683\nv 0.906127 -0.195090 0.375330\nv 0.853553 -0.382683 0.353554\nv 0.768178 -0.555570 0.318190\nv 0.653281 -0.707107 0.270598\nv 0.513280 -0.831470 0.212608\nv 0.353554 -0.923880 0.146447\nv 0.180240 -0.980785 0.074658\nv 0.162212 0.980785 0.108386\nv 0.318190 0.923880 0.212608\nv 0.461940 0.831470 0.308658\nv 0.587938 0.707107 0.392847\nv 0.691341 0.555570 0.461940\nv 0.768178 0.382683 0.513280\nv 0.815493 0.195090 0.544895\nv 0.831469 -0.000000 0.555570\nv 0.815493 -0.195090 0.544895\nv 0.768178 -0.382683 0.513280\nv 0.691342 -0.555570 0.461940\nv 0.587938 -0.707107 0.392847\nv 0.461940 -0.831470 0.308658\nv 0.318190 -0.923880 0.212608\nv 0.162212 -0.980785 0.108386\nv 0.137950 0.980785 0.137950\nv 0.270598 0.923880 0.270598\nv 0.392847 0.831470 0.392847\nv 0.500000 0.707107 0.500000\nv 0.587938 0.555570 0.587938\nv 0.653281 0.382683 0.653281\nv 0.693520 0.195090 0.693520\nv 0.707106 -0.000000 0.707107\nv 0.693520 -0.195090 0.693520\nv 0.653281 -0.382683 0.653282\nv 0.587938 -0.555570 0.587938\nv 0.500000 -0.707107 0.500000\nv 0.392847 -0.831470 0.392847\nv 0.270598 -0.923880 0.270598\nv 0.137950 -0.980785 0.137950\nv 0.108386 0.980785 0.162212\nv 0.212608 0.923880 0.318190\nv 0.308658 0.831470 0.461940\nv 0.392847 0.707107 0.587938\nv 0.461940 0.555570 0.691342\nv 0.513280 0.382683 0.768178\nv 0.544895 0.195090 0.815493\nv 0.555570 -0.000000 0.831469\nv 0.544895 -0.195090 0.815493\nv 0.513280 -0.382683 0.768178\nv 0.461940 -0.555570 0.691342\nv 0.392847 -0.707107 0.587938\nv 0.308658 -0.831470 0.461940\nv 0.212608 -0.923880 0.318190\nv 0.108386 -0.980785 0.162212\nv 0.074658 0.980785 0.180240\nv 0.146447 0.923880 0.353554\nv 0.212607 0.831470 0.513280\nv 0.270598 0.707107 0.653281\nv 0.318190 0.555570 0.768178\nv 0.353553 0.382683 0.853553\nv 0.375330 0.195090 0.906127\nv 0.382683 -0.000000 0.923879\nv 0.375330 -0.195090 0.906127\nv 0.353553 -0.382683 0.853553\nv 0.318190 -0.555570 0.768178\nv 0.270598 -0.707107 0.653281\nv 0.212607 -0.831470 0.513280\nv 0.146447 -0.923880 0.353554\nv 0.074658 -0.980785 0.180240\nv 0.038060 0.980785 0.191342\nv 0.074658 0.923880 0.375330\nv 0.108386 0.831470 0.544895\nv 0.137950 0.707107 0.693520\nv 0.162212 0.555570 0.815493\nv 0.180240 0.382683 0.906127\nv 0.191342 0.195090 0.961939\nv 0.195090 -0.000000 0.980785\nv 0.191342 -0.195090 0.961939\nv 0.180240 -0.382683 0.906127\nv 0.162212 -0.555570 0.815493\nv 0.137950 -0.707107 0.693520\nv 0.108386 -0.831470 0.544895\nv 0.074658 -0.923880 0.375330\nv 0.038060 -0.980785 0.191342\nv 0.000000 0.980785 0.195090\nv -0.000000 0.923880 0.382684\nv -0.000000 0.831470 0.555570\nv 0.000000 0.707107 0.707107\nv -0.000000 0.555570 0.831469\nv 0.000000 0.382683 0.923879\nv -0.000000 0.195090 0.980785\nv -0.000000 -0.000000 0.999999\nv -0.000000 -0.195090 0.980785\nv -0.000000 -0.382683 0.923880\nv -0.000000 -0.555570 0.831469\nv 0.000000 -0.707107 0.707107\nv -0.000000 -0.831470 0.555570\nv 0.000000 -0.923880 0.382684\nv -0.000000 -0.980785 0.195090\nv -0.038060 0.980785 0.191342\nv -0.074658 0.923880 0.375330\nv -0.108386 0.831470 0.544895\nv -0.137950 0.707107 0.693520\nv -0.162212 0.555570 0.815493\nv -0.180240 0.382683 0.906127\nv -0.191342 0.195090 0.961939\nv -0.195090 -0.000000 0.980785\nv -0.191342 -0.195090 0.961939\nv -0.180240 -0.382683 0.906127\nv -0.162212 -0.555570 0.815493\nv -0.137950 -0.707107 0.693520\nv -0.108386 -0.831470 0.544895\nv -0.074658 -0.923880 0.375330\nv -0.038060 -0.980785 0.191342\nv -0.074658 0.980785 0.180240\nv -0.146447 0.923880 0.353553\nv -0.212608 0.831470 0.513280\nv -0.270598 0.707107 0.653281\nv -0.318189 0.555570 0.768177\nv -0.353553 0.382683 0.853553\nv -0.375330 0.195090 0.906127\nv -0.382683 -0.000000 0.923879\nv -0.375330 -0.195090 0.906127\nv -0.353553 -0.382683 0.853553\nv -0.318190 -0.555570 0.768178\nv -0.270598 -0.707107 0.653281\nv -0.212608 -0.831470 0.513280\nv -0.146447 -0.923880 0.353553\nv -0.074658 -0.980785 0.180240\nv -0.108386 0.980785 0.162212\nv -0.212608 0.923880 0.318190\nv -0.308658 0.831470 0.461940\nv -0.392847 0.707107 0.587938\nv -0.461940 0.555570 0.691341\nv -0.513280 0.382683 0.768178\nv -0.544895 0.195090 0.815493\nv -0.555570 -0.000000 0.831469\nv -0.544895 -0.195090 0.815493\nv -0.513280 -0.382683 0.768178\nv -0.461940 -0.555570 0.691342\nv -0.392847 -0.707107 0.587938\nv -0.308658 -0.831470 0.461940\nv -0.212608 -0.923880 0.318190\nv -0.108386 -0.980785 0.162212\nv -0.137950 0.980785 0.137950\nv -0.270598 0.923880 0.270598\nv -0.392847 0.831470 0.392847\nv -0.500000 0.707107 0.500000\nv -0.587937 0.555570 0.587938\nv -0.653281 0.382683 0.653281\nv -0.693520 0.195090 0.693520\nv -0.707106 -0.000000 0.707106\nv -0.693520 -0.195090 0.693520\nv -0.653281 -0.382683 0.653281\nv -0.587938 -0.555570 0.587938\nv -0.500000 -0.707107 0.500000\nv -0.392847 -0.831470 0.392847\nv -0.270598 -0.923880 0.270598\nv -0.137950 -0.980785 0.137950\nv -0.162212 0.980785 0.108386\nv -0.318190 0.923880 0.212608\nv -0.461940 0.831470 0.308658\nv -0.587938 0.707107 0.392847\nv -0.691341 0.555570 0.461940\nv -0.768178 0.382683 0.513280\nv -0.815493 0.195090 0.544895\nv -0.831469 -0.000000 0.555569\nv -0.815493 -0.195090 0.544895\nv -0.768178 -0.382683 0.513280\nv -0.691341 -0.555570 0.461940\nv -0.587938 -0.707107 0.392847\nv -0.461940 -0.831470 0.308658\nv -0.318190 -0.923880 0.212608\nv -0.162212 -0.980785 0.108386\nv -0.000000 1.000000 0.000000\nv -0.180240 0.980785 0.074658\nv -0.353553 0.923880 0.146447\nv -0.513280 0.831470 0.212607\nv -0.653281 0.707107 0.270598\nv -0.768177 0.555570 0.318190\nv -0.853553 0.382683 0.353553\nv -0.906127 0.195090 0.375330\nv -0.923879 -0.000000 0.382683\nv -0.906127 -0.195090 0.375330\nv -0.853553 -0.382683 0.353553\nv -0.768177 -0.555570 0.318190\nv -0.653281 -0.707107 0.270598\nv -0.513280 -0.831470 0.212607\nv -0.353553 -0.923880 0.146447\nv -0.180240 -0.980785 0.074658\nv -0.191342 0.980785 0.038060\nv -0.375330 0.923880 0.074658\nv -0.544895 0.831470 0.108386\nv -0.693520 0.707107 0.137950\nv -0.815493 0.555570 0.162212\nv -0.906127 0.382683 0.180240\nv -0.961939 0.195090 0.191342\nv -0.980784 -0.000000 0.195090\nv -0.961939 -0.195090 0.191342\nv -0.906127 -0.382683 0.180240\nv -0.815493 -0.555570 0.162212\nv -0.693520 -0.707107 0.137950\nv -0.544895 -0.831470 0.108386\nv -0.375330 -0.923880 0.074658\nv -0.191342 -0.980785 0.038060\nv -0.195090 0.980785 0.000000\nv -0.382683 0.923880 0.000000\nv -0.555570 0.831470 -0.000000\nv -0.707107 0.707107 0.000000\nv -0.831469 0.555570 0.000000\nv -0.923879 0.382683 0.000000\nv -0.980785 0.195090 -0.000000\nv -0.999999 -0.000000 -0.000000\nv -0.980785 -0.195090 -0.000000\nv -0.923879 -0.382683 -0.000000\nv -0.831469 -0.555570 0.000000\nv -0.707107 -0.707107 0.000000\nv -0.555570 -0.831470 -0.000000\nv -0.382683 -0.923880 0.000000\nv -0.195090 -0.980785 0.000000\nv -0.191342 0.980785 -0.038060\nv -0.375330 0.923880 -0.074658\nv -0.544895 0.831470 -0.108386\nv -0.693520 0.707107 -0.137950\nv -0.815493 0.555570 -0.162212\nv -0.906127 0.382683 -0.180240\nv -0.961939 0.195090 -0.191342\nv -0.980784 -0.000000 -0.195091\nv -0.961939 -0.195090 -0.191342\nv -0.906127 -0.382683 -0.180240\nv -0.815493 -0.555570 -0.162212\nv -0.693520 -0.707107 -0.137950\nv -0.544895 -0.831470 -0.108386\nv -0.375330 -0.923880 -0.074658\nv -0.191342 -0.980785 -0.038060\nv -0.180240 0.980785 -0.074658\nv -0.353553 0.923880 -0.146447\nv -0.513280 0.831470 -0.212607\nv -0.653281 0.707107 -0.270598\nv -0.768177 0.555570 -0.318189\nv -0.853553 0.382683 -0.353553\nv -0.906127 0.195090 -0.375330\nv -0.923878 -0.000000 -0.382683\nv -0.906127 -0.195090 -0.375330\nv -0.853553 -0.382683 -0.353553\nv -0.768177 -0.555570 -0.318189\nv -0.653281 -0.707107 -0.270598\nv -0.513280 -0.831470 -0.212607\nv -0.353553 -0.923880 -0.146446\nv -0.180240 -0.980785 -0.074658\nv -0.162212 0.980785 -0.108386\nv -0.318189 0.923880 -0.212607\nv -0.461939 0.831470 -0.308658\nv -0.587938 0.707107 -0.392847\nv -0.691341 0.555570 -0.461939\nv -0.768177 0.382683 -0.513280\nv -0.815493 0.195090 -0.544895\nv -0.831469 -0.000000 -0.555570\nv -0.815493 -0.195090 -0.544895\nv -0.768177 -0.382683 -0.513280\nv -0.691341 -0.555570 -0.461939\nv -0.587938 -0.707107 -0.392847\nv -0.461939 -0.831470 -0.308658\nv -0.318189 -0.923880 -0.212607\nv -0.162212 -0.980785 -0.108386\nv -0.137950 0.980785 -0.137950\nv -0.270598 0.923880 -0.270598\nv -0.392847 0.831470 -0.392847\nv -0.500000 0.707107 -0.500000\nv -0.587937 0.555570 -0.587937\nv -0.653281 0.382683 -0.653281\nv -0.693519 0.195090 -0.693520\nv -0.707106 -0.000000 -0.707106\nv -0.693519 -0.195090 -0.693520\nv -0.653281 -0.382683 -0.653281\nv -0.587937 -0.555570 -0.587937\nv -0.500000 -0.707107 -0.500000\nv -0.392847 -0.831470 -0.392847\nv -0.270598 -0.923880 -0.270598\nv -0.137950 -0.980785 -0.137950\nv -0.108386 0.980785 -0.162212\nv -0.212607 0.923880 -0.318189\nv -0.308658 0.831470 -0.461939\nv -0.392847 0.707107 -0.587937\nv -0.461939 0.555570 -0.691341\nv -0.513280 0.382683 -0.768177\nv -0.544895 0.195090 -0.815493\nv -0.555569 -0.000000 -0.831469\nv -0.544895 -0.195090 -0.815493\nv -0.513280 -0.382683 -0.768178\nv -0.461939 -0.555570 -0.691341\nv -0.392847 -0.707107 -0.587937\nv -0.308658 -0.831470 -0.461939\nv -0.212607 -0.923880 -0.318189\nv -0.108386 -0.980785 -0.162212\nv -0.074658 0.980785 -0.180240\nv -0.146446 0.923880 -0.353553\nv -0.212607 0.831470 -0.513279\nv -0.270598 0.707107 -0.653281\nv -0.318189 0.555570 -0.768177\nv -0.353553 0.382683 -0.853553\nv -0.375330 0.195090 -0.906127\nv -0.382683 -0.000000 -0.923879\nv -0.375330 -0.195090 -0.906127\nv -0.353553 -0.382683 -0.853553\nv -0.318189 -0.555570 -0.768177\nv -0.270598 -0.707107 -0.653281\nv -0.212607 -0.831470 -0.513279\nv -0.146446 -0.923880 -0.353553\nv -0.074658 -0.980785 -0.180240\nv -0.038060 0.980785 -0.191342\nv -0.074658 0.923880 -0.375330\nv -0.108386 0.831470 -0.544895\nv -0.137950 0.707107 -0.693520\nv -0.162212 0.555570 -0.815493\nv -0.180240 0.382683 -0.906127\nv -0.191341 0.195090 -0.961939\nv -0.195090 -0.000000 -0.980784\nv -0.191341 -0.195090 -0.961939\nv -0.180240 -0.382683 -0.906127\nv -0.162212 -0.555570 -0.815493\nv -0.137950 -0.707107 -0.693520\nv -0.108386 -0.831470 -0.544895\nv -0.074658 -0.923880 -0.375330\nv -0.038060 -0.980785 -0.191342\nv 0.000001 -0.000000 -0.999999\nv 0.000000 -0.195090 -0.980785\nv 0.000000 -0.382683 -0.923879\nv 0.000000 -0.923880 -0.382683\nv 0.000000 -0.980785 -0.195090\nv 0.000000 -1.000000 0.000000\nvt 0.750000 0.937500\nvt 0.734375 1.000000\nvt 0.718750 0.937500\nvt 0.734375 0.000000\nvt 0.750000 0.062500\nvt 0.718750 0.062500\nvt 0.750000 0.437500\nvt 0.750000 0.500000\nvt 0.718750 0.500000\nvt 0.718750 0.437500\nvt 0.750000 0.875000\nvt 0.718750 0.875000\nvt 0.750000 0.375000\nvt 0.718750 0.375000\nvt 0.750000 0.812500\nvt 0.718750 0.812500\nvt 0.750000 0.312500\nvt 0.718750 0.312500\nvt 0.750000 0.750000\nvt 0.718750 0.750000\nvt 0.750000 0.250000\nvt 0.718750 0.250000\nvt 0.750000 0.687500\nvt 0.718750 0.687500\nvt 0.750000 0.187500\nvt 0.718750 0.187500\nvt 0.750000 0.625000\nvt 0.718750 0.625000\nvt 0.750000 0.125000\nvt 0.718750 0.125000\nvt 0.750000 0.562500\nvt 0.718750 0.562500\nvt 0.687500 0.625000\nvt 0.687500 0.562500\nvt 0.687500 0.125000\nvt 0.687500 0.062500\nvt 0.687500 0.500000\nvt 0.703125 1.000000\nvt 0.687500 0.937500\nvt 0.703125 0.000000\nvt 0.687500 0.437500\nvt 0.687500 0.875000\nvt 0.687500 0.375000\nvt 0.687500 0.812500\nvt 0.687500 0.312500\nvt 0.687500 0.750000\nvt 0.687500 0.250000\nvt 0.687500 0.687500\nvt 0.687500 0.187500\nvt 0.656250 0.375000\nvt 0.656250 0.312500\nvt 0.656250 0.812500\nvt 0.656250 0.750000\nvt 0.656250 0.250000\nvt 0.656250 0.687500\nvt 0.656250 0.187500\nvt 0.656250 0.625000\nvt 0.656250 0.125000\nvt 0.656250 0.562500\nvt 0.656250 0.062500\nvt 0.656250 0.500000\nvt 0.671875 1.000000\nvt 0.656250 0.937500\nvt 0.671875 0.000000\nvt 0.656250 0.437500\nvt 0.656250 0.875000\nvt 0.625000 0.125000\nvt 0.625000 0.062500\nvt 0.625000 0.562500\nvt 0.625000 0.500000\nvt 0.640625 1.000000\nvt 0.625000 0.937500\nvt 0.640625 0.000000\nvt 0.625000 0.437500\nvt 0.625000 0.875000\nvt 0.625000 0.375000\nvt 0.625000 0.812500\nvt 0.625000 0.312500\nvt 0.625000 0.750000\nvt 0.625000 0.250000\nvt 0.625000 0.687500\nvt 0.625000 0.187500\nvt 0.625000 0.625000\nvt 0.593750 0.312500\nvt 0.593750 0.250000\nvt 0.593750 0.750000\nvt 0.593750 0.687500\nvt 0.593750 0.187500\nvt 0.593750 0.625000\nvt 0.593750 0.125000\nvt 0.593750 0.562500\nvt 0.593750 0.062500\nvt 0.593750 0.500000\nvt 0.609375 1.000000\nvt 0.593750 0.937500\nvt 0.609375 0.000000\nvt 0.593750 0.437500\nvt 0.593750 0.875000\nvt 0.593750 0.375000\nvt 0.593750 0.812500\nvt 0.578125 1.000000\nvt 0.562500 0.937500\nvt 0.578125 0.000000\nvt 0.562500 0.062500\nvt 0.562500 0.500000\nvt 0.562500 0.437500\nvt 0.562500 0.875000\nvt 0.562500 0.375000\nvt 0.562500 0.812500\nvt 0.562500 0.312500\nvt 0.562500 0.750000\nvt 0.562500 0.250000\nvt 0.562500 0.687500\nvt 0.562500 0.187500\nvt 0.562500 0.625000\nvt 0.562500 0.125000\nvt 0.562500 0.562500\nvt 0.531250 0.750000\nvt 0.531250 0.687500\nvt 0.531250 0.250000\nvt 0.531250 0.187500\nvt 0.531250 0.625000\nvt 0.531250 0.125000\nvt 0.531250 0.562500\nvt 0.531250 0.062500\nvt 0.531250 0.500000\nvt 0.546875 1.000000\nvt 0.531250 0.937500\nvt 0.546875 0.000000\nvt 0.531250 0.437500\nvt 0.531250 0.875000\nvt 0.531250 0.375000\nvt 0.531250 0.812500\nvt 0.531250 0.312500\nvt 0.500000 0.500000\nvt 0.500000 0.437500\nvt 0.500000 0.937500\nvt 0.500000 0.875000\nvt 0.500000 0.375000\nvt 0.500000 0.812500\nvt 0.500000 0.312500\nvt 0.500000 0.750000\nvt 0.500000 0.250000\nvt 0.500000 0.687500\nvt 0.500000 0.187500\nvt 0.500000 0.625000\nvt 0.500000 0.125000\nvt 0.500000 0.562500\nvt 0.500000 0.062500\nvt 0.515625 1.000000\nvt 0.515625 0.000000\nvt 0.468750 0.250000\nvt 0.468750 0.187500\nvt 0.468750 0.687500\nvt 0.468750 0.625000\nvt 0.468750 0.125000\nvt 0.468750 0.562500\nvt 0.468750 0.062500\nvt 0.468750 0.500000\nvt 0.484375 1.000000\nvt 0.468750 0.937500\nvt 0.484375 0.000000\nvt 0.468750 0.437500\nvt 0.468750 0.875000\nvt 0.468750 0.375000\nvt 0.468750 0.812500\nvt 0.468750 0.312500\nvt 0.468750 0.750000\nvt 0.437500 0.937500\nvt 0.437500 0.875000\nvt 0.437500 0.437500\nvt 0.437500 0.375000\nvt 0.437500 0.812500\nvt 0.437500 0.312500\nvt 0.437500 0.750000\nvt 0.437500 0.250000\nvt 0.437500 0.687500\nvt 0.437500 0.187500\nvt 0.437500 0.625000\nvt 0.437500 0.125000\nvt 0.437500 0.562500\nvt 0.437500 0.062500\nvt 0.437500 0.500000\nvt 0.453125 1.000000\nvt 0.453125 0.000000\nvt 0.406250 0.687500\nvt 0.406250 0.625000\nvt 0.406250 0.187500\nvt 0.406250 0.125000\nvt 0.406250 0.562500\nvt 0.406250 0.062500\nvt 0.406250 0.500000\nvt 0.421875 1.000000\nvt 0.406250 0.937500\nvt 0.421875 0.000000\nvt 0.406250 0.437500\nvt 0.406250 0.875000\nvt 0.406250 0.375000\nvt 0.406250 0.812500\nvt 0.406250 0.312500\nvt 0.406250 0.750000\nvt 0.406250 0.250000\nvt 0.375000 0.437500\nvt 0.375000 0.375000\nvt 0.375000 0.875000\nvt 0.375000 0.812500\nvt 0.375000 0.312500\nvt 0.375000 0.750000\nvt 0.375000 0.250000\nvt 0.375000 0.687500\nvt 0.375000 0.187500\nvt 0.375000 0.625000\nvt 0.375000 0.125000\nvt 0.375000 0.562500\nvt 0.375000 0.062500\nvt 0.375000 0.500000\nvt 0.390625 1.000000\nvt 0.375000 0.937500\nvt 0.390625 0.000000\nvt 0.343750 0.187500\nvt 0.343750 0.125000\nvt 0.343750 0.625000\nvt 0.343750 0.562500\nvt 0.343750 0.062500\nvt 0.343750 0.500000\nvt 0.359375 1.000000\nvt 0.343750 0.937500\nvt 0.359375 0.000000\nvt 0.343750 0.437500\nvt 0.343750 0.875000\nvt 0.343750 0.375000\nvt 0.343750 0.812500\nvt 0.343750 0.312500\nvt 0.343750 0.750000\nvt 0.343750 0.250000\nvt 0.343750 0.687500\nvt 0.312500 0.375000\nvt 0.312500 0.312500\nvt 0.312500 0.812500\nvt 0.312500 0.750000\nvt 0.312500 0.250000\nvt 0.312500 0.687500\nvt 0.312500 0.187500\nvt 0.312500 0.625000\nvt 0.312500 0.125000\nvt 0.312500 0.562500\nvt 0.312500 0.062500\nvt 0.312500 0.500000\nvt 0.328125 1.000000\nvt 0.312500 0.937500\nvt 0.328125 0.000000\nvt 0.312500 0.437500\nvt 0.312500 0.875000\nvt 0.281250 0.125000\nvt 0.281250 0.062500\nvt 0.281250 0.562500\nvt 0.281250 0.500000\nvt 0.296875 1.000000\nvt 0.281250 0.937500\nvt 0.296875 0.000000\nvt 0.281250 0.437500\nvt 0.281250 0.875000\nvt 0.281250 0.375000\nvt 0.281250 0.812500\nvt 0.281250 0.312500\nvt 0.281250 0.750000\nvt 0.281250 0.250000\nvt 0.281250 0.687500\nvt 0.281250 0.187500\nvt 0.281250 0.625000\nvt 0.250000 0.812500\nvt 0.250000 0.750000\nvt 0.250000 0.312500\nvt 0.250000 0.250000\nvt 0.250000 0.687500\nvt 0.250000 0.187500\nvt 0.250000 0.625000\nvt 0.250000 0.125000\nvt 0.250000 0.562500\nvt 0.250000 0.062500\nvt 0.250000 0.500000\nvt 0.265625 1.000000\nvt 0.250000 0.937500\nvt 0.265625 0.000000\nvt 0.250000 0.437500\nvt 0.250000 0.875000\nvt 0.250000 0.375000\nvt 0.218750 0.562500\nvt 0.218750 0.500000\nvt 0.234375 1.000000\nvt 0.218750 0.937500\nvt 0.234375 0.000000\nvt 0.218750 0.062500\nvt 0.218750 0.437500\nvt 0.218750 0.875000\nvt 0.218750 0.375000\nvt 0.218750 0.812500\nvt 0.218750 0.312500\nvt 0.218750 0.750000\nvt 0.218750 0.250000\nvt 0.218750 0.687500\nvt 0.218750 0.187500\nvt 0.218750 0.625000\nvt 0.218750 0.125000\nvt 0.187500 0.312500\nvt 0.187500 0.250000\nvt 0.187500 0.750000\nvt 0.187500 0.687500\nvt 0.187500 0.187500\nvt 0.187500 0.625000\nvt 0.187500 0.125000\nvt 0.187500 0.562500\nvt 0.187500 0.062500\nvt 0.187500 0.500000\nvt 0.203125 1.000000\nvt 0.187500 0.937500\nvt 0.203125 0.000000\nvt 0.187500 0.437500\nvt 0.187500 0.875000\nvt 0.187500 0.375000\nvt 0.187500 0.812500\nvt 0.171875 1.000000\nvt 0.156250 0.937500\nvt 0.171875 0.000000\nvt 0.156250 0.062500\nvt 0.156250 0.500000\nvt 0.156250 0.437500\nvt 0.156250 0.875000\nvt 0.156250 0.375000\nvt 0.156250 0.812500\nvt 0.156250 0.312500\nvt 0.156250 0.750000\nvt 0.156250 0.250000\nvt 0.156250 0.687500\nvt 0.156250 0.187500\nvt 0.156250 0.625000\nvt 0.156250 0.125000\nvt 0.156250 0.562500\nvt 0.125000 0.750000\nvt 0.125000 0.687500\nvt 0.125000 0.250000\nvt 0.125000 0.187500\nvt 0.125000 0.625000\nvt 0.125000 0.125000\nvt 0.125000 0.562500\nvt 0.125000 0.062500\nvt 0.125000 0.500000\nvt 0.140625 1.000000\nvt 0.125000 0.937500\nvt 0.140625 0.000000\nvt 0.125000 0.437500\nvt 0.125000 0.875000\nvt 0.125000 0.375000\nvt 0.125000 0.812500\nvt 0.125000 0.312500\nvt 0.093750 0.500000\nvt 0.093750 0.437500\nvt 0.093750 0.937500\nvt 0.093750 0.875000\nvt 0.093750 0.375000\nvt 0.093750 0.812500\nvt 0.093750 0.312500\nvt 0.093750 0.750000\nvt 0.093750 0.250000\nvt 0.093750 0.687500\nvt 0.093750 0.187500\nvt 0.093750 0.625000\nvt 0.093750 0.125000\nvt 0.093750 0.562500\nvt 0.093750 0.062500\nvt 0.109375 1.000000\nvt 0.109375 0.000000\nvt 0.062500 0.250000\nvt 0.062500 0.187500\nvt 0.062500 0.687500\nvt 0.062500 0.625000\nvt 0.062500 0.125000\nvt 0.062500 0.562500\nvt 0.062500 0.062500\nvt 0.062500 0.500000\nvt 0.078125 1.000000\nvt 0.062500 0.937500\nvt 0.078125 0.000000\nvt 0.062500 0.437500\nvt 0.062500 0.875000\nvt 0.062500 0.375000\nvt 0.062500 0.812500\nvt 0.062500 0.312500\nvt 0.062500 0.750000\nvt 0.031250 0.437500\nvt 0.031250 0.375000\nvt 0.031250 0.875000\nvt 0.031250 0.812500\nvt 0.031250 0.312500\nvt 0.031250 0.750000\nvt 0.031250 0.250000\nvt 0.031250 0.687500\nvt 0.031250 0.187500\nvt 0.031250 0.625000\nvt 0.031250 0.125000\nvt 0.031250 0.562500\nvt 0.031250 0.062500\nvt 0.031250 0.500000\nvt 0.046875 1.000000\nvt 0.031250 0.937500\nvt 0.046875 0.000000\nvt 0.000000 0.187500\nvt 0.000000 0.125000\nvt 0.000000 0.625000\nvt 0.000000 0.562500\nvt 0.000000 0.062500\nvt 0.000000 0.500000\nvt 0.015625 1.000000\nvt 0.000000 0.937500\nvt 0.015625 0.000000\nvt 0.000000 0.437500\nvt 0.000000 0.875000\nvt 0.000000 0.375000\nvt 0.000000 0.812500\nvt 0.000000 0.312500\nvt 0.000000 0.750000\nvt 0.000000 0.250000\nvt 0.000000 0.687500\nvt 1.000000 0.812500\nvt 1.000000 0.875000\nvt 0.968750 0.875000\nvt 0.968750 0.812500\nvt 1.000000 0.312500\nvt 1.000000 0.375000\nvt 0.968750 0.375000\nvt 0.968750 0.312500\nvt 1.000000 0.750000\nvt 0.968750 0.750000\nvt 1.000000 0.250000\nvt 0.968750 0.250000\nvt 1.000000 0.687500\nvt 0.968750 0.687500\nvt 1.000000 0.187500\nvt 0.968750 0.187500\nvt 1.000000 0.625000\nvt 0.968750 0.625000\nvt 1.000000 0.125000\nvt 0.968750 0.125000\nvt 1.000000 0.562500\nvt 0.968750 0.562500\nvt 1.000000 0.062500\nvt 0.968750 0.062500\nvt 1.000000 0.500000\nvt 0.968750 0.500000\nvt 1.000000 0.937500\nvt 0.984375 1.000000\nvt 0.968750 0.937500\nvt 0.984375 0.000000\nvt 1.000000 0.437500\nvt 0.968750 0.437500\nvt 0.937500 0.625000\nvt 0.937500 0.562500\nvt 0.937500 0.125000\nvt 0.937500 0.062500\nvt 0.937500 0.500000\nvt 0.953125 1.000000\nvt 0.937500 0.937500\nvt 0.953125 0.000000\nvt 0.937500 0.437500\nvt 0.937500 0.875000\nvt 0.937500 0.375000\nvt 0.937500 0.812500\nvt 0.937500 0.312500\nvt 0.937500 0.750000\nvt 0.937500 0.250000\nvt 0.937500 0.687500\nvt 0.937500 0.187500\nvt 0.906250 0.375000\nvt 0.906250 0.312500\nvt 0.906250 0.812500\nvt 0.906250 0.750000\nvt 0.906250 0.250000\nvt 0.906250 0.687500\nvt 0.906250 0.187500\nvt 0.906250 0.625000\nvt 0.906250 0.125000\nvt 0.906250 0.562500\nvt 0.906250 0.062500\nvt 0.906250 0.500000\nvt 0.921875 1.000000\nvt 0.906250 0.937500\nvt 0.921875 0.000000\nvt 0.906250 0.437500\nvt 0.906250 0.875000\nvt 0.875000 0.125000\nvt 0.875000 0.062500\nvt 0.875000 0.562500\nvt 0.875000 0.500000\nvt 0.890625 1.000000\nvt 0.875000 0.937500\nvt 0.890625 0.000000\nvt 0.875000 0.437500\nvt 0.875000 0.875000\nvt 0.875000 0.375000\nvt 0.875000 0.812500\nvt 0.875000 0.312500\nvt 0.875000 0.750000\nvt 0.875000 0.250000\nvt 0.875000 0.687500\nvt 0.875000 0.187500\nvt 0.875000 0.625000\nvt 0.843750 0.812500\nvt 0.843750 0.750000\nvt 0.843750 0.312500\nvt 0.843750 0.250000\nvt 0.843750 0.687500\nvt 0.843750 0.187500\nvt 0.843750 0.625000\nvt 0.843750 0.125000\nvt 0.843750 0.562500\nvt 0.843750 0.062500\nvt 0.843750 0.500000\nvt 0.859375 1.000000\nvt 0.843750 0.937500\nvt 0.859375 0.000000\nvt 0.843750 0.437500\nvt 0.843750 0.875000\nvt 0.843750 0.375000\nvt 0.812500 0.562500\nvt 0.812500 0.500000\nvt 0.828125 1.000000\nvt 0.812500 0.937500\nvt 0.828125 0.000000\nvt 0.812500 0.062500\nvt 0.812500 0.437500\nvt 0.812500 0.875000\nvt 0.812500 0.375000\nvt 0.812500 0.812500\nvt 0.812500 0.312500\nvt 0.812500 0.750000\nvt 0.812500 0.250000\nvt 0.812500 0.687500\nvt 0.812500 0.187500\nvt 0.812500 0.625000\nvt 0.812500 0.125000\nvt 0.781250 0.312500\nvt 0.781250 0.250000\nvt 0.781250 0.750000\nvt 0.781250 0.687500\nvt 0.781250 0.187500\nvt 0.781250 0.625000\nvt 0.781250 0.125000\nvt 0.781250 0.562500\nvt 0.781250 0.062500\nvt 0.781250 0.500000\nvt 0.796875 1.000000\nvt 0.781250 0.937500\nvt 0.796875 0.000000\nvt 0.781250 0.437500\nvt 0.781250 0.875000\nvt 0.781250 0.375000\nvt 0.781250 0.812500\nvt 0.765625 0.000000\nvt 0.765625 1.000000\nvn 0.0097 0.9951 -0.0980\nvn 0.0097 -0.9951 -0.0980\nvn 0.0975 -0.0975 -0.9904\nvn 0.0286 0.9565 -0.2902\nvn 0.0938 -0.2890 -0.9527\nvn 0.0464 0.8810 -0.4709\nvn 0.0865 -0.4696 -0.8786\nvn 0.0624 0.7715 -0.6332\nvn 0.0759 -0.6326 -0.7708\nvn 0.0759 0.6326 -0.7708\nvn 0.0624 -0.7715 -0.6332\nvn 0.0865 0.4696 -0.8786\nvn 0.0464 -0.8810 -0.4709\nvn 0.0938 0.2890 -0.9527\nvn 0.0286 -0.9565 -0.2902\nvn 0.0975 0.0975 -0.9904\nvn 0.2779 0.2890 -0.9161\nvn 0.0846 -0.9565 -0.2790\nvn 0.2889 0.0975 -0.9524\nvn 0.0286 0.9951 -0.0942\nvn 0.0286 -0.9951 -0.0942\nvn 0.2889 -0.0975 -0.9524\nvn 0.0846 0.9565 -0.2790\nvn 0.2779 -0.2890 -0.9161\nvn 0.1374 0.8810 -0.4528\nvn 0.2563 -0.4696 -0.8448\nvn 0.1847 0.7715 -0.6088\nvn 0.2248 -0.6326 -0.7412\nvn 0.2248 0.6326 -0.7412\nvn 0.1847 -0.7715 -0.6088\nvn 0.2563 0.4696 -0.8448\nvn 0.1374 -0.8810 -0.4528\nvn 0.4162 -0.4696 -0.7786\nvn 0.2999 0.7715 -0.5611\nvn 0.3651 -0.6326 -0.6831\nvn 0.3651 0.6326 -0.6831\nvn 0.2999 -0.7715 -0.5611\nvn 0.4162 0.4696 -0.7786\nvn 0.2230 -0.8810 -0.4173\nvn 0.4513 0.2890 -0.8443\nvn 0.1374 -0.9565 -0.2571\nvn 0.4691 0.0975 -0.8777\nvn 0.0464 0.9951 -0.0869\nvn 0.0464 -0.9951 -0.0869\nvn 0.4691 -0.0975 -0.8777\nvn 0.1374 0.9565 -0.2571\nvn 0.4513 -0.2890 -0.8443\nvn 0.2230 0.8810 -0.4173\nvn 0.1850 -0.9565 -0.2254\nvn 0.6314 0.0975 -0.7693\nvn 0.0625 0.9951 -0.0761\nvn 0.0625 -0.9951 -0.0761\nvn 0.6314 -0.0975 -0.7693\nvn 0.1850 0.9565 -0.2254\nvn 0.6073 -0.2890 -0.7400\nvn 0.3002 0.8810 -0.3658\nvn 0.5601 -0.4696 -0.6825\nvn 0.4036 0.7715 -0.4918\nvn 0.4913 -0.6326 -0.5987\nvn 0.4913 0.6326 -0.5987\nvn 0.4036 -0.7715 -0.4918\nvn 0.5601 0.4696 -0.6825\nvn 0.3002 -0.8810 -0.3658\nvn 0.6073 0.2890 -0.7400\nvn 0.5987 -0.6326 -0.4913\nvn 0.5987 0.6326 -0.4913\nvn 0.4918 -0.7715 -0.4036\nvn 0.6825 0.4696 -0.5601\nvn 0.3658 -0.8810 -0.3002\nvn 0.7400 0.2890 -0.6073\nvn 0.2254 -0.9565 -0.1850\nvn 0.7693 0.0975 -0.6314\nvn 0.0761 0.9951 -0.0625\nvn 0.0761 -0.9951 -0.0625\nvn 0.7693 -0.0975 -0.6314\nvn 0.2254 0.9565 -0.1850\nvn 0.7400 -0.2890 -0.6073\nvn 0.3658 0.8810 -0.3002\nvn 0.6825 -0.4696 -0.5601\nvn 0.4918 0.7715 -0.4036\nvn 0.0869 0.9951 -0.0464\nvn 0.0869 -0.9951 -0.0464\nvn 0.8777 -0.0975 -0.4691\nvn 0.2571 0.9565 -0.1374\nvn 0.8443 -0.2890 -0.4513\nvn 0.4173 0.8810 -0.2230\nvn 0.7786 -0.4696 -0.4162\nvn 0.5611 0.7715 -0.2999\nvn 0.6831 -0.6326 -0.3651\nvn 0.6831 0.6326 -0.3651\nvn 0.5611 -0.7715 -0.2999\nvn 0.7786 0.4696 -0.4162\nvn 0.4173 -0.8810 -0.2230\nvn 0.8443 0.2890 -0.4513\nvn 0.2571 -0.9565 -0.1374\nvn 0.8777 0.0975 -0.4691\nvn 0.7412 0.6326 -0.2248\nvn 0.6088 -0.7715 -0.1847\nvn 0.8448 0.4696 -0.2563\nvn 0.4528 -0.8810 -0.1374\nvn 0.9161 0.2890 -0.2779\nvn 0.2790 -0.9565 -0.0846\nvn 0.9524 0.0975 -0.2889\nvn 0.0942 0.9951 -0.0286\nvn 0.0942 -0.9951 -0.0286\nvn 0.9524 -0.0975 -0.2889\nvn 0.2790 0.9565 -0.0846\nvn 0.9161 -0.2890 -0.2779\nvn 0.4528 0.8810 -0.1374\nvn 0.8448 -0.4696 -0.2563\nvn 0.6088 0.7715 -0.1847\nvn 0.7412 -0.6326 -0.2248\nvn 0.9904 -0.0975 -0.0975\nvn 0.2902 0.9565 -0.0286\nvn 0.9527 -0.2890 -0.0938\nvn 0.4709 0.8810 -0.0464\nvn 0.8786 -0.4696 -0.0865\nvn 0.6332 0.7715 -0.0624\nvn 0.7708 -0.6326 -0.0759\nvn 0.7708 0.6326 -0.0759\nvn 0.6332 -0.7715 -0.0624\nvn 0.8786 0.4696 -0.0865\nvn 0.4709 -0.8810 -0.0464\nvn 0.9527 0.2890 -0.0938\nvn 0.2902 -0.9565 -0.0286\nvn 0.9904 0.0975 -0.0975\nvn 0.0980 0.9951 -0.0097\nvn 0.0980 -0.9951 -0.0097\nvn 0.6332 -0.7715 0.0624\nvn 0.8786 0.4696 0.0865\nvn 0.4709 -0.8810 0.0464\nvn 0.9527 0.2890 0.0938\nvn 0.2902 -0.9565 0.0286\nvn 0.9904 0.0975 0.0976\nvn 0.0980 0.9951 0.0097\nvn 0.0980 -0.9951 0.0097\nvn 0.9904 -0.0975 0.0976\nvn 0.2902 0.9565 0.0286\nvn 0.9527 -0.2890 0.0938\nvn 0.4709 0.8810 0.0464\nvn 0.8786 -0.4696 0.0865\nvn 0.6332 0.7715 0.0624\nvn 0.7708 -0.6326 0.0759\nvn 0.7708 0.6326 0.0759\nvn 0.2790 0.9565 0.0846\nvn 0.9161 -0.2890 0.2779\nvn 0.4528 0.8810 0.1374\nvn 0.8448 -0.4696 0.2563\nvn 0.6088 0.7715 0.1847\nvn 0.7412 -0.6326 0.2248\nvn 0.7412 0.6326 0.2248\nvn 0.6088 -0.7715 0.1847\nvn 0.8448 0.4696 0.2563\nvn 0.4528 -0.8810 0.1374\nvn 0.9161 0.2890 0.2779\nvn 0.2790 -0.9565 0.0846\nvn 0.9524 0.0975 0.2889\nvn 0.0942 0.9951 0.0286\nvn 0.0942 -0.9951 0.0286\nvn 0.9524 -0.0975 0.2889\nvn 0.7786 0.4696 0.4162\nvn 0.4173 -0.8810 0.2230\nvn 0.8443 0.2890 0.4513\nvn 0.2571 -0.9565 0.1374\nvn 0.8777 0.0975 0.4691\nvn 0.0869 0.9951 0.0464\nvn 0.0869 -0.9951 0.0464\nvn 0.8777 -0.0975 0.4691\nvn 0.2571 0.9565 0.1374\nvn 0.8443 -0.2890 0.4513\nvn 0.4173 0.8810 0.2230\nvn 0.7786 -0.4696 0.4162\nvn 0.5611 0.7715 0.2999\nvn 0.6831 -0.6326 0.3651\nvn 0.6831 0.6326 0.3651\nvn 0.5611 -0.7715 0.2999\nvn 0.7400 -0.2890 0.6073\nvn 0.3658 0.8810 0.3002\nvn 0.6825 -0.4696 0.5601\nvn 0.4918 0.7715 0.4036\nvn 0.5987 -0.6326 0.4913\nvn 0.5987 0.6326 0.4913\nvn 0.4918 -0.7715 0.4036\nvn 0.6825 0.4696 0.5601\nvn 0.3658 -0.8810 0.3002\nvn 0.7400 0.2890 0.6073\nvn 0.2254 -0.9565 0.1850\nvn 0.7693 0.0975 0.6314\nvn 0.0761 0.9951 0.0625\nvn 0.0761 -0.9951 0.0625\nvn 0.7693 -0.0975 0.6314\nvn 0.2254 0.9565 0.1850\nvn 0.3002 -0.8810 0.3658\nvn 0.6073 0.2890 0.7400\nvn 0.1850 -0.9565 0.2254\nvn 0.6314 0.0975 0.7693\nvn 0.0625 0.9951 0.0761\nvn 0.0625 -0.9951 0.0761\nvn 0.6314 -0.0975 0.7693\nvn 0.1850 0.9565 0.2254\nvn 0.6073 -0.2890 0.7400\nvn 0.3002 0.8810 0.3658\nvn 0.5601 -0.4696 0.6825\nvn 0.4036 0.7715 0.4918\nvn 0.4913 -0.6326 0.5987\nvn 0.4913 0.6326 0.5987\nvn 0.4036 -0.7715 0.4918\nvn 0.5601 0.4696 0.6825\nvn 0.4162 -0.4696 0.7786\nvn 0.2999 0.7715 0.5611\nvn 0.3651 -0.6326 0.6831\nvn 0.3651 0.6326 0.6831\nvn 0.2999 -0.7715 0.5611\nvn 0.4162 0.4696 0.7786\nvn 0.2230 -0.8810 0.4173\nvn 0.4513 0.2890 0.8443\nvn 0.1374 -0.9565 0.2571\nvn 0.4691 0.0975 0.8777\nvn 0.0464 0.9951 0.0869\nvn 0.0464 -0.9951 0.0869\nvn 0.4691 -0.0975 0.8777\nvn 0.1374 0.9565 0.2571\nvn 0.4513 -0.2890 0.8443\nvn 0.2230 0.8810 0.4173\nvn 0.0846 -0.9565 0.2790\nvn 0.2889 0.0975 0.9524\nvn 0.0286 0.9951 0.0942\nvn 0.0286 -0.9951 0.0942\nvn 0.2889 -0.0975 0.9524\nvn 0.0846 0.9565 0.2790\nvn 0.2779 -0.2890 0.9161\nvn 0.1374 0.8810 0.4528\nvn 0.2563 -0.4696 0.8448\nvn 0.1847 0.7715 0.6088\nvn 0.2248 -0.6326 0.7412\nvn 0.2248 0.6326 0.7412\nvn 0.1847 -0.7715 0.6088\nvn 0.2563 0.4696 0.8448\nvn 0.1374 -0.8810 0.4528\nvn 0.2779 0.2890 0.9161\nvn 0.0624 0.7715 0.6332\nvn 0.0759 -0.6326 0.7708\nvn 0.0759 0.6326 0.7708\nvn 0.0624 -0.7715 0.6332\nvn 0.0865 0.4696 0.8786\nvn 0.0464 -0.8810 0.4709\nvn 0.0938 0.2890 0.9527\nvn 0.0286 -0.9565 0.2902\nvn 0.0975 0.0975 0.9904\nvn 0.0097 0.9951 0.0980\nvn 0.0097 -0.9951 0.0980\nvn 0.0975 -0.0975 0.9904\nvn 0.0286 0.9565 0.2902\nvn 0.0938 -0.2890 0.9527\nvn 0.0464 0.8810 0.4709\nvn 0.0865 -0.4696 0.8786\nvn -0.0976 0.0975 0.9904\nvn -0.0097 0.9951 0.0980\nvn -0.0097 -0.9951 0.0980\nvn -0.0976 -0.0975 0.9904\nvn -0.0286 0.9565 0.2902\nvn -0.0938 -0.2890 0.9527\nvn -0.0464 0.8810 0.4709\nvn -0.0865 -0.4696 0.8786\nvn -0.0624 0.7715 0.6332\nvn -0.0759 -0.6326 0.7708\nvn -0.0759 0.6326 0.7708\nvn -0.0624 -0.7715 0.6332\nvn -0.0865 0.4696 0.8786\nvn -0.0464 -0.8810 0.4709\nvn -0.0938 0.2890 0.9527\nvn -0.0286 -0.9565 0.2902\nvn -0.2248 -0.6326 0.7412\nvn -0.2248 0.6326 0.7412\nvn -0.1847 -0.7715 0.6088\nvn -0.2563 0.4696 0.8448\nvn -0.1374 -0.8810 0.4528\nvn -0.2779 0.2890 0.9161\nvn -0.0846 -0.9565 0.2790\nvn -0.2889 0.0975 0.9524\nvn -0.0286 0.9951 0.0942\nvn -0.0286 -0.9951 0.0942\nvn -0.2889 -0.0975 0.9524\nvn -0.0846 0.9565 0.2790\nvn -0.2779 -0.2890 0.9161\nvn -0.1374 0.8810 0.4528\nvn -0.2563 -0.4696 0.8448\nvn -0.1847 0.7715 0.6088\nvn -0.0464 0.9951 0.0869\nvn -0.0464 -0.9951 0.0869\nvn -0.4691 -0.0975 0.8777\nvn -0.1374 0.9565 0.2571\nvn -0.4513 -0.2890 0.8443\nvn -0.2231 0.8810 0.4173\nvn -0.4162 -0.4696 0.7786\nvn -0.2999 0.7715 0.5611\nvn -0.3651 -0.6326 0.6831\nvn -0.3651 0.6326 0.6831\nvn -0.2999 -0.7715 0.5611\nvn -0.4162 0.4696 0.7786\nvn -0.2231 -0.8810 0.4173\nvn -0.4513 0.2890 0.8443\nvn -0.1374 -0.9565 0.2571\nvn -0.4691 0.0975 0.8777\nvn -0.4913 0.6326 0.5987\nvn -0.4036 -0.7715 0.4918\nvn -0.5601 0.4696 0.6825\nvn -0.3002 -0.8810 0.3658\nvn -0.6073 0.2890 0.7400\nvn -0.1850 -0.9565 0.2254\nvn -0.6314 0.0975 0.7693\nvn -0.0625 0.9951 0.0761\nvn -0.0625 -0.9951 0.0761\nvn -0.6314 -0.0975 0.7693\nvn -0.1850 0.9565 0.2254\nvn -0.6073 -0.2890 0.7400\nvn -0.3002 0.8810 0.3658\nvn -0.5601 -0.4696 0.6825\nvn -0.4036 0.7715 0.4918\nvn -0.4913 -0.6326 0.5987\nvn -0.7693 -0.0975 0.6314\nvn -0.2254 0.9565 0.1850\nvn -0.7400 -0.2890 0.6073\nvn -0.3658 0.8810 0.3002\nvn -0.6825 -0.4696 0.5601\nvn -0.4918 0.7715 0.4036\nvn -0.5987 -0.6326 0.4913\nvn -0.5987 0.6326 0.4913\nvn -0.4918 -0.7715 0.4036\nvn -0.6825 0.4696 0.5601\nvn -0.3658 -0.8810 0.3002\nvn -0.7400 0.2890 0.6073\nvn -0.2254 -0.9565 0.1850\nvn -0.7693 0.0975 0.6314\nvn -0.0761 0.9951 0.0625\nvn -0.0761 -0.9951 0.0625\nvn -0.5611 -0.7715 0.2999\nvn -0.7786 0.4696 0.4162\nvn -0.4173 -0.8810 0.2230\nvn -0.8443 0.2890 0.4513\nvn -0.2571 -0.9565 0.1374\nvn -0.8777 0.0975 0.4691\nvn -0.0869 0.9951 0.0464\nvn -0.0869 -0.9951 0.0464\nvn -0.8777 -0.0975 0.4691\nvn -0.2571 0.9565 0.1374\nvn -0.8443 -0.2890 0.4513\nvn -0.4173 0.8810 0.2230\nvn -0.7786 -0.4696 0.4162\nvn -0.5611 0.7715 0.2999\nvn -0.6831 -0.6326 0.3651\nvn -0.6831 0.6326 0.3651\nvn -0.9161 -0.2890 0.2779\nvn -0.4528 0.8810 0.1374\nvn -0.8448 -0.4696 0.2563\nvn -0.6088 0.7715 0.1847\nvn -0.7412 -0.6326 0.2248\nvn -0.7412 0.6326 0.2248\nvn -0.6088 -0.7715 0.1847\nvn -0.8448 0.4696 0.2563\nvn -0.4528 -0.8810 0.1374\nvn -0.9161 0.2890 0.2779\nvn -0.2790 -0.9565 0.0846\nvn -0.9524 0.0975 0.2889\nvn -0.0942 0.9951 0.0286\nvn -0.0942 -0.9951 0.0286\nvn -0.9524 -0.0975 0.2889\nvn -0.2790 0.9565 0.0846\nvn -0.4709 -0.8810 0.0464\nvn -0.9527 0.2890 0.0938\nvn -0.2902 -0.9565 0.0286\nvn -0.9904 0.0975 0.0975\nvn -0.0980 0.9951 0.0097\nvn -0.0980 -0.9951 0.0097\nvn -0.9904 -0.0975 0.0975\nvn -0.2902 0.9565 0.0286\nvn -0.9527 -0.2890 0.0938\nvn -0.4709 0.8810 0.0464\nvn -0.8786 -0.4696 0.0865\nvn -0.6332 0.7715 0.0624\nvn -0.7708 -0.6326 0.0759\nvn -0.7708 0.6326 0.0759\nvn -0.6332 -0.7715 0.0624\nvn -0.8786 0.4696 0.0865\nvn -0.4709 0.8810 -0.0464\nvn -0.8786 -0.4696 -0.0865\nvn -0.6332 0.7715 -0.0624\nvn -0.7708 -0.6326 -0.0759\nvn -0.7708 0.6326 -0.0759\nvn -0.6332 -0.7715 -0.0624\nvn -0.8786 0.4696 -0.0865\nvn -0.4709 -0.8810 -0.0464\nvn -0.9527 0.2890 -0.0938\nvn -0.2902 -0.9565 -0.0286\nvn -0.9904 0.0975 -0.0976\nvn -0.0980 0.9951 -0.0097\nvn -0.0980 -0.9951 -0.0097\nvn -0.9904 -0.0975 -0.0976\nvn -0.2902 0.9565 -0.0286\nvn -0.9527 -0.2890 -0.0938\nvn -0.9161 0.2890 -0.2779\nvn -0.2790 -0.9565 -0.0846\nvn -0.9524 0.0975 -0.2889\nvn -0.0942 0.9951 -0.0286\nvn -0.0942 -0.9951 -0.0286\nvn -0.9524 -0.0975 -0.2889\nvn -0.2790 0.9565 -0.0846\nvn -0.9161 -0.2890 -0.2779\nvn -0.4528 0.8810 -0.1374\nvn -0.8448 -0.4696 -0.2563\nvn -0.6088 0.7715 -0.1847\nvn -0.7412 -0.6326 -0.2248\nvn -0.7412 0.6326 -0.2248\nvn -0.6088 -0.7715 -0.1847\nvn -0.8448 0.4696 -0.2563\nvn -0.4528 -0.8810 -0.1374\nvn -0.7786 -0.4696 -0.4162\nvn -0.5611 0.7715 -0.2999\nvn -0.6831 -0.6326 -0.3651\nvn -0.6831 0.6326 -0.3651\nvn -0.5611 -0.7715 -0.2999\nvn -0.7786 0.4696 -0.4162\nvn -0.4173 -0.8810 -0.2230\nvn -0.8443 0.2890 -0.4513\nvn -0.2571 -0.9565 -0.1374\nvn -0.8777 0.0975 -0.4691\nvn -0.0869 0.9951 -0.0464\nvn -0.0869 -0.9951 -0.0464\nvn -0.8777 -0.0975 -0.4691\nvn -0.2571 0.9565 -0.1374\nvn -0.8443 -0.2890 -0.4513\nvn -0.4173 0.8810 -0.2230\nvn -0.2254 -0.9565 -0.1850\nvn -0.7693 0.0975 -0.6314\nvn -0.0761 0.9951 -0.0625\nvn -0.0761 -0.9951 -0.0625\nvn -0.7693 -0.0975 -0.6314\nvn -0.2254 0.9565 -0.1850\nvn -0.7400 -0.2890 -0.6073\nvn -0.3658 0.8810 -0.3002\nvn -0.6825 -0.4696 -0.5601\nvn -0.4918 0.7715 -0.4036\nvn -0.5987 -0.6326 -0.4913\nvn -0.5987 0.6326 -0.4913\nvn -0.4918 -0.7715 -0.4036\nvn -0.6825 0.4696 -0.5601\nvn -0.3658 -0.8810 -0.3002\nvn -0.7400 0.2890 -0.6073\nvn -0.4036 0.7715 -0.4918\nvn -0.4913 -0.6326 -0.5987\nvn -0.4913 0.6326 -0.5987\nvn -0.4036 -0.7715 -0.4918\nvn -0.5601 0.4696 -0.6825\nvn -0.3002 -0.8810 -0.3658\nvn -0.6073 0.2890 -0.7400\nvn -0.1850 -0.9565 -0.2254\nvn -0.6314 0.0975 -0.7693\nvn -0.0625 0.9951 -0.0761\nvn -0.0625 -0.9951 -0.0761\nvn -0.6314 -0.0975 -0.7693\nvn -0.1850 0.9565 -0.2254\nvn -0.6073 -0.2890 -0.7400\nvn -0.3002 0.8810 -0.3658\nvn -0.5601 -0.4696 -0.6825\nvn -0.4691 0.0975 -0.8777\nvn -0.0464 0.9951 -0.0869\nvn -0.0464 -0.9951 -0.0869\nvn -0.4691 -0.0975 -0.8777\nvn -0.1374 0.9565 -0.2571\nvn -0.4513 -0.2890 -0.8443\nvn -0.2231 0.8810 -0.4173\nvn -0.4162 -0.4696 -0.7786\nvn -0.2999 0.7715 -0.5611\nvn -0.3651 -0.6326 -0.6831\nvn -0.3651 0.6326 -0.6831\nvn -0.2999 -0.7715 -0.5611\nvn -0.4162 0.4696 -0.7786\nvn -0.2230 -0.8810 -0.4173\nvn -0.4513 0.2890 -0.8443\nvn -0.1374 -0.9565 -0.2571\nvn -0.2248 -0.6326 -0.7412\nvn -0.2248 0.6326 -0.7412\nvn -0.1847 -0.7715 -0.6088\nvn -0.2563 0.4696 -0.8448\nvn -0.1374 -0.8810 -0.4528\nvn -0.2779 0.2890 -0.9161\nvn -0.0846 -0.9565 -0.2790\nvn -0.2889 0.0975 -0.9524\nvn -0.0286 0.9951 -0.0942\nvn -0.0286 -0.9951 -0.0942\nvn -0.2889 -0.0975 -0.9524\nvn -0.0846 0.9565 -0.2790\nvn -0.2779 -0.2890 -0.9161\nvn -0.1374 0.8810 -0.4528\nvn -0.2563 -0.4696 -0.8448\nvn -0.1847 0.7715 -0.6088\nvn -0.0097 -0.9951 -0.0980\nvn -0.0975 -0.0975 -0.9904\nvn -0.0286 0.9565 -0.2902\nvn -0.0938 -0.2890 -0.9527\nvn -0.0464 0.8810 -0.4709\nvn -0.0865 -0.4696 -0.8786\nvn -0.0624 0.7715 -0.6332\nvn -0.0759 -0.6326 -0.7708\nvn -0.0759 0.6326 -0.7708\nvn -0.0624 -0.7715 -0.6332\nvn -0.0865 0.4696 -0.8786\nvn -0.0464 -0.8810 -0.4709\nvn -0.0938 0.2890 -0.9527\nvn -0.0286 -0.9565 -0.2902\nvn -0.0976 0.0975 -0.9904\nvn -0.0097 0.9951 -0.0980\ng Sphere_Sphere_Material.001\nusemtl Material.001\ns off\nf 1/1/1 326/2/1 11/3/1\nf 482/4/2 481/5/2 25/6/2\nf 478/7/3 477/8/3 18/9/3 19/10/3\nf 2/11/4 1/1/4 11/3/4 12/12/4\nf 479/13/5 478/7/5 19/10/5 20/14/5\nf 3/15/6 2/11/6 12/12/6 13/16/6\nf 8/17/7 479/13/7 20/14/7 21/18/7\nf 4/19/8 3/15/8 13/16/8 14/20/8\nf 9/21/9 8/17/9 21/18/9 22/22/9\nf 5/23/10 4/19/10 14/20/10 15/24/10\nf 10/25/11 9/21/11 22/22/11 23/26/11\nf 6/27/12 5/23/12 15/24/12 16/28/12\nf 480/29/13 10/25/13 23/26/13 24/30/13\nf 7/31/14 6/27/14 16/28/14 17/32/14\nf 481/5/15 480/29/15 24/30/15 25/6/15\nf 477/8/16 7/31/16 17/32/16 18/9/16\nf 17/32/17 16/28/17 31/33/17 32/34/17\nf 25/6/18 24/30/18 39/35/18 40/36/18\nf 18/9/19 17/32/19 32/34/19 33/37/19\nf 11/3/20 326/38/20 26/39/20\nf 482/40/21 25/6/21 40/36/21\nf 19/10/22 18/9/22 33/37/22 34/41/22\nf 12/12/23 11/3/23 26/39/23 27/42/23\nf 20/14/24 19/10/24 34/41/24 35/43/24\nf 13/16/25 12/12/25 27/42/25 28/44/25\nf 21/18/26 20/14/26 35/43/26 36/45/26\nf 14/20/27 13/16/27 28/44/27 29/46/27\nf 22/22/28 21/18/28 36/45/28 37/47/28\nf 15/24/29 14/20/29 29/46/29 30/48/29\nf 23/26/30 22/22/30 37/47/30 38/49/30\nf 16/28/31 15/24/31 30/48/31 31/33/31\nf 24/30/32 23/26/32 38/49/32 39/35/32\nf 36/45/33 35/43/33 50/50/33 51/51/33\nf 29/46/34 28/44/34 43/52/34 44/53/34\nf 37/47/35 36/45/35 51/51/35 52/54/35\nf 30/48/36 29/46/36 44/53/36 45/55/36\nf 38/49/37 37/47/37 52/54/37 53/56/37\nf 31/33/38 30/48/38 45/55/38 46/57/38\nf 39/35/39 38/49/39 53/56/39 54/58/39\nf 32/34/40 31/33/40 46/57/40 47/59/40\nf 40/36/41 39/35/41 54/58/41 55/60/41\nf 33/37/42 32/34/42 47/59/42 48/61/42\nf 26/39/43 326/62/43 41/63/43\nf 482/64/44 40/36/44 55/60/44\nf 34/41/45 33/37/45 48/61/45 49/65/45\nf 27/42/46 26/39/46 41/63/46 42/66/46\nf 35/43/47 34/41/47 49/65/47 50/50/47\nf 28/44/48 27/42/48 42/66/48 43/52/48\nf 55/60/49 54/58/49 69/67/49 70/68/49\nf 48/61/50 47/59/50 62/69/50 63/70/50\nf 41/63/51 326/71/51 56/72/51\nf 482/73/52 55/60/52 70/68/52\nf 49/65/53 48/61/53 63/70/53 64/74/53\nf 42/66/54 41/63/54 56/72/54 57/75/54\nf 50/50/55 49/65/55 64/74/55 65/76/55\nf 43/52/56 42/66/56 57/75/56 58/77/56\nf 51/51/57 50/50/57 65/76/57 66/78/57\nf 44/53/58 43/52/58 58/77/58 59/79/58\nf 52/54/59 51/51/59 66/78/59 67/80/59\nf 45/55/60 44/53/60 59/79/60 60/81/60\nf 53/56/61 52/54/61 67/80/61 68/82/61\nf 46/57/62 45/55/62 60/81/62 61/83/62\nf 54/58/63 53/56/63 68/82/63 69/67/63\nf 47/59/64 46/57/64 61/83/64 62/69/64\nf 67/80/65 66/78/65 81/84/65 82/85/65\nf 60/81/66 59/79/66 74/86/66 75/87/66\nf 68/82/67 67/80/67 82/85/67 83/88/67\nf 61/83/68 60/81/68 75/87/68 76/89/68\nf 69/67/69 68/82/69 83/88/69 84/90/69\nf 62/69/70 61/83/70 76/89/70 77/91/70\nf 70/68/71 69/67/71 84/90/71 85/92/71\nf 63/70/72 62/69/72 77/91/72 78/93/72\nf 56/72/73 326/94/73 71/95/73\nf 482/96/74 70/68/74 85/92/74\nf 64/74/75 63/70/75 78/93/75 79/97/75\nf 57/75/76 56/72/76 71/95/76 72/98/76\nf 65/76/77 64/74/77 79/97/77 80/99/77\nf 58/77/78 57/75/78 72/98/78 73/100/78\nf 66/78/79 65/76/79 80/99/79 81/84/79\nf 59/79/80 58/77/80 73/100/80 74/86/80\nf 71/95/81 326/101/81 86/102/81\nf 482/103/82 85/92/82 100/104/82\nf 79/97/83 78/93/83 93/105/83 94/106/83\nf 72/98/84 71/95/84 86/102/84 87/107/84\nf 80/99/85 79/97/85 94/106/85 95/108/85\nf 73/100/86 72/98/86 87/107/86 88/109/86\nf 81/84/87 80/99/87 95/108/87 96/110/87\nf 74/86/88 73/100/88 88/109/88 89/111/88\nf 82/85/89 81/84/89 96/110/89 97/112/89\nf 75/87/90 74/86/90 89/111/90 90/113/90\nf 83/88/91 82/85/91 97/112/91 98/114/91\nf 76/89/92 75/87/92 90/113/92 91/115/92\nf 84/90/93 83/88/93 98/114/93 99/116/93\nf 77/91/94 76/89/94 91/115/94 92/117/94\nf 85/92/95 84/90/95 99/116/95 100/104/95\nf 78/93/96 77/91/96 92/117/96 93/105/96\nf 90/113/97 89/111/97 104/118/97 105/119/97\nf 98/114/98 97/112/98 112/120/98 113/121/98\nf 91/115/99 90/113/99 105/119/99 106/122/99\nf 99/116/100 98/114/100 113/121/100 114/123/100\nf 92/117/101 91/115/101 106/122/101 107/124/101\nf 100/104/102 99/116/102 114/123/102 115/125/102\nf 93/105/103 92/117/103 107/124/103 108/126/103\nf 86/102/104 326/127/104 101/128/104\nf 482/129/105 100/104/105 115/125/105\nf 94/106/106 93/105/106 108/126/106 109/130/106\nf 87/107/107 86/102/107 101/128/107 102/131/107\nf 95/108/108 94/106/108 109/130/108 110/132/108\nf 88/109/109 87/107/109 102/131/109 103/133/109\nf 96/110/110 95/108/110 110/132/110 111/134/110\nf 89/111/111 88/109/111 103/133/111 104/118/111\nf 97/112/112 96/110/112 111/134/112 112/120/112\nf 109/130/113 108/126/113 123/135/113 124/136/113\nf 102/131/114 101/128/114 116/137/114 117/138/114\nf 110/132/115 109/130/115 124/136/115 125/139/115\nf 103/133/116 102/131/116 117/138/116 118/140/116\nf 111/134/117 110/132/117 125/139/117 126/141/117\nf 104/118/118 103/133/118 118/140/118 119/142/118\nf 112/120/119 111/134/119 126/141/119 127/143/119\nf 105/119/120 104/118/120 119/142/120 120/144/120\nf 113/121/121 112/120/121 127/143/121 128/145/121\nf 106/122/122 105/119/122 120/144/122 121/146/122\nf 114/123/123 113/121/123 128/145/123 129/147/123\nf 107/124/124 106/122/124 121/146/124 122/148/124\nf 115/125/125 114/123/125 129/147/125 130/149/125\nf 108/126/126 107/124/126 122/148/126 123/135/126\nf 101/128/127 326/150/127 116/137/127\nf 482/151/128 115/125/128 130/149/128\nf 128/145/129 127/143/129 142/152/129 143/153/129\nf 121/146/130 120/144/130 135/154/130 136/155/130\nf 129/147/131 128/145/131 143/153/131 144/156/131\nf 122/148/132 121/146/132 136/155/132 137/157/132\nf 130/149/133 129/147/133 144/156/133 145/158/133\nf 123/135/134 122/148/134 137/157/134 138/159/134\nf 116/137/135 326/160/135 131/161/135\nf 482/162/136 130/149/136 145/158/136\nf 124/136/137 123/135/137 138/159/137 139/163/137\nf 117/138/138 116/137/138 131/161/138 132/164/138\nf 125/139/139 124/136/139 139/163/139 140/165/139\nf 118/140/140 117/138/140 132/164/140 133/166/140\nf 126/141/141 125/139/141 140/165/141 141/167/141\nf 119/142/142 118/140/142 133/166/142 134/168/142\nf 127/143/143 126/141/143 141/167/143 142/152/143\nf 120/144/144 119/142/144 134/168/144 135/154/144\nf 132/164/145 131/161/145 146/169/145 147/170/145\nf 140/165/146 139/163/146 154/171/146 155/172/146\nf 133/166/147 132/164/147 147/170/147 148/173/147\nf 141/167/148 140/165/148 155/172/148 156/174/148\nf 134/168/149 133/166/149 148/173/149 149/175/149\nf 142/152/150 141/167/150 156/174/150 157/176/150\nf 135/154/151 134/168/151 149/175/151 150/177/151\nf 143/153/152 142/152/152 157/176/152 158/178/152\nf 136/155/153 135/154/153 150/177/153 151/179/153\nf 144/156/154 143/153/154 158/178/154 159/180/154\nf 137/157/155 136/155/155 151/179/155 152/181/155\nf 145/158/156 144/156/156 159/180/156 160/182/156\nf 138/159/157 137/157/157 152/181/157 153/183/157\nf 131/161/158 326/184/158 146/169/158\nf 482/185/159 145/158/159 160/182/159\nf 139/163/160 138/159/160 153/183/160 154/171/160\nf 151/179/161 150/177/161 165/186/161 166/187/161\nf 159/180/162 158/178/162 173/188/162 174/189/162\nf 152/181/163 151/179/163 166/187/163 167/190/163\nf 160/182/164 159/180/164 174/189/164 175/191/164\nf 153/183/165 152/181/165 167/190/165 168/192/165\nf 146/169/166 326/193/166 161/194/166\nf 482/195/167 160/182/167 175/191/167\nf 154/171/168 153/183/168 168/192/168 169/196/168\nf 147/170/169 146/169/169 161/194/169 162/197/169\nf 155/172/170 154/171/170 169/196/170 170/198/170\nf 148/173/171 147/170/171 162/197/171 163/199/171\nf 156/174/172 155/172/172 170/198/172 171/200/172\nf 149/175/173 148/173/173 163/199/173 164/201/173\nf 157/176/174 156/174/174 171/200/174 172/202/174\nf 150/177/175 149/175/175 164/201/175 165/186/175\nf 158/178/176 157/176/176 172/202/176 173/188/176\nf 170/198/177 169/196/177 184/203/177 185/204/177\nf 163/199/178 162/197/178 177/205/178 178/206/178\nf 171/200/179 170/198/179 185/204/179 186/207/179\nf 164/201/180 163/199/180 178/206/180 179/208/180\nf 172/202/181 171/200/181 186/207/181 187/209/181\nf 165/186/182 164/201/182 179/208/182 180/210/182\nf 173/188/183 172/202/183 187/209/183 188/211/183\nf 166/187/184 165/186/184 180/210/184 181/212/184\nf 174/189/185 173/188/185 188/211/185 189/213/185\nf 167/190/186 166/187/186 181/212/186 182/214/186\nf 175/191/187 174/189/187 189/213/187 190/215/187\nf 168/192/188 167/190/188 182/214/188 183/216/188\nf 161/194/189 326/217/189 176/218/189\nf 482/219/190 175/191/190 190/215/190\nf 169/196/191 168/192/191 183/216/191 184/203/191\nf 162/197/192 161/194/192 176/218/192 177/205/192\nf 189/213/193 188/211/193 203/220/193 204/221/193\nf 182/214/194 181/212/194 196/222/194 197/223/194\nf 190/215/195 189/213/195 204/221/195 205/224/195\nf 183/216/196 182/214/196 197/223/196 198/225/196\nf 176/218/197 326/226/197 191/227/197\nf 482/228/198 190/215/198 205/224/198\nf 184/203/199 183/216/199 198/225/199 199/229/199\nf 177/205/200 176/218/200 191/227/200 192/230/200\nf 185/204/201 184/203/201 199/229/201 200/231/201\nf 178/206/202 177/205/202 192/230/202 193/232/202\nf 186/207/203 185/204/203 200/231/203 201/233/203\nf 179/208/204 178/206/204 193/232/204 194/234/204\nf 187/209/205 186/207/205 201/233/205 202/235/205\nf 180/210/206 179/208/206 194/234/206 195/236/206\nf 188/211/207 187/209/207 202/235/207 203/220/207\nf 181/212/208 180/210/208 195/236/208 196/222/208\nf 201/233/209 200/231/209 215/237/209 216/238/209\nf 194/234/210 193/232/210 208/239/210 209/240/210\nf 202/235/211 201/233/211 216/238/211 217/241/211\nf 195/236/212 194/234/212 209/240/212 210/242/212\nf 203/220/213 202/235/213 217/241/213 218/243/213\nf 196/222/214 195/236/214 210/242/214 211/244/214\nf 204/221/215 203/220/215 218/243/215 219/245/215\nf 197/223/216 196/222/216 211/244/216 212/246/216\nf 205/224/217 204/221/217 219/245/217 220/247/217\nf 198/225/218 197/223/218 212/246/218 213/248/218\nf 191/227/219 326/249/219 206/250/219\nf 482/251/220 205/224/220 220/247/220\nf 199/229/221 198/225/221 213/248/221 214/252/221\nf 192/230/222 191/227/222 206/250/222 207/253/222\nf 200/231/223 199/229/223 214/252/223 215/237/223\nf 193/232/224 192/230/224 207/253/224 208/239/224\nf 220/247/225 219/245/225 234/254/225 235/255/225\nf 213/248/226 212/246/226 227/256/226 228/257/226\nf 206/250/227 326/258/227 221/259/227\nf 482/260/228 220/247/228 235/255/228\nf 214/252/229 213/248/229 228/257/229 229/261/229\nf 207/253/230 206/250/230 221/259/230 222/262/230\nf 215/237/231 214/252/231 229/261/231 230/263/231\nf 208/239/232 207/253/232 222/262/232 223/264/232\nf 216/238/233 215/237/233 230/263/233 231/265/233\nf 209/240/234 208/239/234 223/264/234 224/266/234\nf 217/241/235 216/238/235 231/265/235 232/267/235\nf 210/242/236 209/240/236 224/266/236 225/268/236\nf 218/243/237 217/241/237 232/267/237 233/269/237\nf 211/244/238 210/242/238 225/268/238 226/270/238\nf 219/245/239 218/243/239 233/269/239 234/254/239\nf 212/246/240 211/244/240 226/270/240 227/256/240\nf 224/266/241 223/264/241 238/271/241 239/272/241\nf 232/267/242 231/265/242 246/273/242 247/274/242\nf 225/268/243 224/266/243 239/272/243 240/275/243\nf 233/269/244 232/267/244 247/274/244 248/276/244\nf 226/270/245 225/268/245 240/275/245 241/277/245\nf 234/254/246 233/269/246 248/276/246 249/278/246\nf 227/256/247 226/270/247 241/277/247 242/279/247\nf 235/255/248 234/254/248 249/278/248 250/280/248\nf 228/257/249 227/256/249 242/279/249 243/281/249\nf 221/259/250 326/282/250 236/283/250\nf 482/284/251 235/255/251 250/280/251\nf 229/261/252 228/257/252 243/281/252 244/285/252\nf 222/262/253 221/259/253 236/283/253 237/286/253\nf 230/263/254 229/261/254 244/285/254 245/287/254\nf 223/264/255 222/262/255 237/286/255 238/271/255\nf 231/265/256 230/263/256 245/287/256 246/273/256\nf 243/281/257 242/279/257 257/288/257 258/289/257\nf 236/283/258 326/290/258 251/291/258\nf 482/292/259 250/280/259 265/293/259\nf 244/285/260 243/281/260 258/289/260 259/294/260\nf 237/286/261 236/283/261 251/291/261 252/295/261\nf 245/287/262 244/285/262 259/294/262 260/296/262\nf 238/271/263 237/286/263 252/295/263 253/297/263\nf 246/273/264 245/287/264 260/296/264 261/298/264\nf 239/272/265 238/271/265 253/297/265 254/299/265\nf 247/274/266 246/273/266 261/298/266 262/300/266\nf 240/275/267 239/272/267 254/299/267 255/301/267\nf 248/276/268 247/274/268 262/300/268 263/302/268\nf 241/277/269 240/275/269 255/301/269 256/303/269\nf 249/278/270 248/276/270 263/302/270 264/304/270\nf 242/279/271 241/277/271 256/303/271 257/288/271\nf 250/280/272 249/278/272 264/304/272 265/293/272\nf 262/300/273 261/298/273 276/305/273 277/306/273\nf 255/301/274 254/299/274 269/307/274 270/308/274\nf 263/302/275 262/300/275 277/306/275 278/309/275\nf 256/303/276 255/301/276 270/308/276 271/310/276\nf 264/304/277 263/302/277 278/309/277 279/311/277\nf 257/288/278 256/303/278 271/310/278 272/312/278\nf 265/293/279 264/304/279 279/311/279 280/313/279\nf 258/289/280 257/288/280 272/312/280 273/314/280\nf 251/291/281 326/315/281 266/316/281\nf 482/317/282 265/293/282 280/313/282\nf 259/294/283 258/289/283 273/314/283 274/318/283\nf 252/295/284 251/291/284 266/316/284 267/319/284\nf 260/296/285 259/294/285 274/318/285 275/320/285\nf 253/297/286 252/295/286 267/319/286 268/321/286\nf 261/298/287 260/296/287 275/320/287 276/305/287\nf 254/299/288 253/297/288 268/321/288 269/307/288\nf 266/316/289 326/322/289 281/323/289\nf 482/324/290 280/313/290 295/325/290\nf 274/318/291 273/314/291 288/326/291 289/327/291\nf 267/319/292 266/316/292 281/323/292 282/328/292\nf 275/320/293 274/318/293 289/327/293 290/329/293\nf 268/321/294 267/319/294 282/328/294 283/330/294\nf 276/305/295 275/320/295 290/329/295 291/331/295\nf 269/307/296 268/321/296 283/330/296 284/332/296\nf 277/306/297 276/305/297 291/331/297 292/333/297\nf 270/308/298 269/307/298 284/332/298 285/334/298\nf 278/309/299 277/306/299 292/333/299 293/335/299\nf 271/310/300 270/308/300 285/334/300 286/336/300\nf 279/311/301 278/309/301 293/335/301 294/337/301\nf 272/312/302 271/310/302 286/336/302 287/338/302\nf 280/313/303 279/311/303 294/337/303 295/325/303\nf 273/314/304 272/312/304 287/338/304 288/326/304\nf 285/334/305 284/332/305 299/339/305 300/340/305\nf 293/335/306 292/333/306 307/341/306 308/342/306\nf 286/336/307 285/334/307 300/340/307 301/343/307\nf 294/337/308 293/335/308 308/342/308 309/344/308\nf 287/338/309 286/336/309 301/343/309 302/345/309\nf 295/325/310 294/337/310 309/344/310 310/346/310\nf 288/326/311 287/338/311 302/345/311 303/347/311\nf 281/323/312 326/348/312 296/349/312\nf 482/350/313 295/325/313 310/346/313\nf 289/327/314 288/326/314 303/347/314 304/351/314\nf 282/328/315 281/323/315 296/349/315 297/352/315\nf 290/329/316 289/327/316 304/351/316 305/353/316\nf 283/330/317 282/328/317 297/352/317 298/354/317\nf 291/331/318 290/329/318 305/353/318 306/355/318\nf 284/332/319 283/330/319 298/354/319 299/339/319\nf 292/333/320 291/331/320 306/355/320 307/341/320\nf 304/351/321 303/347/321 318/356/321 319/357/321\nf 297/352/322 296/349/322 311/358/322 312/359/322\nf 305/353/323 304/351/323 319/357/323 320/360/323\nf 298/354/324 297/352/324 312/359/324 313/361/324\nf 306/355/325 305/353/325 320/360/325 321/362/325\nf 299/339/326 298/354/326 313/361/326 314/363/326\nf 307/341/327 306/355/327 321/362/327 322/364/327\nf 300/340/328 299/339/328 314/363/328 315/365/328\nf 308/342/329 307/341/329 322/364/329 323/366/329\nf 301/343/330 300/340/330 315/365/330 316/367/330\nf 309/344/331 308/342/331 323/366/331 324/368/331\nf 302/345/332 301/343/332 316/367/332 317/369/332\nf 310/346/333 309/344/333 324/368/333 325/370/333\nf 303/347/334 302/345/334 317/369/334 318/356/334\nf 296/349/335 326/371/335 311/358/335\nf 482/372/336 310/346/336 325/370/336\nf 323/366/337 322/364/337 338/373/337 339/374/337\nf 316/367/338 315/365/338 331/375/338 332/376/338\nf 324/368/339 323/366/339 339/374/339 340/377/339\nf 317/369/340 316/367/340 332/376/340 333/378/340\nf 325/370/341 324/368/341 340/377/341 341/379/341\nf 318/356/342 317/369/342 333/378/342 334/380/342\nf 311/358/343 326/381/343 327/382/343\nf 482/383/344 325/370/344 341/379/344\nf 319/357/345 318/356/345 334/380/345 335/384/345\nf 312/359/346 311/358/346 327/382/346 328/385/346\nf 320/360/347 319/357/347 335/384/347 336/386/347\nf 313/361/348 312/359/348 328/385/348 329/387/348\nf 321/362/349 320/360/349 336/386/349 337/388/349\nf 314/363/350 313/361/350 329/387/350 330/389/350\nf 322/364/351 321/362/351 337/388/351 338/373/351\nf 315/365/352 314/363/352 330/389/352 331/375/352\nf 336/386/353 335/384/353 350/390/353 351/391/353\nf 329/387/354 328/385/354 343/392/354 344/393/354\nf 337/388/355 336/386/355 351/391/355 352/394/355\nf 330/389/356 329/387/356 344/393/356 345/395/356\nf 338/373/357 337/388/357 352/394/357 353/396/357\nf 331/375/358 330/389/358 345/395/358 346/397/358\nf 339/374/359 338/373/359 353/396/359 354/398/359\nf 332/376/360 331/375/360 346/397/360 347/399/360\nf 340/377/361 339/374/361 354/398/361 355/400/361\nf 333/378/362 332/376/362 347/399/362 348/401/362\nf 341/379/363 340/377/363 355/400/363 356/402/363\nf 334/380/364 333/378/364 348/401/364 349/403/364\nf 327/382/365 326/404/365 342/405/365\nf 482/406/366 341/379/366 356/402/366\nf 335/384/367 334/380/367 349/403/367 350/390/367\nf 328/385/368 327/382/368 342/405/368 343/392/368\nf 355/400/369 354/398/369 369/407/369 370/408/369\nf 348/401/370 347/399/370 362/409/370 363/410/370\nf 356/402/371 355/400/371 370/408/371 371/411/371\nf 349/403/372 348/401/372 363/410/372 364/412/372\nf 342/405/373 326/413/373 357/414/373\nf 482/415/374 356/402/374 371/411/374\nf 350/390/375 349/403/375 364/412/375 365/416/375\nf 343/392/376 342/405/376 357/414/376 358/417/376\nf 351/391/377 350/390/377 365/416/377 366/418/377\nf 344/393/378 343/392/378 358/417/378 359/419/378\nf 352/394/379 351/391/379 366/418/379 367/420/379\nf 345/395/380 344/393/380 359/419/380 360/421/380\nf 353/396/381 352/394/381 367/420/381 368/422/381\nf 346/397/382 345/395/382 360/421/382 361/423/382\nf 354/398/383 353/396/383 368/422/383 369/407/383\nf 347/399/384 346/397/384 361/423/384 362/409/384\nf 359/424/385 358/425/385 373/426/385 374/427/385\nf 367/428/386 366/429/386 381/430/386 382/431/386\nf 360/432/387 359/424/387 374/427/387 375/433/387\nf 368/434/388 367/428/388 382/431/388 383/435/388\nf 361/436/389 360/432/389 375/433/389 376/437/389\nf 369/438/390 368/434/390 383/435/390 384/439/390\nf 362/440/391 361/436/391 376/437/391 377/441/391\nf 370/442/392 369/438/392 384/439/392 385/443/392\nf 363/444/393 362/440/393 377/441/393 378/445/393\nf 371/446/394 370/442/394 385/443/394 386/447/394\nf 364/448/395 363/444/395 378/445/395 379/449/395\nf 357/450/396 326/451/396 372/452/396\nf 482/453/397 371/446/397 386/447/397\nf 365/454/398 364/448/398 379/449/398 380/455/398\nf 358/425/399 357/450/399 372/452/399 373/426/399\nf 366/429/400 365/454/400 380/455/400 381/430/400\nf 378/445/401 377/441/401 392/456/401 393/457/401\nf 386/447/402 385/443/402 400/458/402 401/459/402\nf 379/449/403 378/445/403 393/457/403 394/460/403\nf 372/452/404 326/461/404 387/462/404\nf 482/463/405 386/447/405 401/459/405\nf 380/455/406 379/449/406 394/460/406 395/464/406\nf 373/426/407 372/452/407 387/462/407 388/465/407\nf 381/430/408 380/455/408 395/464/408 396/466/408\nf 374/427/409 373/426/409 388/465/409 389/467/409\nf 382/431/410 381/430/410 396/466/410 397/468/410\nf 375/433/411 374/427/411 389/467/411 390/469/411\nf 383/435/412 382/431/412 397/468/412 398/470/412\nf 376/437/413 375/433/413 390/469/413 391/471/413\nf 384/439/414 383/435/414 398/470/414 399/472/414\nf 377/441/415 376/437/415 391/471/415 392/456/415\nf 385/443/416 384/439/416 399/472/416 400/458/416\nf 397/468/417 396/466/417 411/473/417 412/474/417\nf 390/469/418 389/467/418 404/475/418 405/476/418\nf 398/470/419 397/468/419 412/474/419 413/477/419\nf 391/471/420 390/469/420 405/476/420 406/478/420\nf 399/472/421 398/470/421 413/477/421 414/479/421\nf 392/456/422 391/471/422 406/478/422 407/480/422\nf 400/458/423 399/472/423 414/479/423 415/481/423\nf 393/457/424 392/456/424 407/480/424 408/482/424\nf 401/459/425 400/458/425 415/481/425 416/483/425\nf 394/460/426 393/457/426 408/482/426 409/484/426\nf 387/462/427 326/485/427 402/486/427\nf 482/487/428 401/459/428 416/483/428\nf 395/464/429 394/460/429 409/484/429 410/488/429\nf 388/465/430 387/462/430 402/486/430 403/489/430\nf 396/466/431 395/464/431 410/488/431 411/473/431\nf 389/467/432 388/465/432 403/489/432 404/475/432\nf 416/483/433 415/481/433 430/490/433 431/491/433\nf 409/484/434 408/482/434 423/492/434 424/493/434\nf 402/486/435 326/494/435 417/495/435\nf 482/496/436 416/483/436 431/491/436\nf 410/488/437 409/484/437 424/493/437 425/497/437\nf 403/489/438 402/486/438 417/495/438 418/498/438\nf 411/473/439 410/488/439 425/497/439 426/499/439\nf 404/475/440 403/489/440 418/498/440 419/500/440\nf 412/474/441 411/473/441 426/499/441 427/501/441\nf 405/476/442 404/475/442 419/500/442 420/502/442\nf 413/477/443 412/474/443 427/501/443 428/503/443\nf 406/478/444 405/476/444 420/502/444 421/504/444\nf 414/479/445 413/477/445 428/503/445 429/505/445\nf 407/480/446 406/478/446 421/504/446 422/506/446\nf 415/481/447 414/479/447 429/505/447 430/490/447\nf 408/482/448 407/480/448 422/506/448 423/492/448\nf 420/502/449 419/500/449 434/507/449 435/508/449\nf 428/503/450 427/501/450 442/509/450 443/510/450\nf 421/504/451 420/502/451 435/508/451 436/511/451\nf 429/505/452 428/503/452 443/510/452 444/512/452\nf 422/506/453 421/504/453 436/511/453 437/513/453\nf 430/490/454 429/505/454 444/512/454 445/514/454\nf 423/492/455 422/506/455 437/513/455 438/515/455\nf 431/491/456 430/490/456 445/514/456 446/516/456\nf 424/493/457 423/492/457 438/515/457 439/517/457\nf 417/495/458 326/518/458 432/519/458\nf 482/520/459 431/491/459 446/516/459\nf 425/497/460 424/493/460 439/517/460 440/521/460\nf 418/498/461 417/495/461 432/519/461 433/522/461\nf 426/499/462 425/497/462 440/521/462 441/523/462\nf 419/500/463 418/498/463 433/522/463 434/507/463\nf 427/501/464 426/499/464 441/523/464 442/509/464\nf 439/517/465 438/515/465 453/524/465 454/525/465\nf 432/519/466 326/526/466 447/527/466\nf 482/528/467 446/516/467 461/529/467\nf 440/521/468 439/517/468 454/525/468 455/530/468\nf 433/522/469 432/519/469 447/527/469 448/531/469\nf 441/523/470 440/521/470 455/530/470 456/532/470\nf 434/507/471 433/522/471 448/531/471 449/533/471\nf 442/509/472 441/523/472 456/532/472 457/534/472\nf 435/508/473 434/507/473 449/533/473 450/535/473\nf 443/510/474 442/509/474 457/534/474 458/536/474\nf 436/511/475 435/508/475 450/535/475 451/537/475\nf 444/512/476 443/510/476 458/536/476 459/538/476\nf 437/513/477 436/511/477 451/537/477 452/539/477\nf 445/514/478 444/512/478 459/538/478 460/540/478\nf 438/515/479 437/513/479 452/539/479 453/524/479\nf 446/516/480 445/514/480 460/540/480 461/529/480\nf 458/536/481 457/534/481 472/541/481 473/542/481\nf 451/537/482 450/535/482 465/543/482 466/544/482\nf 459/538/483 458/536/483 473/542/483 474/545/483\nf 452/539/484 451/537/484 466/544/484 467/546/484\nf 460/540/485 459/538/485 474/545/485 475/547/485\nf 453/524/486 452/539/486 467/546/486 468/548/486\nf 461/529/487 460/540/487 475/547/487 476/549/487\nf 454/525/488 453/524/488 468/548/488 469/550/488\nf 447/527/489 326/551/489 462/552/489\nf 482/553/490 461/529/490 476/549/490\nf 455/530/491 454/525/491 469/550/491 470/554/491\nf 448/531/492 447/527/492 462/552/492 463/555/492\nf 456/532/493 455/530/493 470/554/493 471/556/493\nf 449/533/494 448/531/494 463/555/494 464/557/494\nf 457/534/495 456/532/495 471/556/495 472/541/495\nf 450/535/496 449/533/496 464/557/496 465/543/496\nf 482/558/497 476/549/497 481/5/497\nf 470/554/498 469/550/498 477/8/498 478/7/498\nf 463/555/499 462/552/499 1/1/499 2/11/499\nf 471/556/500 470/554/500 478/7/500 479/13/500\nf 464/557/501 463/555/501 2/11/501 3/15/501\nf 472/541/502 471/556/502 479/13/502 8/17/502\nf 465/543/503 464/557/503 3/15/503 4/19/503\nf 473/542/504 472/541/504 8/17/504 9/21/504\nf 466/544/505 465/543/505 4/19/505 5/23/505\nf 474/545/506 473/542/506 9/21/506 10/25/506\nf 467/546/507 466/544/507 5/23/507 6/27/507\nf 475/547/508 474/545/508 10/25/508 480/29/508\nf 468/548/509 467/546/509 6/27/509 7/31/509\nf 476/549/510 475/547/510 480/29/510 481/5/510\nf 469/550/511 468/548/511 7/31/511 477/8/511\nf 462/552/512 326/559/512 1/1/512\n\n",
                );
                (il.name = "sphere"), Zo.add(il);
                var rl = il.uuid;
                el.push(il),
                    $o.addKeyframeTrack(
                        new za(
                            rl + ".position",
                            [
                                0, 0.016666666666666666, 0.03333333333333333,
                                0.05, 0.06666666666666667, 0.08333333333333333,
                                0.1, 0.11666666666666667, 0.13333333333333333,
                                0.15, 0.16666666666666666, 0.18333333333333332,
                                0.2, 0.21666666666666667, 0.23333333333333334,
                                0.25, 0.26666666666666666, 0.2833333333333333,
                                0.3, 0.31666666666666665, 0.3333333333333333,
                                0.35, 0.36666666666666664, 0.38333333333333336,
                                0.4, 0.4166666666666667, 0.43333333333333335,
                                0.45, 0.4666666666666667, 0.48333333333333334,
                                0.5, 0.5166666666666667, 0.5333333333333333,
                                0.55, 0.5666666666666667, 0.5833333333333334,
                                0.6, 0.6166666666666667, 0.6333333333333333,
                                0.65, 0.6666666666666666, 0.6833333333333333,
                                0.7, 0.7166666666666667, 0.7333333333333333,
                                0.75, 0.7666666666666667, 0.7833333333333333,
                                0.8, 0.8166666666666667, 0.8333333333333334,
                                0.85, 0.8666666666666667, 0.8833333333333333,
                                0.9, 0.9166666666666666, 0.9333333333333333,
                                0.95, 0.9666666666666667, 0.9833333333333333, 1,
                                1.0166666666666666, 1.0333333333333334, 1.05,
                                1.0666666666666667, 1.0833333333333333, 1.1,
                                1.1166666666666667, 1.1333333333333333, 1.15,
                                1.1666666666666667, 1.1833333333333333, 1.2,
                                1.2166666666666666, 1.2333333333333334, 1.25,
                                1.2666666666666666, 1.2833333333333334, 1.3,
                                1.3166666666666667, 1.3333333333333333, 1.35,
                                1.3666666666666667, 1.3833333333333333, 1.4,
                                1.4166666666666667, 1.4333333333333333, 1.45,
                                1.4666666666666666, 1.4833333333333334, 1.5,
                                1.5166666666666666, 1.5333333333333334, 1.55,
                                1.5666666666666667, 1.5833333333333333, 1.6,
                                1.6166666666666667, 1.6333333333333333, 1.65,
                                1.6666666666666667, 1.6833333333333333, 1.7,
                                1.7166666666666666, 1.7333333333333334, 1.75,
                                1.7666666666666666, 1.7833333333333334, 1.8,
                                1.8166666666666667, 1.8333333333333333, 1.85,
                                1.8666666666666667, 1.8833333333333333, 1.9,
                                1.9166666666666667, 1.9333333333333333, 1.95,
                                1.9666666666666666, 1.9833333333333334, 2,
                                2.0166666666666666, 2.033333333333333, 2.05,
                                2.066666666666667, 2.0833333333333335, 2.1,
                                2.1166666666666667, 2.1333333333333333, 2.15,
                                2.1666666666666665, 2.183333333333333, 2.2,
                                2.216666666666667, 2.2333333333333334, 2.25,
                                2.2666666666666666, 2.283333333333333, 2.3,
                                2.316666666666667, 2.3333333333333335, 2.35,
                                2.3666666666666667, 2.3833333333333333, 2.4,
                                2.4166666666666665, 2.433333333333333, 2.45,
                                2.466666666666667, 2.4833333333333334, 2.5,
                                2.5166666666666666, 2.533333333333333, 2.55,
                                2.566666666666667, 2.5833333333333335, 2.6,
                                2.6166666666666667, 2.6333333333333333, 2.65,
                                2.6666666666666665, 2.683333333333333, 2.7,
                                2.716666666666667, 2.7333333333333334, 2.75,
                                2.7666666666666666, 2.783333333333333, 2.8,
                                2.816666666666667, 2.8333333333333335, 2.85,
                                2.8666666666666667, 2.8833333333333333, 2.9,
                                2.9166666666666665, 2.933333333333333, 2.95,
                                2.966666666666667, 2.9833333333333334,
                            ],
                            [
                                1, 0, 6.4998296875, 1, 0, 6.497445938124821, 1,
                                0, 6.492339968632181, 1, 0, 6.484514630461776,
                                1, 0, 6.473973363204215, 1, 0,
                                6.4607201916627535, 1, 0, 6.444759722413651, 1,
                                0, 6.426097139871406, 1, 0, 6.404738201865982,
                                1, 0, 6.380689234740051, 1, 0, 6.35395712797509,
                                1.007041154697358, 5014112287484417e-32,
                                6.345775628804096, 1.0158585689171808,
                                50800780541058287e-33, 6.339704216867228,
                                1.025360419183536, 5134416989437432e-32,
                                6.333004275367884, 1.0363425579039538,
                                5245981225228671e-32, 6.3273942352040775,
                                1.0482156335894486, 139280181676276e-31,
                                6.32182973930258, 1.0607010130234704,
                                -3207553326342771e-32, 6.315738543933498,
                                1.0737933890334475, 5264400320055512e-32,
                                6.309106888101519, 1.0874859969679576,
                                6462462111265743e-32, 6.301916086784658,
                                1.101765770352276, 15424661436988164e-33,
                                6.29412560205681, 1.1166272328999016,
                                -12603510510539814e-32, 6.285721615964524,
                                1.1320615165736672, -4628069885715926e-31,
                                6.276678629398244, 1.1480561620475451,
                                -7471127603828787e-31, 6.266958780485134,
                                1.1645974993105468, -1217948264707438e-30,
                                6.256520176457516, 1.1816706424373602,
                                -1485924419185995e-30, 6.245316885677669,
                                1.1992594955360425, -17519040191077595e-31,
                                6.233298970494966, 1.2181037529595762,
                                -191117207419611e-29, 6.222500946716235,
                                1.2382030102370638, -19670633642273784e-31,
                                6.212927601764155, 1.2587989754789608,
                                -1895804659878714e-30, 6.202492476417128,
                                1.2798840684021684, -1874530581334599e-30,
                                6.191175920182882, 1.3014349694672125,
                                -19116058443053033e-31, 6.178903490877686,
                                1.3234529771212353, -17592232285152084e-31,
                                6.165687055528078, 1.3459260577048946,
                                -17604192880512543e-31, 6.151492082347584,
                                1.3688371541812296, -16861310117664543e-31,
                                6.136266740024915, 1.3925930716875203,
                                -17030767327147854e-31, 6.121318546474066,
                                1.4180239129661367, -17063066293045212e-31,
                                6.109309783412089, 1.4438466243479906,
                                -14559032905381921e-31, 6.096129737780938,
                                1.4700548613548914, -16212895513060372e-31,
                                6.081764478570924, 1.496617716693184,
                                -1680248906311885e-30, 6.066114517254932,
                                1.5235465720614774, -17372693279049492e-31,
                                6.049228529039012, 1.5508285977922593,
                                -20814514467528395e-31, 6.03107079656711,
                                1.5793413560177127, -2133189507252215e-30,
                                6.014718078563658, 1.6090378318302132,
                                -20009454905935846e-31, 6.000010058296658,
                                1.6390413904744137, -1817516977229026e-30,
                                5.983890166496669, 1.6693463772568802,
                                -14675049882765436e-31, 5.966348160801971,
                                1.6999389235680782, -12053098098641687e-31,
                                5.947345447428309, 1.7308037584973242,
                                -9069245205073487e-31, 5.9268389180397865,
                                1.7629681092489098, -39802392546706876e-32,
                                5.908429593249786, 1.7963827872307245,
                                15379296342307892e-32, 5.8919490067109495,
                                1.8299922141191918, 4795530944706613e-31,
                                5.873715665672859, 1.8637869059629184,
                                3559723959382466e-31, 5.853707148117857,
                                1.8977383201016451, 9450627362048305e-32,
                                5.831834984564478, 1.9324296712850848,
                                -54256130056086827e-33, 5.810149680092431,
                                1.9689222446630674, 39339467080511604e-32,
                                5.792366086337568, 2.0055044048475246,
                                8669314770596136e-31, 5.772507915410254,
                                2.0422253656396028, 11268728108210429e-31,
                                5.750758867081449, 2.079075000892248,
                                13607384013831942e-31, 5.72709561420172,
                                2.116642070005977, 177855285596212e-29,
                                5.703588934106608, 2.1560749711785823,
                                2805285971505943e-30, 5.684257982861814,
                                2.1955393095673026, 3724846418491194e-30,
                                5.662697426895033, 2.235010722731311,
                                4595528151917977e-30, 5.638834858161987,
                                2.274543512683303, 550896247660073e-29,
                                5.612873372572196, 2.315441331133763,
                                8447873040129577e-30, 5.589382997701083,
                                2.357615330700945, 13424353690609644e-30,
                                5.568055174676489, 2.399735434393731,
                                18297222462741872e-30, 5.544250519286994,
                                2.441812944333419, 2299944376142242e-29,
                                5.518022336900438, 2.4844827637071787,
                                2679773790296352e-29, 5.491604652129681,
                                2.5290370184227395, 28052422415751994e-30,
                                5.46951925671048, 2.5734766523520016,
                                2929818091015605e-29, 5.444785721293249,
                                2.6177955574352847, 3054055506107886e-29,
                                5.417397177879561, 2.6620507253019285,
                                3174882143046128e-29, 5.387568166106361,
                                2.7089990686135215, 32615227159622917e-30,
                                5.3649447583293846, 2.7558176166975894,
                                33479237589593705e-30, 5.339661741247985,
                                2.802504611147666, 3434082026995413e-29,
                                5.3117276591062135, 2.849058125044046,
                                3519993964046596e-29, 5.2811513870769256,
                                2.897863919636188, 3575017771573236e-29,
                                5.256283423333805, 2.9467504167570873,
                                3663711764730469e-29, 5.229535873701234,
                                2.995494640815218, 375214763413577e-28,
                                5.200144162614316, 3.0440946163371088,
                                38403217957190816e-30, 5.16811747782941,
                                3.0951361231883885, 3820477562523342e-29,
                                5.1425048465713985, 3.146079049174521,
                                3797449116011461e-29, 5.114430192405892,
                                3.1968687592239116, 37744899298519406e-30,
                                5.083718070890539, 3.247816438830954,
                                3767179785005807e-29, 5.051472814754043,
                                3.3008677368099377, 37994793137001586e-30,
                                5.02450302219279, 3.353756696154921,
                                3831680004824708e-29, 4.9948939055321375,
                                3.406481422569572, 3863780705064061e-29,
                                4.96265492753825, 3.4598252098024442,
                                38446108457465876e-30, 4.930540871172618,
                                3.51469567308538, 36904058908044315e-30,
                                4.901728836803072, 3.5693928268947865,
                                3536687995346698e-29, 4.870286054372089,
                                3.6239147160077625, 3383462654225106e-29,
                                4.836222320014768, 3.6798012613124937,
                                3285085377973863e-29, 4.804935498361539,
                                3.7363387492244526, 3223463416313241e-29,
                                4.7739332408827675, 3.7926919889869026,
                                316204227242547e-28, 4.740310367315159,
                                3.8492777072955318, 30905082057525296e-30,
                                4.705540917730641, 3.907589916436951,
                                29571412201367795e-30, 4.674854344862205,
                                3.9657088469808377, 2824216285753807e-29,
                                4.641547891916303, 4.023632539268925,
                                26917378845760798e-30, 4.605631779869148,
                                4.082986398980081, 25594198975080373e-30,
                                4.572802465837226, 4.142748039572805,
                                24209670127887083e-30, 4.539488952040973,
                                4.20230553848517, 22829870736621823e-30,
                                4.503567747179246, 4.262555324650393,
                                20893802540100412e-30, 4.468189554333699,
                                4.32393511761551, 18255395040036015e-30,
                                4.434888571221973, 4.385101817286712,
                                15626147345140724e-30, 4.398981768430894,
                                4.446345012064844, 13232530504082079e-30,
                                4.361499167507281, 4.5092303057304655,
                                12700655903865975e-30, 4.327921850195021,
                                4.571893649048367, 12170658527171937e-30,
                                4.2917416696271875, 4.634333084491829,
                                11642554930474149e-30, 4.252969440953636,
                                4.698424091281322, 8975720354618366e-30,
                                4.218173694149602, 4.7624685160584805,
                                5923339005312251e-30, 4.181423132335911,
                                4.826280328840968, 28820440310750993e-31,
                                4.14208478335769, 4.891728411455644,
                                903307231803933e-30, 4.106704298862197,
                                4.957169849192409, -8428826529857034e-31,
                                4.069542961469855, 5.02236992216458,
                                -2582632142743471e-30, 4.02979747505916,
                                5.088880347035814, -7005947291940196e-30,
                                3.9929068338002494, 5.1556259117469105,
                                -12274018216894463e-30, 3.9551159107239355,
                                5.222121467855003, -1752235654900644e-29,
                                3.9147453899868507, 5.289741933663142,
                                -21174734879436317e-30, 3.876616748323043,
                                5.357565235201953, -2428895236959781e-29,
                                3.8375112389396593, 5.425172962981631,
                                -27415070424466195e-30, 3.7959831305012117,
                                5.494637883241789, -3218839935814691e-29,
                                3.7592885324641565, 5.563837541717525,
                                -3694350064907168e-29, 3.720012980311685,
                                5.632770105028903, -4168024831529915e-29,
                                3.678167988455574, 5.7027772358619755,
                                -43928452392249495e-30, 3.638458007639818,
                                5.772770070780404, -4578635362622579e-29,
                                3.597083345776982, 5.843322890229792,
                                -4701114632232074e-29, 3.5560685008044777,
                                5.914846820807117, -4697251370301889e-29,
                                3.516854320824623, 5.986089032936812,
                                -4693403324987246e-29, 3.475073643167005,
                                6.057723115339782, -4644925455069688e-29,
                                3.433098808762592, 6.1300145413582925,
                                -4568757167915448e-29, 3.391864297318127,
                                6.20201642227075, -449289395365846e-28,
                                3.3480740543168146, 6.275514910984266,
                                -4347130067630514e-29, 3.3079843268188283,
                                6.348904672178947, -4195412803375428e-29,
                                3.2659875749290124, 6.42209434053971,
                                -4051612092560851e-29, 3.221782105217651,
                                6.496581499480546, -4231672682520338e-29,
                                3.180613816773205, 6.57076477921848,
                                -4410998693938652e-29, 3.1368926685777296,
                                6.645585133117735, -47301454139959615e-30,
                                3.0939251800994327, 6.721021342529698,
                                -51881216724346053e-30, 3.051640609671363,
                                6.796145669606398, -5644204480684139e-29,
                                3.0068101053871565, 6.872008689826918,
                                -6234618405011522e-29, 2.963121862235418,
                                6.94790533873871, -6867887149979843e-29,
                                2.918117837079582, 7.024722967115841,
                                -7346010258987525e-29, 2.874915156301907,
                                7.102139736888864, -770459940325156e-28,
                                2.832389574362835, 7.179230769213341,
                                -806167975409433e-28, 2.787322242104334,
                                7.256347767212108, -8463203566751362e-29,
                                2.7409605689016763, 7.33363318667354,
                                -890063982789202e-28, 2.6938141113220295,
                                7.4127521178426425, -9082820596289427e-29,
                                2.6517141169727503, 7.492255199574356,
                                -9179945496266636e-29, 2.6095885691063185,
                                7.571418605220647, -927665543112422e-28,
                                2.5649223875990526, 7.65024081361576,
                                -9372948542530795e-29, 2.517728143779927,
                                7.728720167931278, -9468822806422758e-29,
                                2.4680186477033486, 7.808751520184616,
                                -9828315442109389e-29, 2.4224317098176873,
                                7.889265942255702, -1030593866232693e-28,
                                2.3772245909573595, 7.969428733290767,
                                -10781475956278927e-29, 2.3294943884810864,
                                8.050251804174511, -11261125501150082e-29,
                                2.282793016587067, 8.130876994817804,
                                -11733909494502329e-29, 2.234129210070957,
                                8.213084166273395, -1204703726188623e-28,
                                2.189735041261391, 8.295066925805198,
                                -12340071628912227e-29, 2.143297914010857,
                                8.376685495073453, -12631804255621542e-29,
                                2.094346633165014, 8.45864726818809,
                                -12984742556846496e-29, 2.045369146961705,
                                8.541419767544442, -13293275385702995e-29,
                                1.9980112647277224, 8.62534882435215,
                                -13551383421740734e-29, 1.9534775693922009,
                                8.70890248682501, -13808337003073606e-29,
                                1.9064226522150198, 8.792079437555234,
                                -14064132078261611e-29, 1.8568595151193037,
                                8.87487822527399, -14318764184200293e-29,
                                1.8048013831603362, 8.95963551819905,
                                -14515721728360393e-29, 1.7584284669267056,
                                9.044786853155966, -14692994159572604e-29,
                                1.712261257505795, 9.129551042570208,
                                -1486946061127061e-28, 1.6635836153923986,
                                9.213926791614004, -15045118387815312e-29,
                                1.612408746566714, 9.298289653046542,
                                -1524968866930611e-28, 1.560067897738906,
                                9.384813746772432, -15567014485830723e-29,
                                1.5141611297894826, 9.47094074554497,
                                -15882883962567373e-29, 1.4657447557713255,
                                9.556669473335383, -16197292786448162e-29,
                                1.4148320153905676, 9.64199862087151,
                                -16510236155737082e-29, 1.3614363621595154,
                                9.729444114495136, -17092761545940593e-29,
                                1.3143637636917318, 9.817321683145025,
                                -17762733202135258e-29, 1.2677130689341267,
                                9.904790552811457, -18429588969496872e-29,
                                1.2185591074959365, 9.991849626110358,
                                -1909332048165577e-28, 1.1669152422828182,
                                10.078497672770343, -1975391835911989e-28,
                                1.1127950451780315, 10.166237537412425,
                                -20369629071056867e-29, 1.0614654509507182,
                                10.254062663404298, -20968546027178464e-29,
                                1.0094053983270685,
                            ],
                        ),
                    ),
                    $o.addKeyframeTrack(
                        new za(
                            rl + ".quaternion",
                            [
                                0, 0.016666666666666666, 0.03333333333333333,
                                0.05, 0.06666666666666667, 0.08333333333333333,
                                0.1, 0.11666666666666667, 0.13333333333333333,
                                0.15, 0.16666666666666666, 0.18333333333333332,
                                0.2, 0.21666666666666667, 0.23333333333333334,
                                0.25, 0.26666666666666666, 0.2833333333333333,
                                0.3, 0.31666666666666665, 0.3333333333333333,
                                0.35, 0.36666666666666664, 0.38333333333333336,
                                0.4, 0.4166666666666667, 0.43333333333333335,
                                0.45, 0.4666666666666667, 0.48333333333333334,
                                0.5, 0.5166666666666667, 0.5333333333333333,
                                0.55, 0.5666666666666667, 0.5833333333333334,
                                0.6, 0.6166666666666667, 0.6333333333333333,
                                0.65, 0.6666666666666666, 0.6833333333333333,
                                0.7, 0.7166666666666667, 0.7333333333333333,
                                0.75, 0.7666666666666667, 0.7833333333333333,
                                0.8, 0.8166666666666667, 0.8333333333333334,
                                0.85, 0.8666666666666667, 0.8833333333333333,
                                0.9, 0.9166666666666666, 0.9333333333333333,
                                0.95, 0.9666666666666667, 0.9833333333333333, 1,
                                1.0166666666666666, 1.0333333333333334, 1.05,
                                1.0666666666666667, 1.0833333333333333, 1.1,
                                1.1166666666666667, 1.1333333333333333, 1.15,
                                1.1666666666666667, 1.1833333333333333, 1.2,
                                1.2166666666666666, 1.2333333333333334, 1.25,
                                1.2666666666666666, 1.2833333333333334, 1.3,
                                1.3166666666666667, 1.3333333333333333, 1.35,
                                1.3666666666666667, 1.3833333333333333, 1.4,
                                1.4166666666666667, 1.4333333333333333, 1.45,
                                1.4666666666666666, 1.4833333333333334, 1.5,
                                1.5166666666666666, 1.5333333333333334, 1.55,
                                1.5666666666666667, 1.5833333333333333, 1.6,
                                1.6166666666666667, 1.6333333333333333, 1.65,
                                1.6666666666666667, 1.6833333333333333, 1.7,
                                1.7166666666666666, 1.7333333333333334, 1.75,
                                1.7666666666666666, 1.7833333333333334, 1.8,
                                1.8166666666666667, 1.8333333333333333, 1.85,
                                1.8666666666666667, 1.8833333333333333, 1.9,
                                1.9166666666666667, 1.9333333333333333, 1.95,
                                1.9666666666666666, 1.9833333333333334, 2,
                                2.0166666666666666, 2.033333333333333, 2.05,
                                2.066666666666667, 2.0833333333333335, 2.1,
                                2.1166666666666667, 2.1333333333333333, 2.15,
                                2.1666666666666665, 2.183333333333333, 2.2,
                                2.216666666666667, 2.2333333333333334, 2.25,
                                2.2666666666666666, 2.283333333333333, 2.3,
                                2.316666666666667, 2.3333333333333335, 2.35,
                                2.3666666666666667, 2.3833333333333333, 2.4,
                                2.4166666666666665, 2.433333333333333, 2.45,
                                2.466666666666667, 2.4833333333333334, 2.5,
                                2.5166666666666666, 2.533333333333333, 2.55,
                                2.566666666666667, 2.5833333333333335, 2.6,
                                2.6166666666666667, 2.6333333333333333, 2.65,
                                2.6666666666666665, 2.683333333333333, 2.7,
                                2.716666666666667, 2.7333333333333334, 2.75,
                                2.7666666666666666, 2.783333333333333, 2.8,
                                2.816666666666667, 2.8333333333333335, 2.85,
                                2.8666666666666667, 2.8833333333333333, 2.9,
                                2.9166666666666665, 2.933333333333333, 2.95,
                                2.966666666666667, 2.9833333333333334,
                            ],
                            [
                                0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1,
                                0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1,
                                0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1,
                                3045208712907889e-32, 0.004442137414374181,
                                -20586426619774422e-33, 0.9999901336589236,
                                3039735808011988e-32, 0.009789555866672458,
                                -207421851944962e-31, 0.9999520811498586,
                                30472369418996946e-33, 0.015596510872169322,
                                -2092987193701611e-32, 0.999878367027017,
                                3026277263079415e-32, 0.02174938473901471,
                                -20631371106772943e-33, 0.9997634541547687,
                                2926055594475272e-33, 0.028149569921997013,
                                -8565955393439142e-33, 0.9996037223386108,
                                -2932814685251884e-32, 0.034829068139657186,
                                6044346685415359e-33, 0.9993932839540813,
                                27010130487086284e-33, 0.04180716710658812,
                                -1980480650652867e-32, 0.9991256981874311,
                                34236112573729036e-33, 0.049102869150739505,
                                -22775230042098696e-33, 0.9987937265727921,
                                3294882112880741e-34, 0.056731915888088846,
                                -6433924964845743e-33, 0.9983894479208335,
                                -9536314543443799e-32, 0.06471472764862525,
                                3994688331969882e-32, 0.9979038049959346,
                                -32182958887309826e-32, 0.07306979253092188,
                                15060041255004053e-32, 0.9973268297902589,
                                -5141006934300726e-31, 0.08181332188861004,
                                2439572316493255e-31, 0.9966476711263367,
                                -8313166543455307e-31, 0.09096041849225105,
                                40144150484695216e-32, 0.9958545085843186,
                                -10169023817546542e-31, 0.10052482828998602,
                                4891834735533792e-31, 0.9949345500570723,
                                -12037698583454548e-31, 0.11051867550605153,
                                5774404905721092e-31, 0.9938740475353948,
                                -13166983044240536e-31, 0.12103512704178841,
                                6563036978201997e-31, 0.9926482247110394,
                                -13633553226434717e-31, 0.1318975178963148,
                                7154945422461035e-31, 0.9912633579290578,
                                -13242543249343094e-31, 0.142984434155494,
                                7446504227416878e-31, 0.9897249373382653,
                                -1324122659466361e-30, 0.1543204905978004,
                                787011422742198e-30, 0.9880208429894858,
                                -1368569270105347e-30, 0.16592008545747503,
                                8447762939855361e-31, 0.9861392017569245,
                                -12844878765028927e-31, 0.17781184974976105,
                                8538924423011959e-31, 0.9840645030121595,
                                -13107145997648318e-31, 0.19001468379458625,
                                9048579432336748e-31, 0.9817812485184484,
                                -12882559027744835e-31, 0.20254243761310117,
                                9352526964957699e-31, 0.9792734862977467,
                                -133333608025479e-29, 0.21552206220718548,
                                9942956094538034e-31, 0.9764989711730176,
                                -1377182338384651e-30, 0.2290545258847788,
                                1054155280759974e-30, 0.9734135935827583,
                                -12399227567238332e-31, 0.24272929797166706,
                                10720259125251595e-31, 0.9700940613704331,
                                -14063613225336394e-31, 0.25657020579099127,
                                11646205940376168e-31, 0.9665255969193823,
                                -14991824824469258e-31, 0.2705845467046674,
                                12360852607337682e-31, 0.9626962153683942,
                                -15935874080344162e-31, 0.2848048155604661,
                                13080979881384812e-31, 0.9585855293261885,
                                -18964919009483972e-31, 0.29924565477327497,
                                1441107778680613e-30, 0.9541761043430683,
                                -2001050541507012e-30, 0.31422142476702364,
                                15279946425870768e-31, 0.949349722819458,
                                -19834335816145014e-31, 0.3295853860499707,
                                15953794347239579e-31, 0.9441257719723002,
                                -1931457738213262e-30, 0.3450154724215522,
                                16566651174668397e-31, 0.9385969975392704,
                                -1760097976210862e-30, 0.3605313418432159,
                                16979265624881878e-31, 0.9327470994587602,
                                -1655936072533723e-30, 0.37614616319990474,
                                17505084766425303e-31, 0.9265603401344085,
                                -15279234780332173e-31, 0.39186931761058624,
                                17964388974015895e-31, 0.9200208899342522,
                                -12581080660620284e-31, 0.4080684822246025,
                                1816054572472034e-30, 0.912951320616225,
                                -9671882280965157e-31, 0.42461634663453945,
                                1842308429981692e-30, 0.9053733805291254,
                                -8453112395948338e-31, 0.44112194102032426,
                                1877005317559311e-30, 0.8974471756880521,
                                -10581886326400267e-31, 0.4575947681066513,
                                193214391113678e-29, 0.8891608562017449,
                                -1374073772249853e-30, 0.4740311213095907,
                                1994283512182169e-30, 0.8805080897016064,
                                -16115451488023463e-31, 0.4906501701862415,
                                20699704610987668e-31, 0.8713566494244548,
                                -14198432571036223e-31, 0.5077324829930691,
                                2169824895666118e-30, 0.8615147855456068,
                                -12089856002455384e-31, 0.5246590362444807,
                                2269230431527783e-30, 0.8513124547937806,
                                -11574594294750493e-31, 0.5414635172288598,
                                23614876757034873e-31, 0.8407242470097744,
                                -11254486173550742e-31, 0.558150183066214,
                                24517975721088123e-31, 0.8297399430804521,
                                -9607065242128442e-31, 0.574914680099813,
                                2566246218626101e-30, 0.818213364964011,
                                -35531985786840835e-32, 0.5920635100513859,
                                27595657437300345e-31, 0.8058913078484172,
                                1717840295032689e-31, 0.6089636018054054,
                                29396064578082733e-31, 0.7931981667125735,
                                6636494808879567e-31, 0.6256080151876607,
                                31133568483697873e-31, 0.7801375592374435,
                                11885016757973364e-31, 0.6420288965083509,
                                32892172920318717e-31, 0.7666804393280614,
                                3176884073848526e-30, 0.6586268088535043,
                                3885525439930213e-30, 0.7524697513252274,
                                663765758633675e-29, 0.6753031883980096,
                                4895524170650253e-30, 0.7375402387256457,
                                10022934137716602e-30, 0.6916253403984157,
                                58853494283597824e-31, 0.7222564561973646,
                                13283774113711778e-30, 0.7075972621975601,
                                6845735664711046e-30, 0.7066159597196466,
                                15968083632188575e-30, 0.7233850070437903,
                                7591096942809057e-30, 0.6904448794684884,
                                1704714849935736e-29, 0.7393075555972621,
                                7719321676134428e-30, 0.6733679070439883,
                                18110710022929845e-30, 0.7547896971053106,
                                784174856218344e-29, 0.6559668536928325,
                                1916179786233779e-29, 0.7698248213901293,
                                795962831859464e-29, 0.6382552345039213,
                                20183875078945522e-30, 0.7844388769793358,
                                8069288039718526e-30, 0.6202061337034636,
                                21241222522634067e-30, 0.7992936061943539,
                                8232790916172894e-30, 0.6009407051422172,
                                22283290639725816e-30, 0.8136384066498055,
                                8391014152023589e-30, 0.5813712610925705,
                                23309578577697745e-30, 0.8274687195974717,
                                854390477543107e-29, 0.5615118147356484,
                                2431960169514921e-29, 0.8407803627025147,
                                869141378995263e-29, 0.5413763771109962,
                                25375505140009652e-30, 0.8540781572037813,
                                8896947288207254e-30, 0.5201446927417345,
                                26648840544326403e-30, 0.8668542480787707,
                                924912270594168e-29, 0.4985616437189981,
                                27902082144276198e-30, 0.879053133116508,
                                9594563642131047e-30, 0.47672380804617964,
                                2913459805597075e-29, 0.8906717051723891,
                                9933105462844468e-30, 0.454647020891272,
                                3000181062356611e-29, 0.9021682392288366,
                                10033340663753585e-30, 0.4313843624040405,
                                3083330949696503e-29, 0.9130379036729529,
                                10117162602805057e-30, 0.4078747190700834,
                                31641935808150583e-30, 0.9232678536772349,
                                10193996156308832e-30, 0.384156830430271,
                                3254339417546383e-29, 0.9329020891422223,
                                10381106469519122e-30, 0.3601301043707359,
                                33867579205960645e-30, 0.942209589311075,
                                11031552278559696e-30, 0.335024013781483,
                                3516387344081762e-29, 0.9508183262808896,
                                116722992220419e-28, 0.30974910880970713,
                                36431577674189764e-30, 0.9587279586638037,
                                12302967447025658e-30, 0.2843249923526525,
                                3750023657923614e-29, 0.9660270268720921,
                                12744832746585629e-30, 0.25844106359606694,
                                38051190220612784e-30, 0.9727839376450568,
                                12652953246985426e-30, 0.2317140709145182,
                                3857177063465271e-29, 0.9787853547295166,
                                1255176232596473e-29, 0.20488833389681943,
                                390618410340096e-28, 0.9840331729469235,
                                1244141689218706e-29, 0.17798515258304579,
                                3988253712693431e-29, 0.9886345374335264,
                                12871677171175325e-30, 0.15033878871933667,
                                4089521390936199e-29, 0.9924961941768237,
                                13630061299923958e-30, 0.12227552716926116,
                                41872254329166406e-30, 0.9955536055281251,
                                1437533652222449e-29, 0.09419670121586121,
                                42804505914212753e-30, 0.9978235907265931,
                                15104537309112044e-30, 0.06593998627152076,
                                4360294372270133e-29, 0.9993211138152166,
                                15712625945470114e-30, 0.036841708471715695,
                                4436214263064956e-29, 0.9999695848163285,
                                1630561646149805e-29, 0.0077993231924190325,
                                450818072241248e-28, 0.9997760396137647,
                                16883139145712116e-30, -0.021162953815950493,
                                45846541691026325e-30, 0.9987101563148016,
                                17699276842865206e-30, -0.05077424222639435,
                                46580204950705366e-30, 0.9967518120919121,
                                1854865791921189e-29, -0.08053462045288025,
                                47270389091426874e-30, 0.9939168533057948,
                                193790281766975e-28, -0.11013305005631638,
                                4781716605900706e-29, 0.990157561219634,
                                19936486234674857e-30, -0.13995715044107812,
                                4819901168194103e-29, 0.9854116077858536,
                                20186412735418087e-30, -0.17018802320051554,
                                48534746006503325e-30, 0.9797619305339932,
                                20416747554339745e-30, -0.20016632952697785,
                                4886742129220484e-29, 0.9731914143110444,
                                20834128307543886e-30, -0.2299966763048309,
                                4950072889805246e-29, 0.9655052613295273,
                                22845311609846123e-30, -0.2603835446893698,
                                5008363048046051e-29, 0.9568993981277945,
                                24827788972676654e-30, -0.29041959620980234,
                                506160294455531e-28, 0.9473909899834612,
                                26779881778366736e-30, -0.3200786029995715,
                                50891007227388115e-30, 0.9366768406270433,
                                27409407787181726e-30, -0.3501949403302974,
                                51073371867387984e-30, 0.9250085233758593,
                                27745857175726106e-30, -0.37994635368958657,
                                5120324050821711e-29, 0.9124375681270082,
                                2805302465052088e-29, -0.4092159384365074,
                                51288138799554144e-30, 0.8985918727103095,
                                2936518860793129e-29, -0.43878542170288526,
                                513219174603142e-28, 0.8837831729007389,
                                30840941850575784e-30, -0.467896680152256,
                                51301105724608345e-30, 0.8680847516146516,
                                32279128840979255e-30, -0.4964160190950012,
                                -5131285764425602e-29, -0.8511122164089001,
                                -3187639875040421e-29, 0.5249838045878458,
                                -5129564384702099e-29, -0.8331262102832528,
                                -3086074413321848e-29, 0.5530829212144098,
                                -51221677167606723e-30, -0.8142773516132531,
                                -2981429027206387e-29, 0.5804760069543843,
                                -50873539116155656e-30, -0.7941644197596714,
                                -3000974249940707e-29, 0.6077029491353355,
                                -503955997912881e-28, -0.7730643199985128,
                                -3059313269422356e-29, 0.6343276417950247,
                                -49865081791076275e-30, -0.7511352139153884,
                                -31124880554911894e-30, 0.6601483851500992,
                                -4954446509832748e-29, -0.7277162667382424,
                                -3055023064708605e-29, 0.6858782946883181,
                                -4916528856947077e-29, -0.7035015572340595,
                                -29940768409969583e-30, 0.7106937167087193,
                                -4872861270761592e-29, -0.6785285625323837,
                                -2929758900081934e-29, 0.7345740192980806,
                                -475849754026078e-28, -0.6522781292819398,
                                -3038347738306375e-29, 0.7579797108501342,
                                -4628637971071879e-29, -0.625202168803648,
                                -3170193268112008e-29, 0.7804628422437643,
                                -44718570458025626e-30, -0.5971296407290732,
                                -3340897303488035e-29, 0.8021447451443959,
                                -4267050987920792e-29, -0.5679052522614664,
                                -3593139236021442e-29, 0.8230939341617336,
                                -405748078124312e-28, -0.5380537490537906,
                                -38398688042617764e-30, 0.8429105309160401,
                                -3824137244292635e-29, -0.5073139751525665,
                                -4111308924275741e-29, 0.8617612956120165,
                                -3572890422815241e-29, -0.4755819687302874,
                                -4397100030598977e-29, 0.8796714108226003,
                                -33178226196692635e-30, -0.4433352476244141,
                                -4676063662366604e-29, 0.8963558769896025,
                                -30192828544476206e-30, -0.40981795425099693,
                                -49975388667490707e-30, 0.9121673335378371,
                                -27138416814685892e-30, -0.3757711227400137,
                                -5315788596546107e-29, 0.9267125030529747,
                                -24087817100386267e-30, -0.34128943764338854,
                                -56222741086871715e-30, 0.939958254260826,
                                -22516192568627768e-30, -0.3056524987419848,
                                -575263812954975e-28, 0.9521431352547688,
                                -20918571366264432e-30, -0.26971513530624797,
                                -5874408818956942e-29, 0.9629401569083784,
                                -2000154325479678e-29, -0.23305231579713484,
                                -5923103360448486e-29, 0.9724641988791117,
                                -197623845604221e-28, -0.19571850668599577,
                                -5898742459668691e-29, 0.980660117543588,
                                -19495402148089138e-30, -0.15823898316790813,
                                -586590200333067e-28, 0.9874008427209218,
                                -19952448657331704e-30, -0.12008558071380933,
                                -5767701042595555e-29, 0.9927635435009825,
                                -20628116596792666e-30, -0.08170261338900298,
                                -5642337076127652e-29, 0.99665675283189,
                                -20256915509242982e-30, -0.042747858302304674,
                                -5566825658584608e-29, 0.9990858925090306,
                                -19076341620085473e-30, -0.003424242327372368,
                                -5527680706523799e-29, 0.9999941372650559,
                                -17870909795547657e-30, 0.03575514407257817,
                                -54801810259935487e-30, 0.9993605804074669,
                                -16948141767114616e-30, 0.07494800656629129,
                                -5409627013223646e-29, 0.9971874429171975,
                                -16250955704546242e-30, 0.11418648023227058,
                                -531883973169886e-28, 0.9934593337083131,
                                -13775344837828456e-30, 0.15405866782274938,
                                -52782487709498794e-30, 0.988061701954225,
                                -10702786981588526e-30, 0.19384486624243782,
                                -52485705400324925e-30, 0.9810321951044478,
                                -7624801916427806e-30, 0.23316185166777695,
                                -5210490014202425e-29, 0.9724379419412087,
                                -4546463239786277e-30, 0.27195106242836015,
                                -5164166642873658e-29, 0.9623110825736583,
                                -1472747684192473e-30, 0.3101559418421265,
                                -5109770558648537e-29, 0.9506856955587495,
                                -34501314013474586e-32, 0.3485797799271627,
                                -5021259763907052e-29, 0.9372791137254317,
                                -9890932029161126e-32, 0.38665709741052984,
                                -4912662203556097e-29, 0.9222235569654812,
                                14639216937916652e-32, 0.4239403480879066,
                                -4796303574796965e-29, 0.905690113263419,
                                33020924599434614e-32, 0.4608939501967654,
                                -4672050178609859e-29, 0.8874552195305527,
                                5459490274175437e-31, 0.49700635493066886,
                                -4540528099854256e-29, 0.8677469004027211,
                                1864662648259161e-30, 0.5329241212152154,
                                -4394800701216819e-29, 0.8461630345429836,
                                33094933418790354e-31, 0.5678269582576168,
                                -4241195016145676e-29, 0.8231479487163306,
                                4742797219440949e-30, 0.6016036872790234,
                                -40808346931859223e-30, 0.7987947192190764,
                                5679523939903241e-30, 0.634543066226874,
                                -3920834533145869e-29, 0.7728875061115926,
                                6864975124606891e-30, 0.6666215435713708,
                                -3747474536761363e-29, 0.745396349364902,
                                8327956808218452e-30, 0.6978701414818423,
                                -3560111434348933e-29, 0.7162243123687672,
                                976985348425316e-29, 0.7277239044273419,
                                -3367045106230567e-29, 0.6858701910165108,
                                11188295966263133e-30, 0.7561454246779183,
                                -3168696394790973e-29, 0.6544036191362717,
                                12581006433470288e-30, 0.7831007155567604,
                                -2965487516678855e-29, 0.6218949021293628,
                                14274999832078474e-30, 0.8091792778479848,
                                -27414453829661974e-30, 0.5875618233866234,
                                16044933684867267e-30, 0.8338493228932996,
                                -25077663499162675e-30, 0.5519921255873002,
                                17777703166245094e-30, 0.8568649911765767,
                                -2270378941679306e-29, 0.5155408683081925,
                                1947053026481568e-29, 0.878203636132238,
                                -20297717958150355e-30, 0.47828691544314267,
                                20949848027883965e-30, 0.8979192226001972,
                                -17996584577091623e-30, 0.44016027726847123,
                                2174214367842813e-29, 0.9163916830547735,
                                -1616110920840133e-29, 0.4002827540976998,
                                2248940535279867e-29, 0.9330282392341502,
                                -14302264856294363e-30, 0.3598031472786492,
                                23190755667177463e-30, 0.9478197192927975,
                                -1242391760183043e-29, 0.31880680626317026,
                                23845425611497235e-30, 0.9607607696452365,
                                -10529892305390391e-30, 0.27737834001719175,
                                2317897051802948e-29, 0.972109656280764,
                                -10085013885180995e-30, 0.23452679199975196,
                                220459457895581e-28, 0.9815828640145264,
                                -10108192703470142e-30, 0.19103685789145405,
                                20874294278258287e-30, 0.9890838096637489,
                                -10111374928634654e-30, 0.1473540547831824,
                                1966681253225337e-29, 0.9946224822122017,
                                -10094805578708236e-30, 0.10356697291143756,
                                18426311183061675e-30, 0.9982126202590506,
                                -10058764408287989e-30, 0.05976256985405311,
                                17308530929061365e-30, 0.9998849872414044,
                                -9746220647765566e-30, 0.015166156047480011,
                                16211886700656685e-30, 0.9995630847430134,
                                -9329979776832626e-30, -0.029557395335710182,
                            ],
                        ),
                    );
                var al = new (class extends ns {
                    constructor(t, e, n) {
                        super(t, n),
                            (this.isHemisphereLight = !0),
                            (this.type = "HemisphereLight"),
                            this.position.copy(Me.DefaultUp),
                            this.updateMatrix(),
                            (this.groundColor = new ct(e));
                    }
                    copy(t, e) {
                        return (
                            super.copy(t, e),
                            this.groundColor.copy(t.groundColor),
                            this
                        );
                    }
                })(16777215, 4473924);
                Zo.add(al), al.position.set(0, 20, 0);
                var sl = new (class extends ns {
                    constructor(t, e) {
                        super(t, e),
                            (this.isDirectionalLight = !0),
                            (this.type = "DirectionalLight"),
                            this.position.copy(Me.DefaultUp),
                            this.updateMatrix(),
                            (this.target = new Me()),
                            (this.shadow = new os());
                    }
                    dispose() {
                        this.shadow.dispose();
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            (this.target = t.target.clone()),
                            (this.shadow = t.shadow.clone()),
                            this
                        );
                    }
                })(16777215);
                Zo.add(sl),
                    sl.position.set(-3, 10, -10),
                    tl.addFollowableObjects(el),
                    $o.lock();
                var ol = !1;
                const ll = new (class extends Oo {
                    constructor() {
                        super(...arguments), (this.rotate_with_object = !0);
                    }
                    addVideoControls(t, e) {
                        (this.mixer = e),
                            (this.clip_action = e.clip_action),
                            (this.video_controls =
                                this.addFolder("Video controls")),
                            (this.pause_play_button = this.video_controls.add(
                                { "Pause/Play": t },
                                "Pause/Play",
                            )),
                            this.pause_play_button.name("⏸");
                        var n = this.setLoop.bind(this);
                        (this.loop_button = this.video_controls.add(
                            { loop: n },
                            "loop",
                        )),
                            this.loop_button.name("🔃"),
                            (this.looping = !0),
                            (this.real_time_slider = this.video_controls.add(
                                { rt: 1 },
                                "rt",
                                0.01,
                                5,
                            ));
                        var i = this.updateRealTimeFactor.bind(this);
                        this.real_time_slider.onChange(i),
                            this.real_time_slider.name("Real time factor"),
                            this.real_time_slider.setValue(1),
                            (this.max_time =
                                this.clip_action.getClip().duration),
                            (this.time_slider = this.video_controls.add(
                                { Time: 0 },
                                "Time",
                                0,
                                this.max_time,
                            )),
                            this.time_slider.onChange(this.setTime.bind(this)),
                            this.video_controls.open();
                    }
                    addCameraControls(t) {
                        (this.camera = t),
                            (this.camera_controls =
                                this.addFolder("Camera controls"));
                        var e = { None: -1 };
                        this.camera.followable_objs.forEach(
                            (t) => (e[t.name] = t.id),
                        ),
                            (this.follow_control = this.camera_controls.add(
                                { name: "Follow object" },
                                "name",
                                e,
                            ));
                        var n = this.setCameraToFollow.bind(this);
                        this.follow_control.name("Follow object"),
                            this.follow_control.onChange(n),
                            this.follow_control.setValue(-1),
                            (this.rotation_control = this.camera_controls.add(
                                { value: !0 },
                                "value",
                            )),
                            this.rotation_control.name("Rotate with object"),
                            this.rotation_control.setValue(!0);
                        var i = this.setCameraRotation.bind(this);
                        this.rotation_control.onChange(i);
                    }
                    setCameraRotation(t) {
                        (this.rotate_with_object = t),
                            (this.camera.rotation = t),
                            this.setCameraToFollow(
                                this.follow_control.getValue(),
                            );
                    }
                    setCameraToFollow(t) {
                        if (t < 0)
                            (this.camera.follow_obj = null),
                                this.camera.scene.add(this.camera.camera);
                        else if (
                            ((this.camera.follow_obj =
                                this.camera.scene.getObjectById(Math.trunc(t))),
                            this.rotate_with_object)
                        )
                            this.camera.follow_obj.attach(this.camera.camera);
                        else {
                            this.camera.scene.attach(this.camera.camera);
                            var e = new St(),
                                n = new St();
                            this.camera.camera.getWorldPosition(e),
                                this.camera.follow_obj.getWorldPosition(n),
                                this.camera.follow_obj_offset.subVectors(e, n);
                        }
                    }
                    updateRealTimeFactor(t) {
                        this.clip_action.setEffectiveTimeScale(t);
                    }
                    pause() {
                        this.pause_play_button.name("▶");
                    }
                    play() {
                        this.pause_play_button.name("⏸");
                    }
                    setLoop() {
                        this.looping
                            ? ((this.looping = !1),
                              this.clip_action.setLoop(2200, 1 / 0),
                              this.loop_button.name("🔂"))
                            : ((this.looping = !0),
                              this.clip_action.setLoop(2201, 1 / 0),
                              this.clip_action.reset().play(),
                              this.loop_button.name("🔃"));
                    }
                    updateTime() {
                        this.updateControllerWithoutCB(
                            this.time_slider,
                            this.clip_action.time,
                        );
                    }
                    setTime(t) {
                        this.mixer.setTime(
                            t / this.clip_action.getEffectiveTimeScale(),
                        );
                    }
                    updateControllerWithoutCB(t, e) {
                        (t.object[t.property] = e), t.updateDisplay();
                    }
                })();
                ll.addVideoControls(function () {
                    ol
                        ? ((ol = !1), cl.start(), ll.play())
                        : ((ol = !0), cl.stop(), ll.pause());
                }, $o),
                    ll.addCameraControls(tl);
                const cl = new (class {
                    constructor(t = !0) {
                        (this.autoStart = t),
                            (this.startTime = 0),
                            (this.oldTime = 0),
                            (this.elapsedTime = 0),
                            (this.running = !1);
                    }
                    start() {
                        (this.startTime = cs()),
                            (this.oldTime = this.startTime),
                            (this.elapsedTime = 0),
                            (this.running = !0);
                    }
                    stop() {
                        this.getElapsedTime(),
                            (this.running = !1),
                            (this.autoStart = !1);
                    }
                    getElapsedTime() {
                        return this.getDelta(), this.elapsedTime;
                    }
                    getDelta() {
                        let t = 0;
                        if (this.autoStart && !this.running)
                            return this.start(), 0;
                        if (this.running) {
                            const e = cs();
                            (t = (e - this.oldTime) / 1e3),
                                (this.oldTime = e),
                                (this.elapsedTime += t);
                        }
                        return t;
                    }
                })();
                var hl = function () {
                    requestAnimationFrame(hl),
                        (function () {
                            if (!ol) {
                                var t = cl.getDelta();
                                $o.update(t), ll.updateTime(), tl.update();
                            }
                        })(),
                        Jo.render(Zo, Xo);
                };
                Qo.update(), hl();
            })();
        </script>
    </body>
</html>
